<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'><head><title>/Library/Ruby/Gems/1.8/gems/activeresource-2.1.1/lib/active_resource/base.rb - C0 code coverage information</title>
    <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
    <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
    <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
    <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
    </head>
  <body><h3>C0 code coverage information</h3>
    <p>Generated on Tue Nov 11 15:30:16 -0500 2008 with <a href='http://eigenclass.org/hiki/rcov'>rcov 0.8.1.2</a>
      </p>
    <hr/>
    <pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
<table class='report'><thead><tr><td class='heading'>Name</td>
      <td class='heading'>Total lines</td>
      <td class='heading'>Lines of code</td>
      <td class='heading'>Total coverage</td>
      <td class='heading'>Code coverage</td>
      </tr>
    </thead>
  <tbody><tr class='light'><td><a href='-Library-Ruby-Gems-1_8-gems-activeresource-2_1_1-lib-active_resource-base_rb.html'>/Library/Ruby/Gems/1.8/gems/activeresource-2.1.1/lib/active_resource/base.rb</a>
        </td>
      <td class='lines_total'><tt>1026</tt>
        </td>
      <td class='lines_code'><tt>369</tt>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_total'>68.3%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='68'/>
                  <td class='uncovered' width='32'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_code'>21.4%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='21'/>
                  <td class='uncovered' width='79'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </tbody>
  </table>
<pre><span class="marked1"><a name="line1"></a>   1 require 'active_resource/connection'
</span><span class="marked0"><a name="line2"></a>   2 require 'cgi'
</span><span class="marked1"><a name="line3"></a>   3 require 'set'
</span><span class="inferred0"><a name="line4"></a>   4 
</span><span class="marked1"><a name="line5"></a>   5 module ActiveResource
</span><span class="inferred0"><a name="line6"></a>   6   # ActiveResource::Base is the main class for mapping RESTful resources as models in a Rails application.
</span><span class="inferred1"><a name="line7"></a>   7   #
</span><span class="inferred0"><a name="line8"></a>   8   # For an outline of what Active Resource is capable of, see link:files/vendor/rails/activeresource/README.html.
</span><span class="inferred1"><a name="line9"></a>   9   #
</span><span class="inferred0"><a name="line10"></a>  10   # == Automated mapping
</span><span class="inferred1"><a name="line11"></a>  11   #
</span><span class="inferred0"><a name="line12"></a>  12   # Active Resource objects represent your RESTful resources as manipulatable Ruby objects.  To map resources
</span><span class="inferred1"><a name="line13"></a>  13   # to Ruby objects, Active Resource only needs a class name that corresponds to the resource name (e.g., the class
</span><span class="inferred0"><a name="line14"></a>  14   # Person maps to the resources people, very similarly to Active Record) and a +site+ value, which holds the
</span><span class="inferred1"><a name="line15"></a>  15   # URI of the resources.
</span><span class="inferred0"><a name="line16"></a>  16   # 
</span><span class="inferred1"><a name="line17"></a>  17   #   class Person &lt; ActiveResource::Base
</span><span class="inferred0"><a name="line18"></a>  18   #     self.site = &quot;http://api.people.com:3000/&quot;
</span><span class="inferred1"><a name="line19"></a>  19   #   end
</span><span class="inferred0"><a name="line20"></a>  20   # 
</span><span class="inferred1"><a name="line21"></a>  21   # Now the Person class is mapped to RESTful resources located at &lt;tt&gt;http://api.people.com:3000/people/&lt;/tt&gt;, and
</span><span class="inferred0"><a name="line22"></a>  22   # you can now use Active Resource's lifecycles methods to manipulate resources. In the case where you already have 
</span><span class="inferred1"><a name="line23"></a>  23   # an existing model with the same name as the desired RESTful resource you can set the +element_name+ value.
</span><span class="inferred0"><a name="line24"></a>  24   #
</span><span class="inferred1"><a name="line25"></a>  25   #   class PersonResource &lt; ActiveResource::Base
</span><span class="inferred0"><a name="line26"></a>  26   #     self.site = &quot;http://api.people.com:3000/&quot;
</span><span class="inferred1"><a name="line27"></a>  27   #     self.element_name = &quot;person&quot;
</span><span class="inferred0"><a name="line28"></a>  28   #   end
</span><span class="inferred1"><a name="line29"></a>  29   #  
</span><span class="inferred0"><a name="line30"></a>  30   # 
</span><span class="inferred1"><a name="line31"></a>  31   # == Lifecycle methods
</span><span class="inferred0"><a name="line32"></a>  32   #
</span><span class="inferred1"><a name="line33"></a>  33   # Active Resource exposes methods for creating, finding, updating, and deleting resources
</span><span class="inferred0"><a name="line34"></a>  34   # from REST web services.
</span><span class="inferred1"><a name="line35"></a>  35   # 
</span><span class="inferred0"><a name="line36"></a>  36   #   ryan = Person.new(:first =&gt; 'Ryan', :last =&gt; 'Daigle')
</span><span class="inferred1"><a name="line37"></a>  37   #   ryan.save                # =&gt; true
</span><span class="inferred0"><a name="line38"></a>  38   #   ryan.id                  # =&gt; 2
</span><span class="inferred1"><a name="line39"></a>  39   #   Person.exists?(ryan.id)  # =&gt; true
</span><span class="inferred0"><a name="line40"></a>  40   #   ryan.exists?             # =&gt; true
</span><span class="inferred1"><a name="line41"></a>  41   # 
</span><span class="inferred0"><a name="line42"></a>  42   #   ryan = Person.find(1)
</span><span class="inferred1"><a name="line43"></a>  43   #   # Resource holding our newly created Person object
</span><span class="inferred0"><a name="line44"></a>  44   # 
</span><span class="inferred1"><a name="line45"></a>  45   #   ryan.first = 'Rizzle'
</span><span class="inferred0"><a name="line46"></a>  46   #   ryan.save                # =&gt; true
</span><span class="inferred1"><a name="line47"></a>  47   # 
</span><span class="inferred0"><a name="line48"></a>  48   #   ryan.destroy             # =&gt; true
</span><span class="inferred1"><a name="line49"></a>  49   #
</span><span class="inferred0"><a name="line50"></a>  50   # As you can see, these are very similar to Active Record's lifecycle methods for database records.
</span><span class="inferred1"><a name="line51"></a>  51   # You can read more about each of these methods in their respective documentation.
</span><span class="inferred0"><a name="line52"></a>  52   # 
</span><span class="inferred1"><a name="line53"></a>  53   # === Custom REST methods
</span><span class="inferred0"><a name="line54"></a>  54   #
</span><span class="inferred1"><a name="line55"></a>  55   # Since simple CRUD/lifecycle methods can't accomplish every task, Active Resource also supports
</span><span class="inferred0"><a name="line56"></a>  56   # defining your own custom REST methods. To invoke them, Active Resource provides the &lt;tt&gt;get&lt;/tt&gt;,
</span><span class="inferred1"><a name="line57"></a>  57   # &lt;tt&gt;post&lt;/tt&gt;, &lt;tt&gt;put&lt;/tt&gt; and &lt;tt&gt;delete&lt;/tt&gt; methods where you can specify a custom REST method
</span><span class="inferred0"><a name="line58"></a>  58   # name to invoke.
</span><span class="inferred1"><a name="line59"></a>  59   #
</span><span class="inferred0"><a name="line60"></a>  60   #   # POST to the custom 'register' REST method, i.e. POST /people/new/register.xml.
</span><span class="inferred1"><a name="line61"></a>  61   #   Person.new(:name =&gt; 'Ryan').post(:register)
</span><span class="inferred0"><a name="line62"></a>  62   #   # =&gt; { :id =&gt; 1, :name =&gt; 'Ryan', :position =&gt; 'Clerk' }
</span><span class="inferred1"><a name="line63"></a>  63   #
</span><span class="inferred0"><a name="line64"></a>  64   #   # PUT an update by invoking the 'promote' REST method, i.e. PUT /people/1/promote.xml?position=Manager.
</span><span class="inferred1"><a name="line65"></a>  65   #   Person.find(1).put(:promote, :position =&gt; 'Manager')
</span><span class="inferred0"><a name="line66"></a>  66   #   # =&gt; { :id =&gt; 1, :name =&gt; 'Ryan', :position =&gt; 'Manager' }
</span><span class="inferred1"><a name="line67"></a>  67   #
</span><span class="inferred0"><a name="line68"></a>  68   #   # GET all the positions available, i.e. GET /people/positions.xml.
</span><span class="inferred1"><a name="line69"></a>  69   #   Person.get(:positions)
</span><span class="inferred0"><a name="line70"></a>  70   #   # =&gt; [{:name =&gt; 'Manager'}, {:name =&gt; 'Clerk'}]
</span><span class="inferred1"><a name="line71"></a>  71   #
</span><span class="inferred0"><a name="line72"></a>  72   #   # DELETE to 'fire' a person, i.e. DELETE /people/1/fire.xml.
</span><span class="inferred1"><a name="line73"></a>  73   #   Person.find(1).delete(:fire)
</span><span class="inferred0"><a name="line74"></a>  74   # 
</span><span class="inferred1"><a name="line75"></a>  75   # For more information on using custom REST methods, see the
</span><span class="inferred0"><a name="line76"></a>  76   # ActiveResource::CustomMethods documentation.
</span><span class="inferred1"><a name="line77"></a>  77   #
</span><span class="inferred0"><a name="line78"></a>  78   # == Validations
</span><span class="inferred1"><a name="line79"></a>  79   #
</span><span class="inferred0"><a name="line80"></a>  80   # You can validate resources client side by overriding validation methods in the base class.
</span><span class="inferred1"><a name="line81"></a>  81   # 
</span><span class="inferred0"><a name="line82"></a>  82   #   class Person &lt; ActiveResource::Base
</span><span class="inferred1"><a name="line83"></a>  83   #      self.site = &quot;http://api.people.com:3000/&quot;
</span><span class="inferred0"><a name="line84"></a>  84   #      protected
</span><span class="inferred1"><a name="line85"></a>  85   #        def validate
</span><span class="inferred0"><a name="line86"></a>  86   #          errors.add(&quot;last&quot;, &quot;has invalid characters&quot;) unless last =~ /[a-zA-Z]*/
</span><span class="inferred1"><a name="line87"></a>  87   #        end
</span><span class="inferred0"><a name="line88"></a>  88   #   end
</span><span class="inferred1"><a name="line89"></a>  89   # 
</span><span class="inferred0"><a name="line90"></a>  90   # See the ActiveResource::Validations documentation for more information.
</span><span class="inferred1"><a name="line91"></a>  91   #
</span><span class="inferred0"><a name="line92"></a>  92   # == Authentication
</span><span class="inferred1"><a name="line93"></a>  93   # 
</span><span class="inferred0"><a name="line94"></a>  94   # Many REST APIs will require authentication, usually in the form of basic
</span><span class="inferred1"><a name="line95"></a>  95   # HTTP authentication.  Authentication can be specified by:
</span><span class="inferred0"><a name="line96"></a>  96   # * putting the credentials in the URL for the +site+ variable.
</span><span class="inferred1"><a name="line97"></a>  97   # 
</span><span class="inferred0"><a name="line98"></a>  98   #    class Person &lt; ActiveResource::Base
</span><span class="inferred1"><a name="line99"></a>  99   #      self.site = &quot;http://ryan:password@api.people.com:3000/&quot;
</span><span class="inferred0"><a name="line100"></a> 100   #    end
</span><span class="inferred1"><a name="line101"></a> 101   # 
</span><span class="inferred0"><a name="line102"></a> 102   # * defining +user+ and/or +password+ variables
</span><span class="inferred1"><a name="line103"></a> 103   #
</span><span class="inferred0"><a name="line104"></a> 104   #    class Person &lt; ActiveResource::Base
</span><span class="inferred1"><a name="line105"></a> 105   #      self.site = &quot;http://api.people.com:3000/&quot;
</span><span class="inferred0"><a name="line106"></a> 106   #      self.user = &quot;ryan&quot;
</span><span class="inferred1"><a name="line107"></a> 107   #      self.password = &quot;password&quot;
</span><span class="inferred0"><a name="line108"></a> 108   #    end
</span><span class="inferred1"><a name="line109"></a> 109   #
</span><span class="inferred0"><a name="line110"></a> 110   # For obvious security reasons, it is probably best if such services are available 
</span><span class="inferred1"><a name="line111"></a> 111   # over HTTPS.
</span><span class="inferred0"><a name="line112"></a> 112   # 
</span><span class="inferred1"><a name="line113"></a> 113   # Note: Some values cannot be provided in the URL passed to site.  e.g. email addresses 
</span><span class="inferred0"><a name="line114"></a> 114   # as usernames.  In those situations you should use the seperate user and password option.
</span><span class="inferred1"><a name="line115"></a> 115   # == Errors &amp; Validation
</span><span class="inferred0"><a name="line116"></a> 116   #
</span><span class="inferred1"><a name="line117"></a> 117   # Error handling and validation is handled in much the same manner as you're used to seeing in
</span><span class="inferred0"><a name="line118"></a> 118   # Active Record.  Both the response code in the HTTP response and the body of the response are used to
</span><span class="inferred1"><a name="line119"></a> 119   # indicate that an error occurred.
</span><span class="inferred0"><a name="line120"></a> 120   # 
</span><span class="inferred1"><a name="line121"></a> 121   # === Resource errors
</span><span class="inferred0"><a name="line122"></a> 122   # 
</span><span class="inferred1"><a name="line123"></a> 123   # When a GET is requested for a resource that does not exist, the HTTP &lt;tt&gt;404&lt;/tt&gt; (Resource Not Found)
</span><span class="inferred0"><a name="line124"></a> 124   # response code will be returned from the server which will raise an ActiveResource::ResourceNotFound
</span><span class="inferred1"><a name="line125"></a> 125   # exception.
</span><span class="inferred0"><a name="line126"></a> 126   # 
</span><span class="inferred1"><a name="line127"></a> 127   #   # GET http://api.people.com:3000/people/999.xml
</span><span class="inferred0"><a name="line128"></a> 128   #   ryan = Person.find(999) # 404, raises ActiveResource::ResourceNotFound
</span><span class="inferred1"><a name="line129"></a> 129   # 
</span><span class="inferred0"><a name="line130"></a> 130   # &lt;tt&gt;404&lt;/tt&gt; is just one of the HTTP error response codes that Active Resource will handle with its own exception. The
</span><span class="inferred1"><a name="line131"></a> 131   # following HTTP response codes will also result in these exceptions:
</span><span class="inferred0"><a name="line132"></a> 132   # 
</span><span class="inferred1"><a name="line133"></a> 133   # * 200..399 - Valid response, no exception
</span><span class="inferred0"><a name="line134"></a> 134   # * 404 - ActiveResource::ResourceNotFound
</span><span class="inferred1"><a name="line135"></a> 135   # * 409 - ActiveResource::ResourceConflict
</span><span class="inferred0"><a name="line136"></a> 136   # * 422 - ActiveResource::ResourceInvalid (rescued by save as validation errors)
</span><span class="inferred1"><a name="line137"></a> 137   # * 401..499 - ActiveResource::ClientError
</span><span class="inferred0"><a name="line138"></a> 138   # * 500..599 - ActiveResource::ServerError
</span><span class="inferred1"><a name="line139"></a> 139   #
</span><span class="inferred0"><a name="line140"></a> 140   # These custom exceptions allow you to deal with resource errors more naturally and with more precision
</span><span class="inferred1"><a name="line141"></a> 141   # rather than returning a general HTTP error.  For example:
</span><span class="inferred0"><a name="line142"></a> 142   #
</span><span class="inferred1"><a name="line143"></a> 143   #   begin
</span><span class="inferred0"><a name="line144"></a> 144   #     ryan = Person.find(my_id)
</span><span class="inferred1"><a name="line145"></a> 145   #   rescue ActiveResource::ResourceNotFound
</span><span class="inferred0"><a name="line146"></a> 146   #     redirect_to :action =&gt; 'not_found'
</span><span class="inferred1"><a name="line147"></a> 147   #   rescue ActiveResource::ResourceConflict, ActiveResource::ResourceInvalid
</span><span class="inferred0"><a name="line148"></a> 148   #     redirect_to :action =&gt; 'new'
</span><span class="inferred1"><a name="line149"></a> 149   #   end
</span><span class="inferred0"><a name="line150"></a> 150   #
</span><span class="inferred1"><a name="line151"></a> 151   # === Validation errors
</span><span class="inferred0"><a name="line152"></a> 152   # 
</span><span class="inferred1"><a name="line153"></a> 153   # Active Resource supports validations on resources and will return errors if any these validations fail
</span><span class="inferred0"><a name="line154"></a> 154   # (e.g., &quot;First name can not be blank&quot; and so on).  These types of errors are denoted in the response by 
</span><span class="inferred1"><a name="line155"></a> 155   # a response code of &lt;tt&gt;422&lt;/tt&gt; and an XML representation of the validation errors.  The save operation will
</span><span class="inferred0"><a name="line156"></a> 156   # then fail (with a &lt;tt&gt;false&lt;/tt&gt; return value) and the validation errors can be accessed on the resource in question.
</span><span class="inferred1"><a name="line157"></a> 157   # 
</span><span class="inferred0"><a name="line158"></a> 158   #   ryan = Person.find(1)
</span><span class="inferred1"><a name="line159"></a> 159   #   ryan.first # =&gt; ''
</span><span class="inferred0"><a name="line160"></a> 160   #   ryan.save  # =&gt; false
</span><span class="inferred1"><a name="line161"></a> 161   #
</span><span class="inferred0"><a name="line162"></a> 162   #   # When 
</span><span class="inferred1"><a name="line163"></a> 163   #   # PUT http://api.people.com:3000/people/1.xml
</span><span class="inferred0"><a name="line164"></a> 164   #   # is requested with invalid values, the response is:
</span><span class="inferred1"><a name="line165"></a> 165   #   #
</span><span class="inferred0"><a name="line166"></a> 166   #   # Response (422):
</span><span class="inferred1"><a name="line167"></a> 167   #   # &lt;errors type=&quot;array&quot;&gt;&lt;error&gt;First cannot be empty&lt;/error&gt;&lt;/errors&gt;
</span><span class="inferred0"><a name="line168"></a> 168   #   #
</span><span class="inferred1"><a name="line169"></a> 169   #
</span><span class="inferred0"><a name="line170"></a> 170   #   ryan.errors.invalid?(:first)  # =&gt; true
</span><span class="inferred1"><a name="line171"></a> 171   #   ryan.errors.full_messages     # =&gt; ['First cannot be empty']
</span><span class="inferred0"><a name="line172"></a> 172   # 
</span><span class="inferred1"><a name="line173"></a> 173   # Learn more about Active Resource's validation features in the ActiveResource::Validations documentation.
</span><span class="inferred0"><a name="line174"></a> 174   #
</span><span class="inferred1"><a name="line175"></a> 175   # === Timeouts
</span><span class="inferred0"><a name="line176"></a> 176   #
</span><span class="inferred1"><a name="line177"></a> 177   # Active Resource relies on HTTP to access RESTful APIs and as such is inherently susceptible to slow or
</span><span class="inferred0"><a name="line178"></a> 178   # unresponsive servers. In such cases, your Active Resource method calls could timeout. You can control the
</span><span class="inferred1"><a name="line179"></a> 179   # amount of time before Active Resource times out with the +timeout+ variable.
</span><span class="inferred0"><a name="line180"></a> 180   #
</span><span class="inferred1"><a name="line181"></a> 181   #   class Person &lt; ActiveResource::Base
</span><span class="inferred0"><a name="line182"></a> 182   #     self.site = &quot;http://api.people.com:3000/&quot;
</span><span class="inferred1"><a name="line183"></a> 183   #     self.timeout = 5
</span><span class="inferred0"><a name="line184"></a> 184   #   end
</span><span class="inferred1"><a name="line185"></a> 185   #
</span><span class="inferred0"><a name="line186"></a> 186   # This sets the +timeout+ to 5 seconds. You can adjust the +timeout+ to a value suitable for the RESTful API
</span><span class="inferred1"><a name="line187"></a> 187   # you are accessing. It is recommended to set this to a reasonably low value to allow your Active Resource
</span><span class="inferred0"><a name="line188"></a> 188   # clients (especially if you are using Active Resource in a Rails application) to fail-fast (see
</span><span class="inferred1"><a name="line189"></a> 189   # http://en.wikipedia.org/wiki/Fail-fast) rather than cause cascading failures that could incapacitate your
</span><span class="inferred0"><a name="line190"></a> 190   # server.
</span><span class="inferred1"><a name="line191"></a> 191   #
</span><span class="inferred0"><a name="line192"></a> 192   # When a timeout occurs, an ActiveResource::TimeoutError is raised. You should rescue from
</span><span class="inferred1"><a name="line193"></a> 193   # ActiveResource::TimeoutError in your Active Resource method calls.
</span><span class="inferred0"><a name="line194"></a> 194   #
</span><span class="inferred1"><a name="line195"></a> 195   # Internally, Active Resource relies on Ruby's Net::HTTP library to make HTTP requests. Setting +timeout+
</span><span class="inferred0"><a name="line196"></a> 196   # sets the &lt;tt&gt;read_timeout&lt;/tt&gt; of the internal Net::HTTP instance to the same value. The default
</span><span class="inferred1"><a name="line197"></a> 197   # &lt;tt&gt;read_timeout&lt;/tt&gt; is 60 seconds on most Ruby implementations.
</span><span class="marked0"><a name="line198"></a> 198   class Base
</span><span class="inferred1"><a name="line199"></a> 199     # The logger for diagnosing and tracing Active Resource calls.
</span><span class="marked0"><a name="line200"></a> 200     cattr_accessor :logger
</span><span class="inferred1"><a name="line201"></a> 201 
</span><span class="marked0"><a name="line202"></a> 202     class &lt;&lt; self
</span><span class="inferred1"><a name="line203"></a> 203       # Gets the URI of the REST resources to map for this class.  The site variable is required 
</span><span class="inferred0"><a name="line204"></a> 204       # Active Resource's mapping to work.
</span><span class="marked1"><a name="line205"></a> 205       def site
</span><span class="uncovered0"><a name="line206"></a> 206         # Not using superclass_delegating_reader because don't want subclasses to modify superclass instance
</span><span class="uncovered1"><a name="line207"></a> 207         #
</span><span class="uncovered0"><a name="line208"></a> 208         # With superclass_delegating_reader
</span><span class="uncovered1"><a name="line209"></a> 209         #
</span><span class="uncovered0"><a name="line210"></a> 210         #   Parent.site = 'http://anonymous@test.com'
</span><span class="uncovered1"><a name="line211"></a> 211         #   Subclass.site # =&gt; 'http://anonymous@test.com'
</span><span class="uncovered0"><a name="line212"></a> 212         #   Subclass.site.user = 'david'
</span><span class="uncovered1"><a name="line213"></a> 213         #   Parent.site # =&gt; 'http://david@test.com'
</span><span class="uncovered0"><a name="line214"></a> 214         #
</span><span class="uncovered1"><a name="line215"></a> 215         # Without superclass_delegating_reader (expected behaviour)
</span><span class="uncovered0"><a name="line216"></a> 216         #
</span><span class="uncovered1"><a name="line217"></a> 217         #   Parent.site = 'http://anonymous@test.com'
</span><span class="uncovered0"><a name="line218"></a> 218         #   Subclass.site # =&gt; 'http://anonymous@test.com'
</span><span class="uncovered1"><a name="line219"></a> 219         #   Subclass.site.user = 'david' # =&gt; TypeError: can't modify frozen object
</span><span class="uncovered0"><a name="line220"></a> 220         #
</span><span class="uncovered1"><a name="line221"></a> 221         if defined?(@site)
</span><span class="uncovered0"><a name="line222"></a> 222           @site
</span><span class="uncovered1"><a name="line223"></a> 223         elsif superclass != Object &amp;&amp; superclass.site
</span><span class="uncovered0"><a name="line224"></a> 224           superclass.site.dup.freeze
</span><span class="uncovered1"><a name="line225"></a> 225         end
</span><span class="uncovered0"><a name="line226"></a> 226       end
</span><span class="inferred1"><a name="line227"></a> 227 
</span><span class="inferred0"><a name="line228"></a> 228       # Sets the URI of the REST resources to map for this class to the value in the +site+ argument.
</span><span class="inferred1"><a name="line229"></a> 229       # The site variable is required Active Resource's mapping to work.
</span><span class="marked0"><a name="line230"></a> 230       def site=(site)
</span><span class="uncovered1"><a name="line231"></a> 231         @connection = nil
</span><span class="uncovered0"><a name="line232"></a> 232         if site.nil?
</span><span class="uncovered1"><a name="line233"></a> 233           @site = nil
</span><span class="uncovered0"><a name="line234"></a> 234         else
</span><span class="uncovered1"><a name="line235"></a> 235           @site = create_site_uri_from(site)
</span><span class="uncovered0"><a name="line236"></a> 236           @user = URI.decode(@site.user) if @site.user
</span><span class="uncovered1"><a name="line237"></a> 237           @password = URI.decode(@site.password) if @site.password
</span><span class="uncovered0"><a name="line238"></a> 238         end
</span><span class="uncovered1"><a name="line239"></a> 239       end
</span><span class="inferred0"><a name="line240"></a> 240 
</span><span class="inferred1"><a name="line241"></a> 241       # Gets the user for REST HTTP authentication.
</span><span class="marked0"><a name="line242"></a> 242       def user
</span><span class="uncovered1"><a name="line243"></a> 243         # Not using superclass_delegating_reader. See +site+ for explanation
</span><span class="uncovered0"><a name="line244"></a> 244         if defined?(@user)
</span><span class="uncovered1"><a name="line245"></a> 245           @user
</span><span class="uncovered0"><a name="line246"></a> 246         elsif superclass != Object &amp;&amp; superclass.user
</span><span class="uncovered1"><a name="line247"></a> 247           superclass.user.dup.freeze
</span><span class="uncovered0"><a name="line248"></a> 248         end
</span><span class="uncovered1"><a name="line249"></a> 249       end
</span><span class="inferred0"><a name="line250"></a> 250 
</span><span class="inferred1"><a name="line251"></a> 251       # Sets the user for REST HTTP authentication.
</span><span class="marked0"><a name="line252"></a> 252       def user=(user)
</span><span class="uncovered1"><a name="line253"></a> 253         @connection = nil
</span><span class="uncovered0"><a name="line254"></a> 254         @user = user
</span><span class="uncovered1"><a name="line255"></a> 255       end
</span><span class="inferred0"><a name="line256"></a> 256 
</span><span class="inferred1"><a name="line257"></a> 257       # Gets the password for REST HTTP authentication.
</span><span class="marked0"><a name="line258"></a> 258       def password
</span><span class="uncovered1"><a name="line259"></a> 259         # Not using superclass_delegating_reader. See +site+ for explanation
</span><span class="uncovered0"><a name="line260"></a> 260         if defined?(@password)
</span><span class="uncovered1"><a name="line261"></a> 261           @password
</span><span class="uncovered0"><a name="line262"></a> 262         elsif superclass != Object &amp;&amp; superclass.password
</span><span class="uncovered1"><a name="line263"></a> 263           superclass.password.dup.freeze
</span><span class="uncovered0"><a name="line264"></a> 264         end
</span><span class="uncovered1"><a name="line265"></a> 265       end
</span><span class="inferred0"><a name="line266"></a> 266 
</span><span class="inferred1"><a name="line267"></a> 267       # Sets the password for REST HTTP authentication.
</span><span class="marked0"><a name="line268"></a> 268       def password=(password)
</span><span class="uncovered1"><a name="line269"></a> 269         @connection = nil
</span><span class="uncovered0"><a name="line270"></a> 270         @password = password
</span><span class="uncovered1"><a name="line271"></a> 271       end
</span><span class="inferred0"><a name="line272"></a> 272 
</span><span class="inferred1"><a name="line273"></a> 273       # Sets the format that attributes are sent and received in from a mime type reference:
</span><span class="inferred0"><a name="line274"></a> 274       #
</span><span class="inferred1"><a name="line275"></a> 275       #   Person.format = :json
</span><span class="inferred0"><a name="line276"></a> 276       #   Person.find(1) # =&gt; GET /people/1.json
</span><span class="inferred1"><a name="line277"></a> 277       #
</span><span class="inferred0"><a name="line278"></a> 278       #   Person.format = ActiveResource::Formats::XmlFormat
</span><span class="inferred1"><a name="line279"></a> 279       #   Person.find(1) # =&gt; GET /people/1.xml
</span><span class="inferred0"><a name="line280"></a> 280       #
</span><span class="inferred1"><a name="line281"></a> 281       # Default format is &lt;tt&gt;:xml&lt;/tt&gt;.
</span><span class="marked0"><a name="line282"></a> 282       def format=(mime_type_reference_or_format)
</span><span class="uncovered1"><a name="line283"></a> 283         format = mime_type_reference_or_format.is_a?(Symbol) ? 
</span><span class="uncovered0"><a name="line284"></a> 284           ActiveResource::Formats[mime_type_reference_or_format] : mime_type_reference_or_format
</span><span class="uncovered1"><a name="line285"></a> 285 
</span><span class="uncovered0"><a name="line286"></a> 286         write_inheritable_attribute(&quot;format&quot;, format)
</span><span class="uncovered1"><a name="line287"></a> 287         connection.format = format if site
</span><span class="uncovered0"><a name="line288"></a> 288       end
</span><span class="inferred1"><a name="line289"></a> 289 
</span><span class="inferred0"><a name="line290"></a> 290       # Returns the current format, default is ActiveResource::Formats::XmlFormat.
</span><span class="marked1"><a name="line291"></a> 291       def format # :nodoc:
</span><span class="uncovered0"><a name="line292"></a> 292         read_inheritable_attribute(&quot;format&quot;) || ActiveResource::Formats[:xml]
</span><span class="uncovered1"><a name="line293"></a> 293       end
</span><span class="inferred0"><a name="line294"></a> 294 
</span><span class="inferred1"><a name="line295"></a> 295       # Sets the number of seconds after which requests to the REST API should time out.
</span><span class="marked0"><a name="line296"></a> 296       def timeout=(timeout)
</span><span class="uncovered1"><a name="line297"></a> 297         @connection = nil
</span><span class="uncovered0"><a name="line298"></a> 298         @timeout = timeout
</span><span class="uncovered1"><a name="line299"></a> 299       end
</span><span class="inferred0"><a name="line300"></a> 300 
</span><span class="inferred1"><a name="line301"></a> 301       # Gets tthe number of seconds after which requests to the REST API should time out.
</span><span class="marked0"><a name="line302"></a> 302       def timeout
</span><span class="uncovered1"><a name="line303"></a> 303         if defined?(@timeout)
</span><span class="uncovered0"><a name="line304"></a> 304           @timeout
</span><span class="uncovered1"><a name="line305"></a> 305         elsif superclass != Object &amp;&amp; superclass.timeout
</span><span class="uncovered0"><a name="line306"></a> 306           superclass.timeout
</span><span class="uncovered1"><a name="line307"></a> 307         end
</span><span class="uncovered0"><a name="line308"></a> 308       end
</span><span class="inferred1"><a name="line309"></a> 309 
</span><span class="inferred0"><a name="line310"></a> 310       # An instance of ActiveResource::Connection that is the base connection to the remote service.
</span><span class="inferred1"><a name="line311"></a> 311       # The +refresh+ parameter toggles whether or not the connection is refreshed at every request
</span><span class="inferred0"><a name="line312"></a> 312       # or not (defaults to &lt;tt&gt;false&lt;/tt&gt;).
</span><span class="marked1"><a name="line313"></a> 313       def connection(refresh = false)
</span><span class="uncovered0"><a name="line314"></a> 314         if defined?(@connection) || superclass == Object
</span><span class="uncovered1"><a name="line315"></a> 315           @connection = Connection.new(site, format) if refresh || @connection.nil?
</span><span class="uncovered0"><a name="line316"></a> 316           @connection.user = user if user
</span><span class="uncovered1"><a name="line317"></a> 317           @connection.password = password if password
</span><span class="uncovered0"><a name="line318"></a> 318           @connection.timeout = timeout if timeout
</span><span class="uncovered1"><a name="line319"></a> 319           @connection
</span><span class="uncovered0"><a name="line320"></a> 320         else
</span><span class="uncovered1"><a name="line321"></a> 321           superclass.connection
</span><span class="uncovered0"><a name="line322"></a> 322         end
</span><span class="uncovered1"><a name="line323"></a> 323       end
</span><span class="inferred0"><a name="line324"></a> 324 
</span><span class="marked1"><a name="line325"></a> 325       def headers
</span><span class="uncovered0"><a name="line326"></a> 326         @headers ||= {}
</span><span class="uncovered1"><a name="line327"></a> 327       end
</span><span class="inferred0"><a name="line328"></a> 328 
</span><span class="inferred1"><a name="line329"></a> 329       # Do not include any modules in the default element name. This makes it easier to seclude ARes objects
</span><span class="inferred0"><a name="line330"></a> 330       # in a separate namespace without having to set element_name repeatedly.
</span><span class="marked1"><a name="line331"></a> 331       attr_accessor_with_default(:element_name)    { to_s.split(&quot;::&quot;).last.underscore } #:nodoc:
</span><span class="inferred0"><a name="line332"></a> 332 
</span><span class="marked1"><a name="line333"></a> 333       attr_accessor_with_default(:collection_name) { element_name.pluralize } #:nodoc:
</span><span class="marked0"><a name="line334"></a> 334       attr_accessor_with_default(:primary_key, 'id') #:nodoc:
</span><span class="inferred1"><a name="line335"></a> 335       
</span><span class="inferred0"><a name="line336"></a> 336       # Gets the prefix for a resource's nested URL (e.g., &lt;tt&gt;prefix/collectionname/1.xml&lt;/tt&gt;)
</span><span class="inferred1"><a name="line337"></a> 337       # This method is regenerated at runtime based on what the prefix is set to.
</span><span class="marked0"><a name="line338"></a> 338       def prefix(options={})
</span><span class="uncovered1"><a name="line339"></a> 339         default = site.path
</span><span class="uncovered0"><a name="line340"></a> 340         default &lt;&lt; '/' unless default[-1..-1] == '/'
</span><span class="uncovered1"><a name="line341"></a> 341         # generate the actual method based on the current site path
</span><span class="uncovered0"><a name="line342"></a> 342         self.prefix = default
</span><span class="uncovered1"><a name="line343"></a> 343         prefix(options)
</span><span class="uncovered0"><a name="line344"></a> 344       end
</span><span class="inferred1"><a name="line345"></a> 345 
</span><span class="inferred0"><a name="line346"></a> 346       # An attribute reader for the source string for the resource path prefix.  This
</span><span class="inferred1"><a name="line347"></a> 347       # method is regenerated at runtime based on what the prefix is set to.
</span><span class="marked0"><a name="line348"></a> 348       def prefix_source
</span><span class="uncovered1"><a name="line349"></a> 349         prefix # generate #prefix and #prefix_source methods first
</span><span class="uncovered0"><a name="line350"></a> 350         prefix_source
</span><span class="uncovered1"><a name="line351"></a> 351       end
</span><span class="inferred0"><a name="line352"></a> 352 
</span><span class="inferred1"><a name="line353"></a> 353       # Sets the prefix for a resource's nested URL (e.g., &lt;tt&gt;prefix/collectionname/1.xml&lt;/tt&gt;).
</span><span class="inferred0"><a name="line354"></a> 354       # Default value is &lt;tt&gt;site.path&lt;/tt&gt;.
</span><span class="marked1"><a name="line355"></a> 355       def prefix=(value = '/')
</span><span class="uncovered0"><a name="line356"></a> 356         # Replace :placeholders with '#{embedded options[:lookups]}'
</span><span class="uncovered1"><a name="line357"></a> 357         prefix_call = value.gsub(/:\w+/) { |key| &quot;\#{options[#{key}]}&quot; }
</span><span class="uncovered0"><a name="line358"></a> 358 
</span><span class="uncovered1"><a name="line359"></a> 359         # Clear prefix parameters in case they have been cached
</span><span class="uncovered0"><a name="line360"></a> 360         @prefix_parameters = nil
</span><span class="uncovered1"><a name="line361"></a> 361 
</span><span class="uncovered0"><a name="line362"></a> 362         # Redefine the new methods.
</span><span class="uncovered1"><a name="line363"></a> 363         code = &lt;&lt;-end_code
</span><span class="uncovered0"><a name="line364"></a> 364           def prefix_source() &quot;#{value}&quot; end
</span><span class="uncovered1"><a name="line365"></a> 365           def prefix(options={}) &quot;#{prefix_call}&quot; end
</span><span class="uncovered0"><a name="line366"></a> 366         end_code
</span><span class="uncovered1"><a name="line367"></a> 367         silence_warnings { instance_eval code, __FILE__, __LINE__ }
</span><span class="uncovered0"><a name="line368"></a> 368       rescue
</span><span class="uncovered1"><a name="line369"></a> 369         logger.error &quot;Couldn't set prefix: #{$!}\n  #{code}&quot;
</span><span class="uncovered0"><a name="line370"></a> 370         raise
</span><span class="uncovered1"><a name="line371"></a> 371       end
</span><span class="inferred0"><a name="line372"></a> 372 
</span><span class="marked1"><a name="line373"></a> 373       alias_method :set_prefix, :prefix=  #:nodoc:
</span><span class="inferred0"><a name="line374"></a> 374 
</span><span class="marked1"><a name="line375"></a> 375       alias_method :set_element_name, :element_name=  #:nodoc:
</span><span class="marked0"><a name="line376"></a> 376       alias_method :set_collection_name, :collection_name=  #:nodoc:
</span><span class="inferred1"><a name="line377"></a> 377 
</span><span class="inferred0"><a name="line378"></a> 378       # Gets the element path for the given ID in +id+.  If the +query_options+ parameter is omitted, Rails
</span><span class="inferred1"><a name="line379"></a> 379       # will split from the prefix options.
</span><span class="inferred0"><a name="line380"></a> 380       #
</span><span class="inferred1"><a name="line381"></a> 381       # ==== Options
</span><span class="inferred0"><a name="line382"></a> 382       # +prefix_options+ - A hash to add a prefix to the request for nested URLs (e.g., &lt;tt&gt;:account_id =&gt; 19&lt;/tt&gt;
</span><span class="inferred1"><a name="line383"></a> 383       #                    would yield a URL like &lt;tt&gt;/accounts/19/purchases.xml&lt;/tt&gt;).
</span><span class="inferred0"><a name="line384"></a> 384       # +query_options+ - A hash to add items to the query string for the request.
</span><span class="inferred1"><a name="line385"></a> 385       #
</span><span class="inferred0"><a name="line386"></a> 386       # ==== Examples
</span><span class="inferred1"><a name="line387"></a> 387       #   Post.element_path(1) 
</span><span class="inferred0"><a name="line388"></a> 388       #   # =&gt; /posts/1.xml
</span><span class="inferred1"><a name="line389"></a> 389       #
</span><span class="inferred0"><a name="line390"></a> 390       #   Comment.element_path(1, :post_id =&gt; 5) 
</span><span class="inferred1"><a name="line391"></a> 391       #   # =&gt; /posts/5/comments/1.xml
</span><span class="inferred0"><a name="line392"></a> 392       #
</span><span class="inferred1"><a name="line393"></a> 393       #   Comment.element_path(1, :post_id =&gt; 5, :active =&gt; 1) 
</span><span class="inferred0"><a name="line394"></a> 394       #   # =&gt; /posts/5/comments/1.xml?active=1
</span><span class="inferred1"><a name="line395"></a> 395       #
</span><span class="inferred0"><a name="line396"></a> 396       #   Comment.element_path(1, {:post_id =&gt; 5}, {:active =&gt; 1}) 
</span><span class="inferred1"><a name="line397"></a> 397       #   # =&gt; /posts/5/comments/1.xml?active=1
</span><span class="inferred0"><a name="line398"></a> 398       #
</span><span class="marked1"><a name="line399"></a> 399       def element_path(id, prefix_options = {}, query_options = nil)
</span><span class="uncovered0"><a name="line400"></a> 400         prefix_options, query_options = split_options(prefix_options) if query_options.nil?
</span><span class="uncovered1"><a name="line401"></a> 401         &quot;#{prefix(prefix_options)}#{collection_name}/#{id}.#{format.extension}#{query_string(query_options)}&quot;        
</span><span class="uncovered0"><a name="line402"></a> 402       end
</span><span class="inferred1"><a name="line403"></a> 403 
</span><span class="inferred0"><a name="line404"></a> 404       # Gets the collection path for the REST resources.  If the +query_options+ parameter is omitted, Rails
</span><span class="inferred1"><a name="line405"></a> 405       # will split from the +prefix_options+.
</span><span class="inferred0"><a name="line406"></a> 406       #
</span><span class="inferred1"><a name="line407"></a> 407       # ==== Options
</span><span class="inferred0"><a name="line408"></a> 408       # * +prefix_options+ - A hash to add a prefix to the request for nested URL's (e.g., &lt;tt&gt;:account_id =&gt; 19&lt;/tt&gt;
</span><span class="inferred1"><a name="line409"></a> 409       #   would yield a URL like &lt;tt&gt;/accounts/19/purchases.xml&lt;/tt&gt;).
</span><span class="inferred0"><a name="line410"></a> 410       # * +query_options+ - A hash to add items to the query string for the request.
</span><span class="inferred1"><a name="line411"></a> 411       #
</span><span class="inferred0"><a name="line412"></a> 412       # ==== Examples
</span><span class="inferred1"><a name="line413"></a> 413       #   Post.collection_path
</span><span class="inferred0"><a name="line414"></a> 414       #   # =&gt; /posts.xml
</span><span class="inferred1"><a name="line415"></a> 415       #
</span><span class="inferred0"><a name="line416"></a> 416       #   Comment.collection_path(:post_id =&gt; 5) 
</span><span class="inferred1"><a name="line417"></a> 417       #   # =&gt; /posts/5/comments.xml
</span><span class="inferred0"><a name="line418"></a> 418       #
</span><span class="inferred1"><a name="line419"></a> 419       #   Comment.collection_path(:post_id =&gt; 5, :active =&gt; 1) 
</span><span class="inferred0"><a name="line420"></a> 420       #   # =&gt; /posts/5/comments.xml?active=1
</span><span class="inferred1"><a name="line421"></a> 421       #
</span><span class="inferred0"><a name="line422"></a> 422       #   Comment.collection_path({:post_id =&gt; 5}, {:active =&gt; 1}) 
</span><span class="inferred1"><a name="line423"></a> 423       #   # =&gt; /posts/5/comments.xml?active=1
</span><span class="inferred0"><a name="line424"></a> 424       #
</span><span class="marked1"><a name="line425"></a> 425       def collection_path(prefix_options = {}, query_options = nil)
</span><span class="uncovered0"><a name="line426"></a> 426         prefix_options, query_options = split_options(prefix_options) if query_options.nil?
</span><span class="uncovered1"><a name="line427"></a> 427         &quot;#{prefix(prefix_options)}#{collection_name}.#{format.extension}#{query_string(query_options)}&quot;
</span><span class="uncovered0"><a name="line428"></a> 428       end
</span><span class="inferred1"><a name="line429"></a> 429 
</span><span class="marked0"><a name="line430"></a> 430       alias_method :set_primary_key, :primary_key=  #:nodoc:
</span><span class="inferred1"><a name="line431"></a> 431 
</span><span class="inferred0"><a name="line432"></a> 432       # Create a new resource instance and request to the remote service
</span><span class="inferred1"><a name="line433"></a> 433       # that it be saved, making it equivalent to the following simultaneous calls:
</span><span class="inferred0"><a name="line434"></a> 434       #
</span><span class="inferred1"><a name="line435"></a> 435       #   ryan = Person.new(:first =&gt; 'ryan')
</span><span class="inferred0"><a name="line436"></a> 436       #   ryan.save
</span><span class="inferred1"><a name="line437"></a> 437       #
</span><span class="inferred0"><a name="line438"></a> 438       # The newly created resource is returned.  If a failure has occurred an
</span><span class="inferred1"><a name="line439"></a> 439       # exception will be raised (see save).  If the resource is invalid and
</span><span class="inferred0"><a name="line440"></a> 440       # has not been saved then valid? will return &lt;tt&gt;false&lt;/tt&gt;,
</span><span class="inferred1"><a name="line441"></a> 441       # while new? will still return &lt;tt&gt;true&lt;/tt&gt;.
</span><span class="inferred0"><a name="line442"></a> 442       #
</span><span class="inferred1"><a name="line443"></a> 443       # ==== Examples
</span><span class="inferred0"><a name="line444"></a> 444       #   Person.create(:name =&gt; 'Jeremy', :email =&gt; 'myname@nospam.com', :enabled =&gt; true)
</span><span class="inferred1"><a name="line445"></a> 445       #   my_person = Person.find(:first)
</span><span class="inferred0"><a name="line446"></a> 446       #   my_person.email # =&gt; myname@nospam.com
</span><span class="inferred1"><a name="line447"></a> 447       #
</span><span class="inferred0"><a name="line448"></a> 448       #   dhh = Person.create(:name =&gt; 'David', :email =&gt; 'dhh@nospam.com', :enabled =&gt; true)
</span><span class="inferred1"><a name="line449"></a> 449       #   dhh.valid? # =&gt; true
</span><span class="inferred0"><a name="line450"></a> 450       #   dhh.new?   # =&gt; false
</span><span class="inferred1"><a name="line451"></a> 451       #
</span><span class="inferred0"><a name="line452"></a> 452       #   # We'll assume that there's a validation that requires the name attribute
</span><span class="inferred1"><a name="line453"></a> 453       #   that_guy = Person.create(:name =&gt; '', :email =&gt; 'thatguy@nospam.com', :enabled =&gt; true)
</span><span class="inferred0"><a name="line454"></a> 454       #   that_guy.valid? # =&gt; false
</span><span class="inferred1"><a name="line455"></a> 455       #   that_guy.new?   # =&gt; true
</span><span class="marked0"><a name="line456"></a> 456       def create(attributes = {})
</span><span class="uncovered1"><a name="line457"></a> 457         returning(self.new(attributes)) { |res| res.save }        
</span><span class="uncovered0"><a name="line458"></a> 458       end
</span><span class="inferred1"><a name="line459"></a> 459 
</span><span class="inferred0"><a name="line460"></a> 460       # Core method for finding resources.  Used similarly to Active Record's +find+ method.
</span><span class="inferred1"><a name="line461"></a> 461       #
</span><span class="inferred0"><a name="line462"></a> 462       # ==== Arguments
</span><span class="inferred1"><a name="line463"></a> 463       # The first argument is considered to be the scope of the query.  That is, how many 
</span><span class="inferred0"><a name="line464"></a> 464       # resources are returned from the request.  It can be one of the following.
</span><span class="inferred1"><a name="line465"></a> 465       #
</span><span class="inferred0"><a name="line466"></a> 466       # * &lt;tt&gt;:one&lt;/tt&gt; - Returns a single resource.
</span><span class="inferred1"><a name="line467"></a> 467       # * &lt;tt&gt;:first&lt;/tt&gt; - Returns the first resource found.
</span><span class="inferred0"><a name="line468"></a> 468       # * &lt;tt&gt;:all&lt;/tt&gt; - Returns every resource that matches the request.
</span><span class="inferred1"><a name="line469"></a> 469       # 
</span><span class="inferred0"><a name="line470"></a> 470       # ==== Options
</span><span class="inferred1"><a name="line471"></a> 471       #
</span><span class="inferred0"><a name="line472"></a> 472       # * &lt;tt&gt;:from&lt;/tt&gt; - Sets the path or custom method that resources will be fetched from.
</span><span class="inferred1"><a name="line473"></a> 473       # * &lt;tt&gt;:params&lt;/tt&gt; - Sets query and prefix (nested URL) parameters.
</span><span class="inferred0"><a name="line474"></a> 474       #
</span><span class="inferred1"><a name="line475"></a> 475       # ==== Examples
</span><span class="inferred0"><a name="line476"></a> 476       #   Person.find(1)                                         
</span><span class="inferred1"><a name="line477"></a> 477       #   # =&gt; GET /people/1.xml
</span><span class="inferred0"><a name="line478"></a> 478       #
</span><span class="inferred1"><a name="line479"></a> 479       #   Person.find(:all)                                      
</span><span class="inferred0"><a name="line480"></a> 480       #   # =&gt; GET /people.xml
</span><span class="inferred1"><a name="line481"></a> 481       #
</span><span class="inferred0"><a name="line482"></a> 482       #   Person.find(:all, :params =&gt; { :title =&gt; &quot;CEO&quot; })      
</span><span class="inferred1"><a name="line483"></a> 483       #   # =&gt; GET /people.xml?title=CEO
</span><span class="inferred0"><a name="line484"></a> 484       #
</span><span class="inferred1"><a name="line485"></a> 485       #   Person.find(:first, :from =&gt; :managers)                  
</span><span class="inferred0"><a name="line486"></a> 486       #   # =&gt; GET /people/managers.xml
</span><span class="inferred1"><a name="line487"></a> 487       #
</span><span class="inferred0"><a name="line488"></a> 488       #   Person.find(:all, :from =&gt; &quot;/companies/1/people.xml&quot;)  
</span><span class="inferred1"><a name="line489"></a> 489       #   # =&gt; GET /companies/1/people.xml
</span><span class="inferred0"><a name="line490"></a> 490       #
</span><span class="inferred1"><a name="line491"></a> 491       #   Person.find(:one, :from =&gt; :leader)                    
</span><span class="inferred0"><a name="line492"></a> 492       #   # =&gt; GET /people/leader.xml
</span><span class="inferred1"><a name="line493"></a> 493       #
</span><span class="inferred0"><a name="line494"></a> 494       #   Person.find(:all, :from =&gt; :developers, :params =&gt; { :language =&gt; 'ruby' })
</span><span class="inferred1"><a name="line495"></a> 495       #   # =&gt; GET /people/developers.xml?language=ruby
</span><span class="inferred0"><a name="line496"></a> 496       #
</span><span class="inferred1"><a name="line497"></a> 497       #   Person.find(:one, :from =&gt; &quot;/companies/1/manager.xml&quot;) 
</span><span class="inferred0"><a name="line498"></a> 498       #   # =&gt; GET /companies/1/manager.xml
</span><span class="inferred1"><a name="line499"></a> 499       #
</span><span class="inferred0"><a name="line500"></a> 500       #   StreetAddress.find(1, :params =&gt; { :person_id =&gt; 1 })  
</span><span class="inferred1"><a name="line501"></a> 501       #   # =&gt; GET /people/1/street_addresses/1.xml
</span><span class="marked0"><a name="line502"></a> 502       def find(*arguments)
</span><span class="uncovered1"><a name="line503"></a> 503         scope   = arguments.slice!(0)
</span><span class="uncovered0"><a name="line504"></a> 504         options = arguments.slice!(0) || {}
</span><span class="uncovered1"><a name="line505"></a> 505 
</span><span class="uncovered0"><a name="line506"></a> 506         case scope
</span><span class="uncovered1"><a name="line507"></a> 507           when :all   then find_every(options)
</span><span class="uncovered0"><a name="line508"></a> 508           when :first then find_every(options).first
</span><span class="uncovered1"><a name="line509"></a> 509           when :one   then find_one(options)
</span><span class="uncovered0"><a name="line510"></a> 510           else             find_single(scope, options)
</span><span class="uncovered1"><a name="line511"></a> 511         end
</span><span class="uncovered0"><a name="line512"></a> 512       end
</span><span class="inferred1"><a name="line513"></a> 513 
</span><span class="inferred0"><a name="line514"></a> 514       # Deletes the resources with the ID in the +id+ parameter.
</span><span class="inferred1"><a name="line515"></a> 515       #
</span><span class="inferred0"><a name="line516"></a> 516       # ==== Options
</span><span class="inferred1"><a name="line517"></a> 517       # All options specify prefix and query parameters.
</span><span class="inferred0"><a name="line518"></a> 518       #
</span><span class="inferred1"><a name="line519"></a> 519       # ==== Examples
</span><span class="inferred0"><a name="line520"></a> 520       #   Event.delete(2) # sends DELETE /events/2
</span><span class="inferred1"><a name="line521"></a> 521       #
</span><span class="inferred0"><a name="line522"></a> 522       #   Event.create(:name =&gt; 'Free Concert', :location =&gt; 'Community Center')
</span><span class="inferred1"><a name="line523"></a> 523       #   my_event = Event.find(:first) # let's assume this is event with ID 7
</span><span class="inferred0"><a name="line524"></a> 524       #   Event.delete(my_event.id) # sends DELETE /events/7
</span><span class="inferred1"><a name="line525"></a> 525       #
</span><span class="inferred0"><a name="line526"></a> 526       #   # Let's assume a request to events/5/cancel.xml
</span><span class="inferred1"><a name="line527"></a> 527       #   Event.delete(params[:id]) # sends DELETE /events/5
</span><span class="marked0"><a name="line528"></a> 528       def delete(id, options = {})
</span><span class="uncovered1"><a name="line529"></a> 529         connection.delete(element_path(id, options))
</span><span class="uncovered0"><a name="line530"></a> 530       end
</span><span class="inferred1"><a name="line531"></a> 531 
</span><span class="inferred0"><a name="line532"></a> 532       # Asserts the existence of a resource, returning &lt;tt&gt;true&lt;/tt&gt; if the resource is found.
</span><span class="inferred1"><a name="line533"></a> 533       #
</span><span class="inferred0"><a name="line534"></a> 534       # ==== Examples
</span><span class="inferred1"><a name="line535"></a> 535       #   Note.create(:title =&gt; 'Hello, world.', :body =&gt; 'Nothing more for now...')
</span><span class="inferred0"><a name="line536"></a> 536       #   Note.exists?(1) # =&gt; true
</span><span class="inferred1"><a name="line537"></a> 537       #
</span><span class="inferred0"><a name="line538"></a> 538       #   Note.exists(1349) # =&gt; false
</span><span class="marked1"><a name="line539"></a> 539       def exists?(id, options = {})
</span><span class="uncovered0"><a name="line540"></a> 540         if id
</span><span class="uncovered1"><a name="line541"></a> 541           prefix_options, query_options = split_options(options[:params])
</span><span class="uncovered0"><a name="line542"></a> 542           path = element_path(id, prefix_options, query_options)
</span><span class="uncovered1"><a name="line543"></a> 543           response = connection.head(path, headers)
</span><span class="uncovered0"><a name="line544"></a> 544           response.code.to_i == 200
</span><span class="uncovered1"><a name="line545"></a> 545         end
</span><span class="uncovered0"><a name="line546"></a> 546         # id &amp;&amp; !find_single(id, options).nil?
</span><span class="uncovered1"><a name="line547"></a> 547       rescue ActiveResource::ResourceNotFound
</span><span class="uncovered0"><a name="line548"></a> 548         false
</span><span class="uncovered1"><a name="line549"></a> 549       end
</span><span class="inferred0"><a name="line550"></a> 550 
</span><span class="marked1"><a name="line551"></a> 551       private
</span><span class="inferred0"><a name="line552"></a> 552         # Find every resource
</span><span class="marked1"><a name="line553"></a> 553         def find_every(options)
</span><span class="uncovered0"><a name="line554"></a> 554           case from = options[:from]
</span><span class="uncovered1"><a name="line555"></a> 555           when Symbol
</span><span class="uncovered0"><a name="line556"></a> 556             instantiate_collection(get(from, options[:params]))
</span><span class="uncovered1"><a name="line557"></a> 557           when String
</span><span class="uncovered0"><a name="line558"></a> 558             path = &quot;#{from}#{query_string(options[:params])}&quot;
</span><span class="uncovered1"><a name="line559"></a> 559             instantiate_collection(connection.get(path, headers) || [])
</span><span class="uncovered0"><a name="line560"></a> 560           else
</span><span class="uncovered1"><a name="line561"></a> 561             prefix_options, query_options = split_options(options[:params])
</span><span class="uncovered0"><a name="line562"></a> 562             path = collection_path(prefix_options, query_options)
</span><span class="uncovered1"><a name="line563"></a> 563             instantiate_collection( (connection.get(path, headers) || []), prefix_options )
</span><span class="uncovered0"><a name="line564"></a> 564           end
</span><span class="uncovered1"><a name="line565"></a> 565         end
</span><span class="inferred0"><a name="line566"></a> 566         
</span><span class="inferred1"><a name="line567"></a> 567         # Find a single resource from a one-off URL
</span><span class="marked0"><a name="line568"></a> 568         def find_one(options)
</span><span class="uncovered1"><a name="line569"></a> 569           case from = options[:from]
</span><span class="uncovered0"><a name="line570"></a> 570           when Symbol
</span><span class="uncovered1"><a name="line571"></a> 571             instantiate_record(get(from, options[:params]))
</span><span class="uncovered0"><a name="line572"></a> 572           when String
</span><span class="uncovered1"><a name="line573"></a> 573             path = &quot;#{from}#{query_string(options[:params])}&quot;
</span><span class="uncovered0"><a name="line574"></a> 574             instantiate_record(connection.get(path, headers))
</span><span class="uncovered1"><a name="line575"></a> 575           end
</span><span class="uncovered0"><a name="line576"></a> 576         end
</span><span class="inferred1"><a name="line577"></a> 577 
</span><span class="inferred0"><a name="line578"></a> 578         # Find a single resource from the default URL
</span><span class="marked1"><a name="line579"></a> 579         def find_single(scope, options)
</span><span class="uncovered0"><a name="line580"></a> 580           prefix_options, query_options = split_options(options[:params])
</span><span class="uncovered1"><a name="line581"></a> 581           path = element_path(scope, prefix_options, query_options)
</span><span class="uncovered0"><a name="line582"></a> 582           instantiate_record(connection.get(path, headers), prefix_options)
</span><span class="uncovered1"><a name="line583"></a> 583         end
</span><span class="inferred0"><a name="line584"></a> 584         
</span><span class="marked1"><a name="line585"></a> 585         def instantiate_collection(collection, prefix_options = {})
</span><span class="uncovered0"><a name="line586"></a> 586           collection.collect! { |record| instantiate_record(record, prefix_options) }
</span><span class="uncovered1"><a name="line587"></a> 587         end
</span><span class="inferred0"><a name="line588"></a> 588 
</span><span class="marked1"><a name="line589"></a> 589         def instantiate_record(record, prefix_options = {})
</span><span class="uncovered0"><a name="line590"></a> 590           returning new(record) do |resource|
</span><span class="uncovered1"><a name="line591"></a> 591             resource.prefix_options = prefix_options
</span><span class="uncovered0"><a name="line592"></a> 592           end
</span><span class="uncovered1"><a name="line593"></a> 593         end
</span><span class="inferred0"><a name="line594"></a> 594 
</span><span class="inferred1"><a name="line595"></a> 595 
</span><span class="inferred0"><a name="line596"></a> 596         # Accepts a URI and creates the site URI from that.
</span><span class="marked1"><a name="line597"></a> 597         def create_site_uri_from(site)
</span><span class="uncovered0"><a name="line598"></a> 598           site.is_a?(URI) ? site.dup : URI.parse(site)
</span><span class="uncovered1"><a name="line599"></a> 599         end
</span><span class="inferred0"><a name="line600"></a> 600 
</span><span class="inferred1"><a name="line601"></a> 601         # contains a set of the current prefix parameters.
</span><span class="marked0"><a name="line602"></a> 602         def prefix_parameters
</span><span class="uncovered1"><a name="line603"></a> 603           @prefix_parameters ||= prefix_source.scan(/:\w+/).map { |key| key[1..-1].to_sym }.to_set
</span><span class="uncovered0"><a name="line604"></a> 604         end
</span><span class="inferred1"><a name="line605"></a> 605 
</span><span class="inferred0"><a name="line606"></a> 606         # Builds the query string for the request.
</span><span class="marked1"><a name="line607"></a> 607         def query_string(options)
</span><span class="uncovered0"><a name="line608"></a> 608           &quot;?#{options.to_query}&quot; unless options.nil? || options.empty? 
</span><span class="uncovered1"><a name="line609"></a> 609         end
</span><span class="inferred0"><a name="line610"></a> 610 
</span><span class="inferred1"><a name="line611"></a> 611         # split an option hash into two hashes, one containing the prefix options, 
</span><span class="inferred0"><a name="line612"></a> 612         # and the other containing the leftovers.
</span><span class="marked1"><a name="line613"></a> 613         def split_options(options = {})
</span><span class="uncovered0"><a name="line614"></a> 614           prefix_options, query_options = {}, {}
</span><span class="uncovered1"><a name="line615"></a> 615 
</span><span class="uncovered0"><a name="line616"></a> 616           (options || {}).each do |key, value|
</span><span class="uncovered1"><a name="line617"></a> 617             next if key.blank?
</span><span class="uncovered0"><a name="line618"></a> 618             (prefix_parameters.include?(key.to_sym) ? prefix_options : query_options)[key.to_sym] = value
</span><span class="uncovered1"><a name="line619"></a> 619           end
</span><span class="uncovered0"><a name="line620"></a> 620 
</span><span class="uncovered1"><a name="line621"></a> 621           [ prefix_options, query_options ]
</span><span class="uncovered0"><a name="line622"></a> 622         end
</span><span class="uncovered1"><a name="line623"></a> 623     end
</span><span class="inferred0"><a name="line624"></a> 624 
</span><span class="marked1"><a name="line625"></a> 625     attr_accessor :attributes #:nodoc:
</span><span class="marked0"><a name="line626"></a> 626     attr_accessor :prefix_options #:nodoc:
</span><span class="inferred1"><a name="line627"></a> 627 
</span><span class="inferred0"><a name="line628"></a> 628     # Constructor method for new resources; the optional +attributes+ parameter takes a hash
</span><span class="inferred1"><a name="line629"></a> 629     # of attributes for the new resource.
</span><span class="inferred0"><a name="line630"></a> 630     #
</span><span class="inferred1"><a name="line631"></a> 631     # ==== Examples
</span><span class="inferred0"><a name="line632"></a> 632     #   my_course = Course.new
</span><span class="inferred1"><a name="line633"></a> 633     #   my_course.name = &quot;Western Civilization&quot;
</span><span class="inferred0"><a name="line634"></a> 634     #   my_course.lecturer = &quot;Don Trotter&quot;
</span><span class="inferred1"><a name="line635"></a> 635     #   my_course.save
</span><span class="inferred0"><a name="line636"></a> 636     #
</span><span class="inferred1"><a name="line637"></a> 637     #   my_other_course = Course.new(:name =&gt; &quot;Philosophy: Reason and Being&quot;, :lecturer =&gt; &quot;Ralph Cling&quot;)
</span><span class="inferred0"><a name="line638"></a> 638     #   my_other_course.save
</span><span class="marked1"><a name="line639"></a> 639     def initialize(attributes = {})
</span><span class="uncovered0"><a name="line640"></a> 640       @attributes     = {}
</span><span class="uncovered1"><a name="line641"></a> 641       @prefix_options = {}
</span><span class="uncovered0"><a name="line642"></a> 642       load(attributes)
</span><span class="uncovered1"><a name="line643"></a> 643     end
</span><span class="inferred0"><a name="line644"></a> 644 
</span><span class="inferred1"><a name="line645"></a> 645     # Returns a clone of the resource that hasn't been assigned an +id+ yet and
</span><span class="inferred0"><a name="line646"></a> 646     # is treated as a new resource.
</span><span class="inferred1"><a name="line647"></a> 647     #
</span><span class="inferred0"><a name="line648"></a> 648     #   ryan = Person.find(1)
</span><span class="inferred1"><a name="line649"></a> 649     #   not_ryan = ryan.clone
</span><span class="inferred0"><a name="line650"></a> 650     #   not_ryan.new?  # =&gt; true
</span><span class="inferred1"><a name="line651"></a> 651     #
</span><span class="inferred0"><a name="line652"></a> 652     # Any active resource member attributes will NOT be cloned, though all other
</span><span class="inferred1"><a name="line653"></a> 653     # attributes are.  This is to prevent the conflict between any +prefix_options+
</span><span class="inferred0"><a name="line654"></a> 654     # that refer to the original parent resource and the newly cloned parent
</span><span class="inferred1"><a name="line655"></a> 655     # resource that does not exist.
</span><span class="inferred0"><a name="line656"></a> 656     #
</span><span class="inferred1"><a name="line657"></a> 657     #   ryan = Person.find(1)
</span><span class="inferred0"><a name="line658"></a> 658     #   ryan.address = StreetAddress.find(1, :person_id =&gt; ryan.id)
</span><span class="inferred1"><a name="line659"></a> 659     #   ryan.hash = {:not =&gt; &quot;an ARes instance&quot;}
</span><span class="inferred0"><a name="line660"></a> 660     #   
</span><span class="inferred1"><a name="line661"></a> 661     #   not_ryan = ryan.clone
</span><span class="inferred0"><a name="line662"></a> 662     #   not_ryan.new?            # =&gt; true
</span><span class="inferred1"><a name="line663"></a> 663     #   not_ryan.address         # =&gt; NoMethodError
</span><span class="inferred0"><a name="line664"></a> 664     #   not_ryan.hash            # =&gt; {:not =&gt; &quot;an ARes instance&quot;}
</span><span class="marked1"><a name="line665"></a> 665     def clone
</span><span class="uncovered0"><a name="line666"></a> 666       # Clone all attributes except the pk and any nested ARes
</span><span class="uncovered1"><a name="line667"></a> 667       cloned = attributes.reject {|k,v| k == self.class.primary_key || v.is_a?(ActiveResource::Base)}.inject({}) do |attrs, (k, v)|
</span><span class="uncovered0"><a name="line668"></a> 668         attrs[k] = v.clone
</span><span class="uncovered1"><a name="line669"></a> 669         attrs
</span><span class="uncovered0"><a name="line670"></a> 670       end
</span><span class="uncovered1"><a name="line671"></a> 671       # Form the new resource - bypass initialize of resource with 'new' as that will call 'load' which
</span><span class="uncovered0"><a name="line672"></a> 672       # attempts to convert hashes into member objects and arrays into collections of objects.  We want
</span><span class="uncovered1"><a name="line673"></a> 673       # the raw objects to be cloned so we bypass load by directly setting the attributes hash.
</span><span class="uncovered0"><a name="line674"></a> 674       resource = self.class.new({})
</span><span class="uncovered1"><a name="line675"></a> 675       resource.prefix_options = self.prefix_options
</span><span class="uncovered0"><a name="line676"></a> 676       resource.send :instance_variable_set, '@attributes', cloned
</span><span class="uncovered1"><a name="line677"></a> 677       resource
</span><span class="uncovered0"><a name="line678"></a> 678     end
</span><span class="inferred1"><a name="line679"></a> 679 
</span><span class="inferred0"><a name="line680"></a> 680 
</span><span class="inferred1"><a name="line681"></a> 681     # A method to determine if the resource a new object (i.e., it has not been POSTed to the remote service yet).
</span><span class="inferred0"><a name="line682"></a> 682     #
</span><span class="inferred1"><a name="line683"></a> 683     # ==== Examples
</span><span class="inferred0"><a name="line684"></a> 684     #   not_new = Computer.create(:brand =&gt; 'Apple', :make =&gt; 'MacBook', :vendor =&gt; 'MacMall')
</span><span class="inferred1"><a name="line685"></a> 685     #   not_new.new? # =&gt; false
</span><span class="inferred0"><a name="line686"></a> 686     #
</span><span class="inferred1"><a name="line687"></a> 687     #   is_new = Computer.new(:brand =&gt; 'IBM', :make =&gt; 'Thinkpad', :vendor =&gt; 'IBM')
</span><span class="inferred0"><a name="line688"></a> 688     #   is_new.new? # =&gt; true
</span><span class="inferred1"><a name="line689"></a> 689     #
</span><span class="inferred0"><a name="line690"></a> 690     #   is_new.save
</span><span class="inferred1"><a name="line691"></a> 691     #   is_new.new? # =&gt; false
</span><span class="inferred0"><a name="line692"></a> 692     #
</span><span class="marked1"><a name="line693"></a> 693     def new?
</span><span class="uncovered0"><a name="line694"></a> 694       id.nil?
</span><span class="uncovered1"><a name="line695"></a> 695     end
</span><span class="inferred0"><a name="line696"></a> 696 
</span><span class="inferred1"><a name="line697"></a> 697     # Get the +id+ attribute of the resource.
</span><span class="marked0"><a name="line698"></a> 698     def id
</span><span class="uncovered1"><a name="line699"></a> 699       attributes[self.class.primary_key]
</span><span class="uncovered0"><a name="line700"></a> 700     end
</span><span class="inferred1"><a name="line701"></a> 701 
</span><span class="inferred0"><a name="line702"></a> 702     # Set the +id+ attribute of the resource.
</span><span class="marked1"><a name="line703"></a> 703     def id=(id)
</span><span class="uncovered0"><a name="line704"></a> 704       attributes[self.class.primary_key] = id
</span><span class="uncovered1"><a name="line705"></a> 705     end
</span><span class="inferred0"><a name="line706"></a> 706 
</span><span class="inferred1"><a name="line707"></a> 707     # Allows Active Resource objects to be used as parameters in Action Pack URL generation.
</span><span class="marked0"><a name="line708"></a> 708     def to_param
</span><span class="uncovered1"><a name="line709"></a> 709       id &amp;&amp; id.to_s
</span><span class="uncovered0"><a name="line710"></a> 710     end
</span><span class="inferred1"><a name="line711"></a> 711 
</span><span class="inferred0"><a name="line712"></a> 712     # Test for equality.  Resource are equal if and only if +other+ is the same object or 
</span><span class="inferred1"><a name="line713"></a> 713     # is an instance of the same class, is not &lt;tt&gt;new?&lt;/tt&gt;, and has the same +id+.
</span><span class="inferred0"><a name="line714"></a> 714     #
</span><span class="inferred1"><a name="line715"></a> 715     # ==== Examples
</span><span class="inferred0"><a name="line716"></a> 716     #   ryan = Person.create(:name =&gt; 'Ryan')
</span><span class="inferred1"><a name="line717"></a> 717     #   jamie = Person.create(:name =&gt; 'Jamie')
</span><span class="inferred0"><a name="line718"></a> 718     #
</span><span class="inferred1"><a name="line719"></a> 719     #   ryan == jamie
</span><span class="inferred0"><a name="line720"></a> 720     #   # =&gt; false (Different name attribute and id)
</span><span class="inferred1"><a name="line721"></a> 721     #
</span><span class="inferred0"><a name="line722"></a> 722     #   ryan_again = Person.new(:name =&gt; 'Ryan')
</span><span class="inferred1"><a name="line723"></a> 723     #   ryan == ryan_again
</span><span class="inferred0"><a name="line724"></a> 724     #   # =&gt; false (ryan_again is new?)
</span><span class="inferred1"><a name="line725"></a> 725     #
</span><span class="inferred0"><a name="line726"></a> 726     #   ryans_clone = Person.create(:name =&gt; 'Ryan')
</span><span class="inferred1"><a name="line727"></a> 727     #   ryan == ryans_clone
</span><span class="inferred0"><a name="line728"></a> 728     #   # =&gt; false (Different id attributes)
</span><span class="inferred1"><a name="line729"></a> 729     #
</span><span class="inferred0"><a name="line730"></a> 730     #   ryans_twin = Person.find(ryan.id)
</span><span class="inferred1"><a name="line731"></a> 731     #   ryan == ryans_twin
</span><span class="inferred0"><a name="line732"></a> 732     #   # =&gt; true
</span><span class="inferred1"><a name="line733"></a> 733     #
</span><span class="marked0"><a name="line734"></a> 734     def ==(other)
</span><span class="uncovered1"><a name="line735"></a> 735       other.equal?(self) || (other.instance_of?(self.class) &amp;&amp; !other.new? &amp;&amp; other.id == id)
</span><span class="uncovered0"><a name="line736"></a> 736     end
</span><span class="inferred1"><a name="line737"></a> 737 
</span><span class="inferred0"><a name="line738"></a> 738     # Tests for equality (delegates to ==).
</span><span class="marked1"><a name="line739"></a> 739     def eql?(other)
</span><span class="uncovered0"><a name="line740"></a> 740       self == other
</span><span class="uncovered1"><a name="line741"></a> 741     end
</span><span class="inferred0"><a name="line742"></a> 742 
</span><span class="inferred1"><a name="line743"></a> 743     # Delegates to id in order to allow two resources of the same type and id to work with something like:
</span><span class="inferred0"><a name="line744"></a> 744     #   [Person.find(1), Person.find(2)] &amp; [Person.find(1), Person.find(4)] # =&gt; [Person.find(1)]
</span><span class="marked1"><a name="line745"></a> 745     def hash
</span><span class="uncovered0"><a name="line746"></a> 746       id.hash
</span><span class="uncovered1"><a name="line747"></a> 747     end
</span><span class="inferred0"><a name="line748"></a> 748     
</span><span class="inferred1"><a name="line749"></a> 749     # Duplicate the current resource without saving it.
</span><span class="inferred0"><a name="line750"></a> 750     #
</span><span class="inferred1"><a name="line751"></a> 751     # ==== Examples
</span><span class="inferred0"><a name="line752"></a> 752     #   my_invoice = Invoice.create(:customer =&gt; 'That Company')
</span><span class="inferred1"><a name="line753"></a> 753     #   next_invoice = my_invoice.dup
</span><span class="inferred0"><a name="line754"></a> 754     #   next_invoice.new? # =&gt; true
</span><span class="inferred1"><a name="line755"></a> 755     #
</span><span class="inferred0"><a name="line756"></a> 756     #   next_invoice.save
</span><span class="inferred1"><a name="line757"></a> 757     #   next_invoice == my_invoice # =&gt; false (different id attributes)
</span><span class="inferred0"><a name="line758"></a> 758     #
</span><span class="inferred1"><a name="line759"></a> 759     #   my_invoice.customer   # =&gt; That Company
</span><span class="inferred0"><a name="line760"></a> 760     #   next_invoice.customer # =&gt; That Company
</span><span class="marked1"><a name="line761"></a> 761     def dup
</span><span class="uncovered0"><a name="line762"></a> 762       returning self.class.new do |resource|
</span><span class="uncovered1"><a name="line763"></a> 763         resource.attributes     = @attributes
</span><span class="uncovered0"><a name="line764"></a> 764         resource.prefix_options = @prefix_options
</span><span class="uncovered1"><a name="line765"></a> 765       end
</span><span class="uncovered0"><a name="line766"></a> 766     end
</span><span class="inferred1"><a name="line767"></a> 767 
</span><span class="inferred0"><a name="line768"></a> 768     # A method to save (+POST+) or update (+PUT+) a resource.  It delegates to +create+ if a new object, 
</span><span class="inferred1"><a name="line769"></a> 769     # +update+ if it is existing. If the response to the save includes a body, it will be assumed that this body
</span><span class="inferred0"><a name="line770"></a> 770     # is XML for the final object as it looked after the save (which would include attributes like +created_at+
</span><span class="inferred1"><a name="line771"></a> 771     # that weren't part of the original submit).
</span><span class="inferred0"><a name="line772"></a> 772     #
</span><span class="inferred1"><a name="line773"></a> 773     # ==== Examples
</span><span class="inferred0"><a name="line774"></a> 774     #   my_company = Company.new(:name =&gt; 'RoleModel Software', :owner =&gt; 'Ken Auer', :size =&gt; 2)
</span><span class="inferred1"><a name="line775"></a> 775     #   my_company.new? # =&gt; true
</span><span class="inferred0"><a name="line776"></a> 776     #   my_company.save # sends POST /companies/ (create)
</span><span class="inferred1"><a name="line777"></a> 777     #
</span><span class="inferred0"><a name="line778"></a> 778     #   my_company.new? # =&gt; false
</span><span class="inferred1"><a name="line779"></a> 779     #   my_company.size = 10
</span><span class="inferred0"><a name="line780"></a> 780     #   my_company.save # sends PUT /companies/1 (update)
</span><span class="marked1"><a name="line781"></a> 781     def save
</span><span class="uncovered0"><a name="line782"></a> 782       new? ? create : update
</span><span class="uncovered1"><a name="line783"></a> 783     end
</span><span class="inferred0"><a name="line784"></a> 784 
</span><span class="inferred1"><a name="line785"></a> 785     # Deletes the resource from the remote service.
</span><span class="inferred0"><a name="line786"></a> 786     #
</span><span class="inferred1"><a name="line787"></a> 787     # ==== Examples
</span><span class="inferred0"><a name="line788"></a> 788     #   my_id = 3
</span><span class="inferred1"><a name="line789"></a> 789     #   my_person = Person.find(my_id)
</span><span class="inferred0"><a name="line790"></a> 790     #   my_person.destroy
</span><span class="inferred1"><a name="line791"></a> 791     #   Person.find(my_id) # 404 (Resource Not Found)
</span><span class="inferred0"><a name="line792"></a> 792     #   
</span><span class="inferred1"><a name="line793"></a> 793     #   new_person = Person.create(:name =&gt; 'James')
</span><span class="inferred0"><a name="line794"></a> 794     #   new_id = new_person.id # =&gt; 7
</span><span class="inferred1"><a name="line795"></a> 795     #   new_person.destroy
</span><span class="inferred0"><a name="line796"></a> 796     #   Person.find(new_id) # 404 (Resource Not Found)
</span><span class="marked1"><a name="line797"></a> 797     def destroy
</span><span class="uncovered0"><a name="line798"></a> 798       connection.delete(element_path, self.class.headers)
</span><span class="uncovered1"><a name="line799"></a> 799     end
</span><span class="inferred0"><a name="line800"></a> 800 
</span><span class="inferred1"><a name="line801"></a> 801     # Evaluates to &lt;tt&gt;true&lt;/tt&gt; if this resource is not &lt;tt&gt;new?&lt;/tt&gt; and is
</span><span class="inferred0"><a name="line802"></a> 802     # found on the remote service.  Using this method, you can check for
</span><span class="inferred1"><a name="line803"></a> 803     # resources that may have been deleted between the object's instantiation
</span><span class="inferred0"><a name="line804"></a> 804     # and actions on it.
</span><span class="inferred1"><a name="line805"></a> 805     #
</span><span class="inferred0"><a name="line806"></a> 806     # ==== Examples
</span><span class="inferred1"><a name="line807"></a> 807     #   Person.create(:name =&gt; 'Theodore Roosevelt')
</span><span class="inferred0"><a name="line808"></a> 808     #   that_guy = Person.find(:first)
</span><span class="inferred1"><a name="line809"></a> 809     #   that_guy.exists? # =&gt; true
</span><span class="inferred0"><a name="line810"></a> 810     #
</span><span class="inferred1"><a name="line811"></a> 811     #   that_lady = Person.new(:name =&gt; 'Paul Bean')
</span><span class="inferred0"><a name="line812"></a> 812     #   that_lady.exists? # =&gt; false
</span><span class="inferred1"><a name="line813"></a> 813     #
</span><span class="inferred0"><a name="line814"></a> 814     #   guys_id = that_guy.id
</span><span class="inferred1"><a name="line815"></a> 815     #   Person.delete(guys_id)
</span><span class="inferred0"><a name="line816"></a> 816     #   that_guy.exists? # =&gt; false
</span><span class="marked1"><a name="line817"></a> 817     def exists?
</span><span class="uncovered0"><a name="line818"></a> 818       !new? &amp;&amp; self.class.exists?(to_param, :params =&gt; prefix_options)      
</span><span class="uncovered1"><a name="line819"></a> 819     end
</span><span class="inferred0"><a name="line820"></a> 820 
</span><span class="inferred1"><a name="line821"></a> 821     # A method to convert the the resource to an XML string.
</span><span class="inferred0"><a name="line822"></a> 822     #
</span><span class="inferred1"><a name="line823"></a> 823     # ==== Options
</span><span class="inferred0"><a name="line824"></a> 824     # The +options+ parameter is handed off to the +to_xml+ method on each
</span><span class="inferred1"><a name="line825"></a> 825     # attribute, so it has the same options as the +to_xml+ methods in
</span><span class="inferred0"><a name="line826"></a> 826     # Active Support.
</span><span class="inferred1"><a name="line827"></a> 827     #
</span><span class="inferred0"><a name="line828"></a> 828     # * &lt;tt&gt;:indent&lt;/tt&gt; - Set the indent level for the XML output (default is +2+).
</span><span class="inferred1"><a name="line829"></a> 829     # * &lt;tt&gt;:dasherize&lt;/tt&gt; - Boolean option to determine whether or not element names should
</span><span class="inferred0"><a name="line830"></a> 830     #   replace underscores with dashes (default is &lt;tt&gt;false&lt;/tt&gt;).
</span><span class="inferred1"><a name="line831"></a> 831     # * &lt;tt&gt;:skip_instruct&lt;/tt&gt; - Toggle skipping the +instruct!+ call on the XML builder 
</span><span class="inferred0"><a name="line832"></a> 832     #   that generates the XML declaration (default is &lt;tt&gt;false&lt;/tt&gt;).
</span><span class="inferred1"><a name="line833"></a> 833     #
</span><span class="inferred0"><a name="line834"></a> 834     # ==== Examples
</span><span class="inferred1"><a name="line835"></a> 835     #   my_group = SubsidiaryGroup.find(:first)
</span><span class="inferred0"><a name="line836"></a> 836     #   my_group.to_xml
</span><span class="inferred1"><a name="line837"></a> 837     #   # =&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
</span><span class="inferred0"><a name="line838"></a> 838     #   #    &lt;subsidiary_group&gt; [...] &lt;/subsidiary_group&gt;
</span><span class="inferred1"><a name="line839"></a> 839     #
</span><span class="inferred0"><a name="line840"></a> 840     #   my_group.to_xml(:dasherize =&gt; true)
</span><span class="inferred1"><a name="line841"></a> 841     #   # =&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
</span><span class="inferred0"><a name="line842"></a> 842     #   #    &lt;subsidiary-group&gt; [...] &lt;/subsidiary-group&gt;
</span><span class="inferred1"><a name="line843"></a> 843     #
</span><span class="inferred0"><a name="line844"></a> 844     #   my_group.to_xml(:skip_instruct =&gt; true)
</span><span class="inferred1"><a name="line845"></a> 845     #   # =&gt; &lt;subsidiary_group&gt; [...] &lt;/subsidiary_group&gt;
</span><span class="marked0"><a name="line846"></a> 846     def encode(options={})
</span><span class="uncovered1"><a name="line847"></a> 847       case self.class.format
</span><span class="uncovered0"><a name="line848"></a> 848         when ActiveResource::Formats[:xml]
</span><span class="uncovered1"><a name="line849"></a> 849           self.class.format.encode(attributes, {:root =&gt; self.class.element_name}.merge(options))
</span><span class="uncovered0"><a name="line850"></a> 850         else
</span><span class="uncovered1"><a name="line851"></a> 851           self.class.format.encode(attributes, options)
</span><span class="uncovered0"><a name="line852"></a> 852       end
</span><span class="uncovered1"><a name="line853"></a> 853     end
</span><span class="inferred0"><a name="line854"></a> 854 
</span><span class="inferred1"><a name="line855"></a> 855     # A method to reload the attributes of this object from the remote web service.
</span><span class="inferred0"><a name="line856"></a> 856     #
</span><span class="inferred1"><a name="line857"></a> 857     # ==== Examples
</span><span class="inferred0"><a name="line858"></a> 858     #   my_branch = Branch.find(:first)
</span><span class="inferred1"><a name="line859"></a> 859     #   my_branch.name # =&gt; &quot;Wislon Raod&quot;
</span><span class="inferred0"><a name="line860"></a> 860     #   
</span><span class="inferred1"><a name="line861"></a> 861     #   # Another client fixes the typo...
</span><span class="inferred0"><a name="line862"></a> 862     #
</span><span class="inferred1"><a name="line863"></a> 863     #   my_branch.name # =&gt; &quot;Wislon Raod&quot;
</span><span class="inferred0"><a name="line864"></a> 864     #   my_branch.reload
</span><span class="inferred1"><a name="line865"></a> 865     #   my_branch.name # =&gt; &quot;Wilson Road&quot;
</span><span class="marked0"><a name="line866"></a> 866     def reload
</span><span class="uncovered1"><a name="line867"></a> 867       self.load(self.class.find(to_param, :params =&gt; @prefix_options).attributes)
</span><span class="uncovered0"><a name="line868"></a> 868     end
</span><span class="inferred1"><a name="line869"></a> 869 
</span><span class="inferred0"><a name="line870"></a> 870     # A method to manually load attributes from a hash. Recursively loads collections of
</span><span class="inferred1"><a name="line871"></a> 871     # resources.  This method is called in +initialize+ and +create+ when a hash of attributes
</span><span class="inferred0"><a name="line872"></a> 872     # is provided.
</span><span class="inferred1"><a name="line873"></a> 873     #
</span><span class="inferred0"><a name="line874"></a> 874     # ==== Examples
</span><span class="inferred1"><a name="line875"></a> 875     #   my_attrs = {:name =&gt; 'J&amp;J Textiles', :industry =&gt; 'Cloth and textiles'}
</span><span class="inferred0"><a name="line876"></a> 876     #
</span><span class="inferred1"><a name="line877"></a> 877     #   the_supplier = Supplier.find(:first)
</span><span class="inferred0"><a name="line878"></a> 878     #   the_supplier.name # =&gt; 'J&amp;M Textiles'
</span><span class="inferred1"><a name="line879"></a> 879     #   the_supplier.load(my_attrs)
</span><span class="inferred0"><a name="line880"></a> 880     #   the_supplier.name('J&amp;J Textiles')
</span><span class="inferred1"><a name="line881"></a> 881     #
</span><span class="inferred0"><a name="line882"></a> 882     #   # These two calls are the same as Supplier.new(my_attrs)
</span><span class="inferred1"><a name="line883"></a> 883     #   my_supplier = Supplier.new
</span><span class="inferred0"><a name="line884"></a> 884     #   my_supplier.load(my_attrs)
</span><span class="inferred1"><a name="line885"></a> 885     #
</span><span class="inferred0"><a name="line886"></a> 886     #   # These three calls are the same as Supplier.create(my_attrs)
</span><span class="inferred1"><a name="line887"></a> 887     #   your_supplier = Supplier.new
</span><span class="inferred0"><a name="line888"></a> 888     #   your_supplier.load(my_attrs)
</span><span class="inferred1"><a name="line889"></a> 889     #   your_supplier.save
</span><span class="marked0"><a name="line890"></a> 890     def load(attributes)
</span><span class="uncovered1"><a name="line891"></a> 891       raise ArgumentError, &quot;expected an attributes Hash, got #{attributes.inspect}&quot; unless attributes.is_a?(Hash)
</span><span class="uncovered0"><a name="line892"></a> 892       @prefix_options, attributes = split_options(attributes)
</span><span class="uncovered1"><a name="line893"></a> 893       attributes.each do |key, value|
</span><span class="uncovered0"><a name="line894"></a> 894         @attributes[key.to_s] =
</span><span class="uncovered1"><a name="line895"></a> 895           case value
</span><span class="uncovered0"><a name="line896"></a> 896             when Array
</span><span class="uncovered1"><a name="line897"></a> 897               resource = find_or_create_resource_for_collection(key)
</span><span class="uncovered0"><a name="line898"></a> 898               value.map { |attrs| resource.new(attrs) }
</span><span class="uncovered1"><a name="line899"></a> 899             when Hash
</span><span class="uncovered0"><a name="line900"></a> 900               resource = find_or_create_resource_for(key)
</span><span class="uncovered1"><a name="line901"></a> 901               resource.new(value)
</span><span class="uncovered0"><a name="line902"></a> 902             else
</span><span class="uncovered1"><a name="line903"></a> 903               value.dup rescue value
</span><span class="uncovered0"><a name="line904"></a> 904           end
</span><span class="uncovered1"><a name="line905"></a> 905       end
</span><span class="uncovered0"><a name="line906"></a> 906       self
</span><span class="uncovered1"><a name="line907"></a> 907     end
</span><span class="inferred0"><a name="line908"></a> 908     
</span><span class="inferred1"><a name="line909"></a> 909     # For checking &lt;tt&gt;respond_to?&lt;/tt&gt; without searching the attributes (which is faster).
</span><span class="marked0"><a name="line910"></a> 910     alias_method :respond_to_without_attributes?, :respond_to?
</span><span class="inferred1"><a name="line911"></a> 911 
</span><span class="inferred0"><a name="line912"></a> 912     # A method to determine if an object responds to a message (e.g., a method call). In Active Resource, a Person object with a
</span><span class="inferred1"><a name="line913"></a> 913     # +name+ attribute can answer &lt;tt&gt;true&lt;/tt&gt; to &lt;tt&gt;my_person.respond_to?(&quot;name&quot;)&lt;/tt&gt;, &lt;tt&gt;my_person.respond_to?(&quot;name=&quot;)&lt;/tt&gt;, and
</span><span class="inferred0"><a name="line914"></a> 914     # &lt;tt&gt;my_person.respond_to?(&quot;name?&quot;)&lt;/tt&gt;.
</span><span class="marked1"><a name="line915"></a> 915     def respond_to?(method, include_priv = false)
</span><span class="uncovered0"><a name="line916"></a> 916       method_name = method.to_s
</span><span class="uncovered1"><a name="line917"></a> 917       if attributes.nil?
</span><span class="uncovered0"><a name="line918"></a> 918         return super
</span><span class="uncovered1"><a name="line919"></a> 919       elsif attributes.has_key?(method_name)
</span><span class="uncovered0"><a name="line920"></a> 920         return true 
</span><span class="uncovered1"><a name="line921"></a> 921       elsif ['?','='].include?(method_name.last) &amp;&amp; attributes.has_key?(method_name.first(-1))
</span><span class="uncovered0"><a name="line922"></a> 922         return true
</span><span class="uncovered1"><a name="line923"></a> 923       end
</span><span class="uncovered0"><a name="line924"></a> 924       # super must be called at the end of the method, because the inherited respond_to?
</span><span class="uncovered1"><a name="line925"></a> 925       # would return true for generated readers, even if the attribute wasn't present
</span><span class="uncovered0"><a name="line926"></a> 926       super
</span><span class="uncovered1"><a name="line927"></a> 927     end
</span><span class="inferred0"><a name="line928"></a> 928     
</span><span class="inferred1"><a name="line929"></a> 929 
</span><span class="marked0"><a name="line930"></a> 930     protected
</span><span class="marked1"><a name="line931"></a> 931       def connection(refresh = false)
</span><span class="uncovered0"><a name="line932"></a> 932         self.class.connection(refresh)
</span><span class="uncovered1"><a name="line933"></a> 933       end
</span><span class="inferred0"><a name="line934"></a> 934 
</span><span class="inferred1"><a name="line935"></a> 935       # Update the resource on the remote service.
</span><span class="marked0"><a name="line936"></a> 936       def update
</span><span class="uncovered1"><a name="line937"></a> 937         returning connection.put(element_path(prefix_options), encode, self.class.headers) do |response|
</span><span class="uncovered0"><a name="line938"></a> 938           load_attributes_from_response(response)
</span><span class="uncovered1"><a name="line939"></a> 939         end
</span><span class="uncovered0"><a name="line940"></a> 940       end
</span><span class="inferred1"><a name="line941"></a> 941 
</span><span class="inferred0"><a name="line942"></a> 942       # Create (i.e., save to the remote service) the new resource.
</span><span class="marked1"><a name="line943"></a> 943       def create
</span><span class="uncovered0"><a name="line944"></a> 944         returning connection.post(collection_path, encode, self.class.headers) do |response|
</span><span class="uncovered1"><a name="line945"></a> 945           self.id = id_from_response(response)
</span><span class="uncovered0"><a name="line946"></a> 946           load_attributes_from_response(response)
</span><span class="uncovered1"><a name="line947"></a> 947         end
</span><span class="uncovered0"><a name="line948"></a> 948       end
</span><span class="inferred1"><a name="line949"></a> 949       
</span><span class="marked0"><a name="line950"></a> 950       def load_attributes_from_response(response)
</span><span class="uncovered1"><a name="line951"></a> 951         if response['Content-Length'] != &quot;0&quot; &amp;&amp; response.body.strip.size &gt; 0
</span><span class="uncovered0"><a name="line952"></a> 952           load(self.class.format.decode(response.body))
</span><span class="uncovered1"><a name="line953"></a> 953         end
</span><span class="uncovered0"><a name="line954"></a> 954       end
</span><span class="inferred1"><a name="line955"></a> 955 
</span><span class="inferred0"><a name="line956"></a> 956       # Takes a response from a typical create post and pulls the ID out
</span><span class="marked1"><a name="line957"></a> 957       def id_from_response(response)
</span><span class="uncovered0"><a name="line958"></a> 958         response['Location'][/\/([^\/]*?)(\.\w+)?$/, 1]
</span><span class="uncovered1"><a name="line959"></a> 959       end
</span><span class="inferred0"><a name="line960"></a> 960 
</span><span class="marked1"><a name="line961"></a> 961       def element_path(options = nil)
</span><span class="uncovered0"><a name="line962"></a> 962         self.class.element_path(to_param, options || prefix_options)
</span><span class="uncovered1"><a name="line963"></a> 963       end
</span><span class="inferred0"><a name="line964"></a> 964 
</span><span class="marked1"><a name="line965"></a> 965       def collection_path(options = nil)
</span><span class="uncovered0"><a name="line966"></a> 966         self.class.collection_path(options || prefix_options)
</span><span class="uncovered1"><a name="line967"></a> 967       end
</span><span class="inferred0"><a name="line968"></a> 968 
</span><span class="marked1"><a name="line969"></a> 969     private
</span><span class="inferred0"><a name="line970"></a> 970       # Tries to find a resource for a given collection name; if it fails, then the resource is created
</span><span class="marked1"><a name="line971"></a> 971       def find_or_create_resource_for_collection(name)
</span><span class="uncovered0"><a name="line972"></a> 972         find_or_create_resource_for(name.to_s.singularize)
</span><span class="uncovered1"><a name="line973"></a> 973       end
</span><span class="inferred0"><a name="line974"></a> 974       
</span><span class="inferred1"><a name="line975"></a> 975       # Tries to find a resource in a non empty list of nested modules
</span><span class="inferred0"><a name="line976"></a> 976       # Raises a NameError if it was not found in any of the given nested modules
</span><span class="marked1"><a name="line977"></a> 977       def find_resource_in_modules(resource_name, module_names)
</span><span class="uncovered0"><a name="line978"></a> 978         receiver = Object
</span><span class="uncovered1"><a name="line979"></a> 979         namespaces = module_names[0, module_names.size-1].map do |module_name|
</span><span class="uncovered0"><a name="line980"></a> 980           receiver = receiver.const_get(module_name)
</span><span class="uncovered1"><a name="line981"></a> 981         end
</span><span class="uncovered0"><a name="line982"></a> 982         if namespace = namespaces.reverse.detect { |ns| ns.const_defined?(resource_name) }
</span><span class="uncovered1"><a name="line983"></a> 983           return namespace.const_get(resource_name)
</span><span class="uncovered0"><a name="line984"></a> 984         else
</span><span class="uncovered1"><a name="line985"></a> 985           raise NameError
</span><span class="uncovered0"><a name="line986"></a> 986         end
</span><span class="uncovered1"><a name="line987"></a> 987       end
</span><span class="inferred0"><a name="line988"></a> 988 
</span><span class="inferred1"><a name="line989"></a> 989       # Tries to find a resource for a given name; if it fails, then the resource is created
</span><span class="marked0"><a name="line990"></a> 990       def find_or_create_resource_for(name)
</span><span class="uncovered1"><a name="line991"></a> 991         resource_name = name.to_s.camelize
</span><span class="uncovered0"><a name="line992"></a> 992         ancestors = self.class.name.split(&quot;::&quot;)
</span><span class="uncovered1"><a name="line993"></a> 993         if ancestors.size &gt; 1
</span><span class="uncovered0"><a name="line994"></a> 994           find_resource_in_modules(resource_name, ancestors)
</span><span class="uncovered1"><a name="line995"></a> 995         else
</span><span class="uncovered0"><a name="line996"></a> 996           self.class.const_get(resource_name)
</span><span class="uncovered1"><a name="line997"></a> 997         end
</span><span class="uncovered0"><a name="line998"></a> 998       rescue NameError
</span><span class="uncovered1"><a name="line999"></a> 999         if self.class.const_defined?(resource_name)
</span><span class="uncovered0"><a name="line1000"></a>1000           resource = self.class.const_get(resource_name)
</span><span class="uncovered1"><a name="line1001"></a>1001         else
</span><span class="uncovered0"><a name="line1002"></a>1002           resource = self.class.const_set(resource_name, Class.new(ActiveResource::Base))
</span><span class="uncovered1"><a name="line1003"></a>1003         end
</span><span class="uncovered0"><a name="line1004"></a>1004         resource.prefix = self.class.prefix
</span><span class="uncovered1"><a name="line1005"></a>1005         resource.site   = self.class.site
</span><span class="uncovered0"><a name="line1006"></a>1006         resource
</span><span class="uncovered1"><a name="line1007"></a>1007       end
</span><span class="inferred0"><a name="line1008"></a>1008 
</span><span class="marked1"><a name="line1009"></a>1009       def split_options(options = {})
</span><span class="uncovered0"><a name="line1010"></a>1010         self.class.send!(:split_options, options)
</span><span class="uncovered1"><a name="line1011"></a>1011       end
</span><span class="inferred0"><a name="line1012"></a>1012 
</span><span class="marked1"><a name="line1013"></a>1013       def method_missing(method_symbol, *arguments) #:nodoc:
</span><span class="uncovered0"><a name="line1014"></a>1014         method_name = method_symbol.to_s
</span><span class="uncovered1"><a name="line1015"></a>1015 
</span><span class="uncovered0"><a name="line1016"></a>1016         case method_name.last
</span><span class="uncovered1"><a name="line1017"></a>1017           when &quot;=&quot;
</span><span class="uncovered0"><a name="line1018"></a>1018             attributes[method_name.first(-1)] = arguments.first
</span><span class="uncovered1"><a name="line1019"></a>1019           when &quot;?&quot;
</span><span class="uncovered0"><a name="line1020"></a>1020             attributes[method_name.first(-1)]
</span><span class="uncovered1"><a name="line1021"></a>1021           else
</span><span class="uncovered0"><a name="line1022"></a>1022             attributes.has_key?(method_name) ? attributes[method_name] : super
</span><span class="uncovered1"><a name="line1023"></a>1023         end
</span><span class="uncovered0"><a name="line1024"></a>1024       end
</span><span class="uncovered1"><a name="line1025"></a>1025   end
</span><span class="uncovered0"><a name="line1026"></a>1026 end
</span></pre><hr/>
    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a>
   version 0.8.1.2.</p>
<p><a href='http://validator.w3.org/check/referer'><img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88'/>
        </a>
      <a href='http://jigsaw.w3.org/css-validator/check/referer'><img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px'/>
        </a>
      </p>
    </body>
  </html>
