<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'><head><title>/Library/Ruby/Gems/1.8/gems/activerecord-2.1.1/lib/active_record/associations.rb - C0 code coverage information</title>
    <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
    <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
    <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
    <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
    </head>
  <body><h3>C0 code coverage information</h3>
    <p>Generated on Tue Nov 11 15:30:05 -0500 2008 with <a href='http://eigenclass.org/hiki/rcov'>rcov 0.8.1.2</a>
      </p>
    <hr/>
    <pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
<table class='report'><thead><tr><td class='heading'>Name</td>
      <td class='heading'>Total lines</td>
      <td class='heading'>Lines of code</td>
      <td class='heading'>Total coverage</td>
      <td class='heading'>Code coverage</td>
      </tr>
    </thead>
  <tbody><tr class='light'><td><a href='-Library-Ruby-Gems-1_8-gems-activerecord-2_1_1-lib-active_record-associations_rb.html'>/Library/Ruby/Gems/1.8/gems/activerecord-2.1.1/lib/active_record/associations.rb</a>
        </td>
      <td class='lines_total'><tt>2012</tt>
        </td>
      <td class='lines_code'><tt>974</tt>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_total'>58.3%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='58'/>
                  <td class='uncovered' width='42'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_code'>22.2%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='22'/>
                  <td class='uncovered' width='78'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </tbody>
  </table>
<pre><span class="marked0"><a name="line1"></a>   1 require 'active_record/associations/association_proxy'
</span><span class="marked1"><a name="line2"></a>   2 require 'active_record/associations/association_collection'
</span><span class="marked0"><a name="line3"></a>   3 require 'active_record/associations/belongs_to_association'
</span><span class="marked1"><a name="line4"></a>   4 require 'active_record/associations/belongs_to_polymorphic_association'
</span><span class="marked0"><a name="line5"></a>   5 require 'active_record/associations/has_one_association'
</span><span class="marked1"><a name="line6"></a>   6 require 'active_record/associations/has_many_association'
</span><span class="marked0"><a name="line7"></a>   7 require 'active_record/associations/has_many_through_association'
</span><span class="marked1"><a name="line8"></a>   8 require 'active_record/associations/has_and_belongs_to_many_association'
</span><span class="marked0"><a name="line9"></a>   9 require 'active_record/associations/has_one_through_association'
</span><span class="inferred1"><a name="line10"></a>  10 
</span><span class="marked0"><a name="line11"></a>  11 module ActiveRecord
</span><span class="marked1"><a name="line12"></a>  12   class HasManyThroughAssociationNotFoundError &lt; ActiveRecordError #:nodoc:
</span><span class="marked0"><a name="line13"></a>  13     def initialize(owner_class_name, reflection)
</span><span class="uncovered1"><a name="line14"></a>  14       super(&quot;Could not find the association #{reflection.options[:through].inspect} in model #{owner_class_name}&quot;)
</span><span class="uncovered0"><a name="line15"></a>  15     end
</span><span class="uncovered1"><a name="line16"></a>  16   end
</span><span class="inferred0"><a name="line17"></a>  17 
</span><span class="marked1"><a name="line18"></a>  18   class HasManyThroughAssociationPolymorphicError &lt; ActiveRecordError #:nodoc:
</span><span class="marked0"><a name="line19"></a>  19     def initialize(owner_class_name, reflection, source_reflection)
</span><span class="uncovered1"><a name="line20"></a>  20       super(&quot;Cannot have a has_many :through association '#{owner_class_name}##{reflection.name}' on the polymorphic object '#{source_reflection.class_name}##{source_reflection.name}'.&quot;)
</span><span class="uncovered0"><a name="line21"></a>  21     end
</span><span class="uncovered1"><a name="line22"></a>  22   end
</span><span class="inferred0"><a name="line23"></a>  23 
</span><span class="marked1"><a name="line24"></a>  24   class HasManyThroughAssociationPointlessSourceTypeError &lt; ActiveRecordError #:nodoc:
</span><span class="marked0"><a name="line25"></a>  25     def initialize(owner_class_name, reflection, source_reflection)
</span><span class="uncovered1"><a name="line26"></a>  26       super(&quot;Cannot have a has_many :through association '#{owner_class_name}##{reflection.name}' with a :source_type option if the '#{reflection.through_reflection.class_name}##{source_reflection.name}' is not polymorphic.  Try removing :source_type on your association.&quot;)
</span><span class="uncovered0"><a name="line27"></a>  27     end
</span><span class="uncovered1"><a name="line28"></a>  28   end
</span><span class="inferred0"><a name="line29"></a>  29 
</span><span class="marked1"><a name="line30"></a>  30   class HasManyThroughSourceAssociationNotFoundError &lt; ActiveRecordError #:nodoc:
</span><span class="marked0"><a name="line31"></a>  31     def initialize(reflection)
</span><span class="uncovered1"><a name="line32"></a>  32       through_reflection      = reflection.through_reflection
</span><span class="uncovered0"><a name="line33"></a>  33       source_reflection_names = reflection.source_reflection_names
</span><span class="uncovered1"><a name="line34"></a>  34       source_associations     = reflection.through_reflection.klass.reflect_on_all_associations.collect { |a| a.name.inspect }
</span><span class="uncovered0"><a name="line35"></a>  35       super(&quot;Could not find the source association(s) #{source_reflection_names.collect(&amp;:inspect).to_sentence :connector =&gt; 'or'} in model #{through_reflection.klass}.  Try 'has_many #{reflection.name.inspect}, :through =&gt; #{through_reflection.name.inspect}, :source =&gt; &lt;name&gt;'.  Is it one of #{source_associations.to_sentence :connector =&gt; 'or'}?&quot;)
</span><span class="uncovered1"><a name="line36"></a>  36     end
</span><span class="uncovered0"><a name="line37"></a>  37   end
</span><span class="inferred1"><a name="line38"></a>  38 
</span><span class="marked0"><a name="line39"></a>  39   class HasManyThroughSourceAssociationMacroError &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line40"></a>  40     def initialize(reflection)
</span><span class="uncovered0"><a name="line41"></a>  41       through_reflection = reflection.through_reflection
</span><span class="uncovered1"><a name="line42"></a>  42       source_reflection  = reflection.source_reflection
</span><span class="uncovered0"><a name="line43"></a>  43       super(&quot;Invalid source reflection macro :#{source_reflection.macro}#{&quot; :through&quot; if source_reflection.options[:through]} for has_many #{reflection.name.inspect}, :through =&gt; #{through_reflection.name.inspect}.  Use :source to specify the source reflection.&quot;)
</span><span class="uncovered1"><a name="line44"></a>  44     end
</span><span class="uncovered0"><a name="line45"></a>  45   end
</span><span class="inferred1"><a name="line46"></a>  46 
</span><span class="marked0"><a name="line47"></a>  47   class HasManyThroughCantAssociateThroughHasManyReflection &lt; ActiveRecordError #:nodoc:
</span><span class="marked1"><a name="line48"></a>  48     def initialize(owner, reflection)
</span><span class="uncovered0"><a name="line49"></a>  49       super(&quot;Cannot modify association '#{owner.class.name}##{reflection.name}' because the source reflection class '#{reflection.source_reflection.class_name}' is associated to '#{reflection.through_reflection.class_name}' via :#{reflection.source_reflection.macro}.&quot;)
</span><span class="uncovered1"><a name="line50"></a>  50     end
</span><span class="uncovered0"><a name="line51"></a>  51   end
</span><span class="marked1"><a name="line52"></a>  52   class HasManyThroughCantAssociateNewRecords &lt; ActiveRecordError #:nodoc:
</span><span class="marked0"><a name="line53"></a>  53     def initialize(owner, reflection)
</span><span class="uncovered1"><a name="line54"></a>  54       super(&quot;Cannot associate new records through '#{owner.class.name}##{reflection.name}' on '#{reflection.source_reflection.class_name rescue nil}##{reflection.source_reflection.name rescue nil}'. Both records must have an id in order to create the has_many :through record associating them.&quot;)
</span><span class="uncovered0"><a name="line55"></a>  55     end
</span><span class="uncovered1"><a name="line56"></a>  56   end
</span><span class="inferred0"><a name="line57"></a>  57 
</span><span class="marked1"><a name="line58"></a>  58   class HasManyThroughCantDissociateNewRecords &lt; ActiveRecordError #:nodoc:
</span><span class="marked0"><a name="line59"></a>  59     def initialize(owner, reflection)
</span><span class="uncovered1"><a name="line60"></a>  60       super(&quot;Cannot dissociate new records through '#{owner.class.name}##{reflection.name}' on '#{reflection.source_reflection.class_name rescue nil}##{reflection.source_reflection.name rescue nil}'. Both records must have an id in order to delete the has_many :through record associating them.&quot;)
</span><span class="uncovered0"><a name="line61"></a>  61     end
</span><span class="uncovered1"><a name="line62"></a>  62   end
</span><span class="inferred0"><a name="line63"></a>  63 
</span><span class="marked1"><a name="line64"></a>  64   class EagerLoadPolymorphicError &lt; ActiveRecordError #:nodoc:
</span><span class="marked0"><a name="line65"></a>  65     def initialize(reflection)
</span><span class="uncovered1"><a name="line66"></a>  66       super(&quot;Can not eagerly load the polymorphic association #{reflection.name.inspect}&quot;)
</span><span class="uncovered0"><a name="line67"></a>  67     end
</span><span class="uncovered1"><a name="line68"></a>  68   end
</span><span class="inferred0"><a name="line69"></a>  69 
</span><span class="marked1"><a name="line70"></a>  70   class ReadOnlyAssociation &lt; ActiveRecordError #:nodoc:
</span><span class="marked0"><a name="line71"></a>  71     def initialize(reflection)
</span><span class="uncovered1"><a name="line72"></a>  72       super(&quot;Can not add to a has_many :through association.  Try adding to #{reflection.through_reflection.name.inspect}.&quot;)
</span><span class="uncovered0"><a name="line73"></a>  73     end
</span><span class="uncovered1"><a name="line74"></a>  74   end
</span><span class="inferred0"><a name="line75"></a>  75 
</span><span class="marked1"><a name="line76"></a>  76   module Associations # :nodoc:
</span><span class="marked0"><a name="line77"></a>  77     def self.included(base)
</span><span class="marked1"><a name="line78"></a>  78       base.extend(ClassMethods)
</span><span class="marked0"><a name="line79"></a>  79     end
</span><span class="inferred1"><a name="line80"></a>  80 
</span><span class="inferred0"><a name="line81"></a>  81     # Clears out the association cache
</span><span class="marked1"><a name="line82"></a>  82     def clear_association_cache #:nodoc:
</span><span class="uncovered0"><a name="line83"></a>  83       self.class.reflect_on_all_associations.to_a.each do |assoc|
</span><span class="uncovered1"><a name="line84"></a>  84         instance_variable_set &quot;@#{assoc.name}&quot;, nil
</span><span class="uncovered0"><a name="line85"></a>  85       end unless self.new_record?
</span><span class="uncovered1"><a name="line86"></a>  86     end
</span><span class="inferred0"><a name="line87"></a>  87 
</span><span class="inferred1"><a name="line88"></a>  88     # Associations are a set of macro-like class methods for tying objects together through foreign keys. They express relationships like
</span><span class="inferred0"><a name="line89"></a>  89     # &quot;Project has one Project Manager&quot; or &quot;Project belongs to a Portfolio&quot;. Each macro adds a number of methods to the class which are
</span><span class="inferred1"><a name="line90"></a>  90     # specialized according to the collection or association symbol and the options hash. It works much the same way as Ruby's own &lt;tt&gt;attr*&lt;/tt&gt;
</span><span class="inferred0"><a name="line91"></a>  91     # methods. Example:
</span><span class="inferred1"><a name="line92"></a>  92     #
</span><span class="inferred0"><a name="line93"></a>  93     #   class Project &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line94"></a>  94     #     belongs_to              :portfolio
</span><span class="inferred0"><a name="line95"></a>  95     #     has_one                 :project_manager
</span><span class="inferred1"><a name="line96"></a>  96     #     has_many                :milestones
</span><span class="inferred0"><a name="line97"></a>  97     #     has_and_belongs_to_many :categories
</span><span class="inferred1"><a name="line98"></a>  98     #   end
</span><span class="inferred0"><a name="line99"></a>  99     #
</span><span class="inferred1"><a name="line100"></a> 100     # The project class now has the following methods (and more) to ease the traversal and manipulation of its relationships:
</span><span class="inferred0"><a name="line101"></a> 101     # * &lt;tt&gt;Project#portfolio, Project#portfolio=(portfolio), Project#portfolio.nil?&lt;/tt&gt;
</span><span class="inferred1"><a name="line102"></a> 102     # * &lt;tt&gt;Project#project_manager, Project#project_manager=(project_manager), Project#project_manager.nil?,&lt;/tt&gt;
</span><span class="inferred0"><a name="line103"></a> 103     # * &lt;tt&gt;Project#milestones.empty?, Project#milestones.size, Project#milestones, Project#milestones&lt;&lt;(milestone),&lt;/tt&gt;
</span><span class="inferred1"><a name="line104"></a> 104     #   &lt;tt&gt;Project#milestones.delete(milestone), Project#milestones.find(milestone_id), Project#milestones.find(:all, options),&lt;/tt&gt;
</span><span class="inferred0"><a name="line105"></a> 105     #   &lt;tt&gt;Project#milestones.build, Project#milestones.create&lt;/tt&gt;
</span><span class="inferred1"><a name="line106"></a> 106     # * &lt;tt&gt;Project#categories.empty?, Project#categories.size, Project#categories, Project#categories&lt;&lt;(category1),&lt;/tt&gt;
</span><span class="inferred0"><a name="line107"></a> 107     #   &lt;tt&gt;Project#categories.delete(category1)&lt;/tt&gt;
</span><span class="inferred1"><a name="line108"></a> 108     #
</span><span class="inferred0"><a name="line109"></a> 109     # === A word of warning
</span><span class="inferred1"><a name="line110"></a> 110     #
</span><span class="inferred0"><a name="line111"></a> 111     # Don't create associations that have the same name as instance methods of ActiveRecord::Base. Since the association
</span><span class="inferred1"><a name="line112"></a> 112     # adds a method with that name to its model, it will override the inherited method and break things.
</span><span class="inferred0"><a name="line113"></a> 113     # For instance, +attributes+ and +connection+ would be bad choices for association names.
</span><span class="inferred1"><a name="line114"></a> 114     #
</span><span class="inferred0"><a name="line115"></a> 115     # == Auto-generated methods
</span><span class="inferred1"><a name="line116"></a> 116     #
</span><span class="inferred0"><a name="line117"></a> 117     # === Singular associations (one-to-one)
</span><span class="inferred1"><a name="line118"></a> 118     #                                     |            |  belongs_to  |
</span><span class="inferred0"><a name="line119"></a> 119     #   generated methods                 | belongs_to | :polymorphic | has_one
</span><span class="inferred1"><a name="line120"></a> 120     #   ----------------------------------+------------+--------------+---------
</span><span class="inferred0"><a name="line121"></a> 121     #   #other                            |     X      |      X       |    X
</span><span class="inferred1"><a name="line122"></a> 122     #   #other=(other)                    |     X      |      X       |    X
</span><span class="inferred0"><a name="line123"></a> 123     #   #build_other(attributes={})       |     X      |              |    X
</span><span class="inferred1"><a name="line124"></a> 124     #   #create_other(attributes={})      |     X      |              |    X
</span><span class="inferred0"><a name="line125"></a> 125     #   #other.create!(attributes={})     |            |              |    X
</span><span class="inferred1"><a name="line126"></a> 126     #   #other.nil?                       |     X      |      X       |
</span><span class="inferred0"><a name="line127"></a> 127     #
</span><span class="inferred1"><a name="line128"></a> 128     # ===Collection associations (one-to-many / many-to-many)
</span><span class="inferred0"><a name="line129"></a> 129     #                                     |       |          | has_many
</span><span class="inferred1"><a name="line130"></a> 130     #   generated methods                 | habtm | has_many | :through
</span><span class="inferred0"><a name="line131"></a> 131     #   ----------------------------------+-------+----------+----------
</span><span class="inferred1"><a name="line132"></a> 132     #   #others                           |   X   |    X     |    X
</span><span class="inferred0"><a name="line133"></a> 133     #   #others=(other,other,...)         |   X   |    X     |    X
</span><span class="inferred1"><a name="line134"></a> 134     #   #other_ids                        |   X   |    X     |    X
</span><span class="inferred0"><a name="line135"></a> 135     #   #other_ids=(id,id,...)            |   X   |    X     |    X
</span><span class="inferred1"><a name="line136"></a> 136     #   #others&lt;&lt;                         |   X   |    X     |    X
</span><span class="inferred0"><a name="line137"></a> 137     #   #others.push                      |   X   |    X     |    X
</span><span class="inferred1"><a name="line138"></a> 138     #   #others.concat                    |   X   |    X     |    X
</span><span class="inferred0"><a name="line139"></a> 139     #   #others.build(attributes={})      |   X   |    X     |    X
</span><span class="inferred1"><a name="line140"></a> 140     #   #others.create(attributes={})     |   X   |    X     |    X
</span><span class="inferred0"><a name="line141"></a> 141     #   #others.create!(attributes={})    |   X   |    X     |    X
</span><span class="inferred1"><a name="line142"></a> 142     #   #others.size                      |   X   |    X     |    X
</span><span class="inferred0"><a name="line143"></a> 143     #   #others.length                    |   X   |    X     |    X
</span><span class="inferred1"><a name="line144"></a> 144     #   #others.count                     |   X   |    X     |    X
</span><span class="inferred0"><a name="line145"></a> 145     #   #others.sum(args*,&amp;block)         |   X   |    X     |    X
</span><span class="inferred1"><a name="line146"></a> 146     #   #others.empty?                    |   X   |    X     |    X
</span><span class="inferred0"><a name="line147"></a> 147     #   #others.clear                     |   X   |    X     |    X
</span><span class="inferred1"><a name="line148"></a> 148     #   #others.delete(other,other,...)   |   X   |    X     |    X
</span><span class="inferred0"><a name="line149"></a> 149     #   #others.delete_all                |   X   |    X     |
</span><span class="inferred1"><a name="line150"></a> 150     #   #others.destroy_all               |   X   |    X     |    X
</span><span class="inferred0"><a name="line151"></a> 151     #   #others.find(*args)               |   X   |    X     |    X
</span><span class="inferred1"><a name="line152"></a> 152     #   #others.find_first                |   X   |          |
</span><span class="inferred0"><a name="line153"></a> 153     #   #others.uniq                      |   X   |    X     |    X
</span><span class="inferred1"><a name="line154"></a> 154     #   #others.reset                     |   X   |    X     |    X
</span><span class="inferred0"><a name="line155"></a> 155     #
</span><span class="inferred1"><a name="line156"></a> 156     # == Cardinality and associations
</span><span class="inferred0"><a name="line157"></a> 157     #
</span><span class="inferred1"><a name="line158"></a> 158     # Active Record associations can be used to describe one-to-one, one-to-many and many-to-many
</span><span class="inferred0"><a name="line159"></a> 159     # relationships between models. Each model uses an association to describe its role in
</span><span class="inferred1"><a name="line160"></a> 160     # the relation. The +belongs_to+ association is always used in the model that has
</span><span class="inferred0"><a name="line161"></a> 161     # the foreign key.
</span><span class="inferred1"><a name="line162"></a> 162     #
</span><span class="inferred0"><a name="line163"></a> 163     # === One-to-one
</span><span class="inferred1"><a name="line164"></a> 164     #
</span><span class="inferred0"><a name="line165"></a> 165     # Use +has_one+ in the base, and +belongs_to+ in the associated model.
</span><span class="inferred1"><a name="line166"></a> 166     #
</span><span class="inferred0"><a name="line167"></a> 167     #   class Employee &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line168"></a> 168     #     has_one :office
</span><span class="inferred0"><a name="line169"></a> 169     #   end
</span><span class="inferred1"><a name="line170"></a> 170     #   class Office &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line171"></a> 171     #     belongs_to :employee    # foreign key - employee_id
</span><span class="inferred1"><a name="line172"></a> 172     #   end
</span><span class="inferred0"><a name="line173"></a> 173     #
</span><span class="inferred1"><a name="line174"></a> 174     # === One-to-many
</span><span class="inferred0"><a name="line175"></a> 175     #
</span><span class="inferred1"><a name="line176"></a> 176     # Use +has_many+ in the base, and +belongs_to+ in the associated model.
</span><span class="inferred0"><a name="line177"></a> 177     #
</span><span class="inferred1"><a name="line178"></a> 178     #   class Manager &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line179"></a> 179     #     has_many :employees
</span><span class="inferred1"><a name="line180"></a> 180     #   end
</span><span class="inferred0"><a name="line181"></a> 181     #   class Employee &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line182"></a> 182     #     belongs_to :manager     # foreign key - manager_id
</span><span class="inferred0"><a name="line183"></a> 183     #   end
</span><span class="inferred1"><a name="line184"></a> 184     #
</span><span class="inferred0"><a name="line185"></a> 185     # === Many-to-many
</span><span class="inferred1"><a name="line186"></a> 186     #
</span><span class="inferred0"><a name="line187"></a> 187     # There are two ways to build a many-to-many relationship.
</span><span class="inferred1"><a name="line188"></a> 188     #
</span><span class="inferred0"><a name="line189"></a> 189     # The first way uses a +has_many+ association with the &lt;tt&gt;:through&lt;/tt&gt; option and a join model, so
</span><span class="inferred1"><a name="line190"></a> 190     # there are two stages of associations.
</span><span class="inferred0"><a name="line191"></a> 191     #
</span><span class="inferred1"><a name="line192"></a> 192     #   class Assignment &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line193"></a> 193     #     belongs_to :programmer  # foreign key - programmer_id
</span><span class="inferred1"><a name="line194"></a> 194     #     belongs_to :project     # foreign key - project_id
</span><span class="inferred0"><a name="line195"></a> 195     #   end
</span><span class="inferred1"><a name="line196"></a> 196     #   class Programmer &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line197"></a> 197     #     has_many :assignments
</span><span class="inferred1"><a name="line198"></a> 198     #     has_many :projects, :through =&gt; :assignments
</span><span class="inferred0"><a name="line199"></a> 199     #   end
</span><span class="inferred1"><a name="line200"></a> 200     #   class Project &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line201"></a> 201     #     has_many :assignments
</span><span class="inferred1"><a name="line202"></a> 202     #     has_many :programmers, :through =&gt; :assignments
</span><span class="inferred0"><a name="line203"></a> 203     #   end
</span><span class="inferred1"><a name="line204"></a> 204     #
</span><span class="inferred0"><a name="line205"></a> 205     # For the second way, use +has_and_belongs_to_many+ in both models. This requires a join table
</span><span class="inferred1"><a name="line206"></a> 206     # that has no corresponding model or primary key.
</span><span class="inferred0"><a name="line207"></a> 207     #
</span><span class="inferred1"><a name="line208"></a> 208     #   class Programmer &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line209"></a> 209     #     has_and_belongs_to_many :projects       # foreign keys in the join table
</span><span class="inferred1"><a name="line210"></a> 210     #   end
</span><span class="inferred0"><a name="line211"></a> 211     #   class Project &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line212"></a> 212     #     has_and_belongs_to_many :programmers    # foreign keys in the join table
</span><span class="inferred0"><a name="line213"></a> 213     #   end
</span><span class="inferred1"><a name="line214"></a> 214     #
</span><span class="inferred0"><a name="line215"></a> 215     # Choosing which way to build a many-to-many relationship is not always simple.
</span><span class="inferred1"><a name="line216"></a> 216     # If you need to work with the relationship model as its own entity,
</span><span class="inferred0"><a name="line217"></a> 217     # use &lt;tt&gt;has_many :through&lt;/tt&gt;. Use +has_and_belongs_to_many+ when working with legacy schemas or when
</span><span class="inferred1"><a name="line218"></a> 218     # you never work directly with the relationship itself.
</span><span class="inferred0"><a name="line219"></a> 219     #
</span><span class="inferred1"><a name="line220"></a> 220     # == Is it a +belongs_to+ or +has_one+ association?
</span><span class="inferred0"><a name="line221"></a> 221     #
</span><span class="inferred1"><a name="line222"></a> 222     # Both express a 1-1 relationship. The difference is mostly where to place the foreign key, which goes on the table for the class
</span><span class="inferred0"><a name="line223"></a> 223     # declaring the +belongs_to+ relationship. Example:
</span><span class="inferred1"><a name="line224"></a> 224     #
</span><span class="inferred0"><a name="line225"></a> 225     #   class User &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line226"></a> 226     #     # I reference an account.
</span><span class="inferred0"><a name="line227"></a> 227     #     belongs_to :account
</span><span class="inferred1"><a name="line228"></a> 228     #   end
</span><span class="inferred0"><a name="line229"></a> 229     #
</span><span class="inferred1"><a name="line230"></a> 230     #   class Account &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line231"></a> 231     #     # One user references me.
</span><span class="inferred1"><a name="line232"></a> 232     #     has_one :user
</span><span class="inferred0"><a name="line233"></a> 233     #   end
</span><span class="inferred1"><a name="line234"></a> 234     #
</span><span class="inferred0"><a name="line235"></a> 235     # The tables for these classes could look something like:
</span><span class="inferred1"><a name="line236"></a> 236     #
</span><span class="inferred0"><a name="line237"></a> 237     #   CREATE TABLE users (
</span><span class="inferred1"><a name="line238"></a> 238     #     id int(11) NOT NULL auto_increment,
</span><span class="inferred0"><a name="line239"></a> 239     #     account_id int(11) default NULL,
</span><span class="inferred1"><a name="line240"></a> 240     #     name varchar default NULL,
</span><span class="inferred0"><a name="line241"></a> 241     #     PRIMARY KEY  (id)
</span><span class="inferred1"><a name="line242"></a> 242     #   )
</span><span class="inferred0"><a name="line243"></a> 243     #
</span><span class="inferred1"><a name="line244"></a> 244     #   CREATE TABLE accounts (
</span><span class="inferred0"><a name="line245"></a> 245     #     id int(11) NOT NULL auto_increment,
</span><span class="inferred1"><a name="line246"></a> 246     #     name varchar default NULL,
</span><span class="inferred0"><a name="line247"></a> 247     #     PRIMARY KEY  (id)
</span><span class="inferred1"><a name="line248"></a> 248     #   )
</span><span class="inferred0"><a name="line249"></a> 249     #
</span><span class="inferred1"><a name="line250"></a> 250     # == Unsaved objects and associations
</span><span class="inferred0"><a name="line251"></a> 251     #
</span><span class="inferred1"><a name="line252"></a> 252     # You can manipulate objects and associations before they are saved to the database, but there is some special behavior you should be
</span><span class="inferred0"><a name="line253"></a> 253     # aware of, mostly involving the saving of associated objects.
</span><span class="inferred1"><a name="line254"></a> 254     #
</span><span class="inferred0"><a name="line255"></a> 255     # === One-to-one associations
</span><span class="inferred1"><a name="line256"></a> 256     #
</span><span class="inferred0"><a name="line257"></a> 257     # * Assigning an object to a +has_one+ association automatically saves that object and the object being replaced (if there is one), in
</span><span class="inferred1"><a name="line258"></a> 258     #   order to update their primary keys - except if the parent object is unsaved (&lt;tt&gt;new_record? == true&lt;/tt&gt;).
</span><span class="inferred0"><a name="line259"></a> 259     # * If either of these saves fail (due to one of the objects being invalid) the assignment statement returns +false+ and the assignment
</span><span class="inferred1"><a name="line260"></a> 260     #   is cancelled.
</span><span class="inferred0"><a name="line261"></a> 261     # * If you wish to assign an object to a +has_one+ association without saving it, use the &lt;tt&gt;association.build&lt;/tt&gt; method (documented below).
</span><span class="inferred1"><a name="line262"></a> 262     # * Assigning an object to a +belongs_to+ association does not save the object, since the foreign key field belongs on the parent. It
</span><span class="inferred0"><a name="line263"></a> 263     #   does not save the parent either.
</span><span class="inferred1"><a name="line264"></a> 264     #
</span><span class="inferred0"><a name="line265"></a> 265     # === Collections
</span><span class="inferred1"><a name="line266"></a> 266     #
</span><span class="inferred0"><a name="line267"></a> 267     # * Adding an object to a collection (+has_many+ or +has_and_belongs_to_many+) automatically saves that object, except if the parent object
</span><span class="inferred1"><a name="line268"></a> 268     #   (the owner of the collection) is not yet stored in the database.
</span><span class="inferred0"><a name="line269"></a> 269     # * If saving any of the objects being added to a collection (via &lt;tt&gt;push&lt;/tt&gt; or similar) fails, then &lt;tt&gt;push&lt;/tt&gt; returns +false+.
</span><span class="inferred1"><a name="line270"></a> 270     # * You can add an object to a collection without automatically saving it by using the &lt;tt&gt;collection.build&lt;/tt&gt; method (documented below).
</span><span class="inferred0"><a name="line271"></a> 271     # * All unsaved (&lt;tt&gt;new_record? == true&lt;/tt&gt;) members of the collection are automatically saved when the parent is saved.
</span><span class="inferred1"><a name="line272"></a> 272     #
</span><span class="inferred0"><a name="line273"></a> 273     # === Association callbacks
</span><span class="inferred1"><a name="line274"></a> 274     #
</span><span class="inferred0"><a name="line275"></a> 275     # Similar to the normal callbacks that hook into the lifecycle of an Active Record object, you can also define callbacks that get
</span><span class="inferred1"><a name="line276"></a> 276     # triggered when you add an object to or remove an object from an association collection. Example:
</span><span class="inferred0"><a name="line277"></a> 277     #
</span><span class="inferred1"><a name="line278"></a> 278     #   class Project
</span><span class="inferred0"><a name="line279"></a> 279     #     has_and_belongs_to_many :developers, :after_add =&gt; :evaluate_velocity
</span><span class="inferred1"><a name="line280"></a> 280     #
</span><span class="inferred0"><a name="line281"></a> 281     #     def evaluate_velocity(developer)
</span><span class="inferred1"><a name="line282"></a> 282     #       ...
</span><span class="inferred0"><a name="line283"></a> 283     #     end
</span><span class="inferred1"><a name="line284"></a> 284     #   end
</span><span class="inferred0"><a name="line285"></a> 285     #
</span><span class="inferred1"><a name="line286"></a> 286     # It's possible to stack callbacks by passing them as an array. Example:
</span><span class="inferred0"><a name="line287"></a> 287     #
</span><span class="inferred1"><a name="line288"></a> 288     #   class Project
</span><span class="inferred0"><a name="line289"></a> 289     #     has_and_belongs_to_many :developers, :after_add =&gt; [:evaluate_velocity, Proc.new { |p, d| p.shipping_date = Time.now}]
</span><span class="inferred1"><a name="line290"></a> 290     #   end
</span><span class="inferred0"><a name="line291"></a> 291     #
</span><span class="inferred1"><a name="line292"></a> 292     # Possible callbacks are: +before_add+, +after_add+, +before_remove+ and +after_remove+.
</span><span class="inferred0"><a name="line293"></a> 293     #
</span><span class="inferred1"><a name="line294"></a> 294     # Should any of the +before_add+ callbacks throw an exception, the object does not get added to the collection. Same with
</span><span class="inferred0"><a name="line295"></a> 295     # the +before_remove+ callbacks; if an exception is thrown the object doesn't get removed.
</span><span class="inferred1"><a name="line296"></a> 296     #
</span><span class="inferred0"><a name="line297"></a> 297     # === Association extensions
</span><span class="inferred1"><a name="line298"></a> 298     #
</span><span class="inferred0"><a name="line299"></a> 299     # The proxy objects that control the access to associations can be extended through anonymous modules. This is especially
</span><span class="inferred1"><a name="line300"></a> 300     # beneficial for adding new finders, creators, and other factory-type methods that are only used as part of this association.
</span><span class="inferred0"><a name="line301"></a> 301     # Example:
</span><span class="inferred1"><a name="line302"></a> 302     #
</span><span class="inferred0"><a name="line303"></a> 303     #   class Account &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line304"></a> 304     #     has_many :people do
</span><span class="inferred0"><a name="line305"></a> 305     #       def find_or_create_by_name(name)
</span><span class="inferred1"><a name="line306"></a> 306     #         first_name, last_name = name.split(&quot; &quot;, 2)
</span><span class="inferred0"><a name="line307"></a> 307     #         find_or_create_by_first_name_and_last_name(first_name, last_name)
</span><span class="inferred1"><a name="line308"></a> 308     #       end
</span><span class="inferred0"><a name="line309"></a> 309     #     end
</span><span class="inferred1"><a name="line310"></a> 310     #   end
</span><span class="inferred0"><a name="line311"></a> 311     #
</span><span class="inferred1"><a name="line312"></a> 312     #   person = Account.find(:first).people.find_or_create_by_name(&quot;David Heinemeier Hansson&quot;)
</span><span class="inferred0"><a name="line313"></a> 313     #   person.first_name # =&gt; &quot;David&quot;
</span><span class="inferred1"><a name="line314"></a> 314     #   person.last_name  # =&gt; &quot;Heinemeier Hansson&quot;
</span><span class="inferred0"><a name="line315"></a> 315     #
</span><span class="inferred1"><a name="line316"></a> 316     # If you need to share the same extensions between many associations, you can use a named extension module. Example:
</span><span class="inferred0"><a name="line317"></a> 317     #
</span><span class="inferred1"><a name="line318"></a> 318     #   module FindOrCreateByNameExtension
</span><span class="inferred0"><a name="line319"></a> 319     #     def find_or_create_by_name(name)
</span><span class="inferred1"><a name="line320"></a> 320     #       first_name, last_name = name.split(&quot; &quot;, 2)
</span><span class="inferred0"><a name="line321"></a> 321     #       find_or_create_by_first_name_and_last_name(first_name, last_name)
</span><span class="inferred1"><a name="line322"></a> 322     #     end
</span><span class="inferred0"><a name="line323"></a> 323     #   end
</span><span class="inferred1"><a name="line324"></a> 324     #
</span><span class="inferred0"><a name="line325"></a> 325     #   class Account &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line326"></a> 326     #     has_many :people, :extend =&gt; FindOrCreateByNameExtension
</span><span class="inferred0"><a name="line327"></a> 327     #   end
</span><span class="inferred1"><a name="line328"></a> 328     #
</span><span class="inferred0"><a name="line329"></a> 329     #   class Company &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line330"></a> 330     #     has_many :people, :extend =&gt; FindOrCreateByNameExtension
</span><span class="inferred0"><a name="line331"></a> 331     #   end
</span><span class="inferred1"><a name="line332"></a> 332     #
</span><span class="inferred0"><a name="line333"></a> 333     # If you need to use multiple named extension modules, you can specify an array of modules with the &lt;tt&gt;:extend&lt;/tt&gt; option.
</span><span class="inferred1"><a name="line334"></a> 334     # In the case of name conflicts between methods in the modules, methods in modules later in the array supercede
</span><span class="inferred0"><a name="line335"></a> 335     # those earlier in the array. Example:
</span><span class="inferred1"><a name="line336"></a> 336     #
</span><span class="inferred0"><a name="line337"></a> 337     #   class Account &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line338"></a> 338     #     has_many :people, :extend =&gt; [FindOrCreateByNameExtension, FindRecentExtension]
</span><span class="inferred0"><a name="line339"></a> 339     #   end
</span><span class="inferred1"><a name="line340"></a> 340     #
</span><span class="inferred0"><a name="line341"></a> 341     # Some extensions can only be made to work with knowledge of the association proxy's internals.
</span><span class="inferred1"><a name="line342"></a> 342     # Extensions can access relevant state using accessors on the association proxy:
</span><span class="inferred0"><a name="line343"></a> 343     #
</span><span class="inferred1"><a name="line344"></a> 344     # * +proxy_owner+ - Returns the object the association is part of.
</span><span class="inferred0"><a name="line345"></a> 345     # * +proxy_reflection+ - Returns the reflection object that describes the association.
</span><span class="inferred1"><a name="line346"></a> 346     # * +proxy_target+ - Returns the associated object for +belongs_to+ and +has_one+, or the collection of associated objects for +has_many+ and +has_and_belongs_to_many+.
</span><span class="inferred0"><a name="line347"></a> 347     #
</span><span class="inferred1"><a name="line348"></a> 348     # === Association Join Models
</span><span class="inferred0"><a name="line349"></a> 349     #
</span><span class="inferred1"><a name="line350"></a> 350     # Has Many associations can be configured with the &lt;tt&gt;:through&lt;/tt&gt; option to use an explicit join model to retrieve the data.  This
</span><span class="inferred0"><a name="line351"></a> 351     # operates similarly to a +has_and_belongs_to_many+ association.  The advantage is that you're able to add validations,
</span><span class="inferred1"><a name="line352"></a> 352     # callbacks, and extra attributes on the join model.  Consider the following schema:
</span><span class="inferred0"><a name="line353"></a> 353     #
</span><span class="inferred1"><a name="line354"></a> 354     #   class Author &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line355"></a> 355     #     has_many :authorships
</span><span class="inferred1"><a name="line356"></a> 356     #     has_many :books, :through =&gt; :authorships
</span><span class="inferred0"><a name="line357"></a> 357     #   end
</span><span class="inferred1"><a name="line358"></a> 358     #
</span><span class="inferred0"><a name="line359"></a> 359     #   class Authorship &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line360"></a> 360     #     belongs_to :author
</span><span class="inferred0"><a name="line361"></a> 361     #     belongs_to :book
</span><span class="inferred1"><a name="line362"></a> 362     #   end
</span><span class="inferred0"><a name="line363"></a> 363     #
</span><span class="inferred1"><a name="line364"></a> 364     #   @author = Author.find :first
</span><span class="inferred0"><a name="line365"></a> 365     #   @author.authorships.collect { |a| a.book } # selects all books that the author's authorships belong to.
</span><span class="inferred1"><a name="line366"></a> 366     #   @author.books                              # selects all books by using the Authorship join model
</span><span class="inferred0"><a name="line367"></a> 367     #
</span><span class="inferred1"><a name="line368"></a> 368     # You can also go through a +has_many+ association on the join model:
</span><span class="inferred0"><a name="line369"></a> 369     #
</span><span class="inferred1"><a name="line370"></a> 370     #   class Firm &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line371"></a> 371     #     has_many   :clients
</span><span class="inferred1"><a name="line372"></a> 372     #     has_many   :invoices, :through =&gt; :clients
</span><span class="inferred0"><a name="line373"></a> 373     #   end
</span><span class="inferred1"><a name="line374"></a> 374     #
</span><span class="inferred0"><a name="line375"></a> 375     #   class Client &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line376"></a> 376     #     belongs_to :firm
</span><span class="inferred0"><a name="line377"></a> 377     #     has_many   :invoices
</span><span class="inferred1"><a name="line378"></a> 378     #   end
</span><span class="inferred0"><a name="line379"></a> 379     #
</span><span class="inferred1"><a name="line380"></a> 380     #   class Invoice &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line381"></a> 381     #     belongs_to :client
</span><span class="inferred1"><a name="line382"></a> 382     #   end
</span><span class="inferred0"><a name="line383"></a> 383     #
</span><span class="inferred1"><a name="line384"></a> 384     #   @firm = Firm.find :first
</span><span class="inferred0"><a name="line385"></a> 385     #   @firm.clients.collect { |c| c.invoices }.flatten # select all invoices for all clients of the firm
</span><span class="inferred1"><a name="line386"></a> 386     #   @firm.invoices                                   # selects all invoices by going through the Client join model.
</span><span class="inferred0"><a name="line387"></a> 387     #
</span><span class="inferred1"><a name="line388"></a> 388     # === Polymorphic Associations
</span><span class="inferred0"><a name="line389"></a> 389     #
</span><span class="inferred1"><a name="line390"></a> 390     # Polymorphic associations on models are not restricted on what types of models they can be associated with.  Rather, they
</span><span class="inferred0"><a name="line391"></a> 391     # specify an interface that a +has_many+ association must adhere to.
</span><span class="inferred1"><a name="line392"></a> 392     #
</span><span class="inferred0"><a name="line393"></a> 393     #   class Asset &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line394"></a> 394     #     belongs_to :attachable, :polymorphic =&gt; true
</span><span class="inferred0"><a name="line395"></a> 395     #   end
</span><span class="inferred1"><a name="line396"></a> 396     #
</span><span class="inferred0"><a name="line397"></a> 397     #   class Post &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line398"></a> 398     #     has_many :assets, :as =&gt; :attachable         # The :as option specifies the polymorphic interface to use.
</span><span class="inferred0"><a name="line399"></a> 399     #   end
</span><span class="inferred1"><a name="line400"></a> 400     #
</span><span class="inferred0"><a name="line401"></a> 401     #   @asset.attachable = @post
</span><span class="inferred1"><a name="line402"></a> 402     #
</span><span class="inferred0"><a name="line403"></a> 403     # This works by using a type column in addition to a foreign key to specify the associated record.  In the Asset example, you'd need
</span><span class="inferred1"><a name="line404"></a> 404     # an +attachable_id+ integer column and an +attachable_type+ string column.
</span><span class="inferred0"><a name="line405"></a> 405     #
</span><span class="inferred1"><a name="line406"></a> 406     # Using polymorphic associations in combination with single table inheritance (STI) is a little tricky. In order
</span><span class="inferred0"><a name="line407"></a> 407     # for the associations to work as expected, ensure that you store the base model for the STI models in the
</span><span class="inferred1"><a name="line408"></a> 408     # type column of the polymorphic association. To continue with the asset example above, suppose there are guest posts
</span><span class="inferred0"><a name="line409"></a> 409     # and member posts that use the posts table for STI. In this case, there must be a +type+ column in the posts table.
</span><span class="inferred1"><a name="line410"></a> 410     #
</span><span class="inferred0"><a name="line411"></a> 411     #   class Asset &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line412"></a> 412     #     belongs_to :attachable, :polymorphic =&gt; true
</span><span class="inferred0"><a name="line413"></a> 413     #
</span><span class="inferred1"><a name="line414"></a> 414     #     def attachable_type=(sType)
</span><span class="inferred0"><a name="line415"></a> 415     #        super(sType.to_s.classify.constantize.base_class.to_s)
</span><span class="inferred1"><a name="line416"></a> 416     #     end
</span><span class="inferred0"><a name="line417"></a> 417     #   end
</span><span class="inferred1"><a name="line418"></a> 418     #
</span><span class="inferred0"><a name="line419"></a> 419     #   class Post &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line420"></a> 420     #     # because we store &quot;Post&quot; in attachable_type now :dependent =&gt; :destroy will work
</span><span class="inferred0"><a name="line421"></a> 421     #     has_many :assets, :as =&gt; :attachable, :dependent =&gt; :destroy
</span><span class="inferred1"><a name="line422"></a> 422     #   end
</span><span class="inferred0"><a name="line423"></a> 423     #
</span><span class="inferred1"><a name="line424"></a> 424     #   class GuestPost &lt; Post
</span><span class="inferred0"><a name="line425"></a> 425     #   end
</span><span class="inferred1"><a name="line426"></a> 426     #
</span><span class="inferred0"><a name="line427"></a> 427     #   class MemberPost &lt; Post
</span><span class="inferred1"><a name="line428"></a> 428     #   end
</span><span class="inferred0"><a name="line429"></a> 429     #
</span><span class="inferred1"><a name="line430"></a> 430     # == Caching
</span><span class="inferred0"><a name="line431"></a> 431     #
</span><span class="inferred1"><a name="line432"></a> 432     # All of the methods are built on a simple caching principle that will keep the result of the last query around unless specifically
</span><span class="inferred0"><a name="line433"></a> 433     # instructed not to. The cache is even shared across methods to make it even cheaper to use the macro-added methods without
</span><span class="inferred1"><a name="line434"></a> 434     # worrying too much about performance at the first go. Example:
</span><span class="inferred0"><a name="line435"></a> 435     #
</span><span class="inferred1"><a name="line436"></a> 436     #   project.milestones             # fetches milestones from the database
</span><span class="inferred0"><a name="line437"></a> 437     #   project.milestones.size        # uses the milestone cache
</span><span class="inferred1"><a name="line438"></a> 438     #   project.milestones.empty?      # uses the milestone cache
</span><span class="inferred0"><a name="line439"></a> 439     #   project.milestones(true).size  # fetches milestones from the database
</span><span class="inferred1"><a name="line440"></a> 440     #   project.milestones             # uses the milestone cache
</span><span class="inferred0"><a name="line441"></a> 441     #
</span><span class="inferred1"><a name="line442"></a> 442     # == Eager loading of associations
</span><span class="inferred0"><a name="line443"></a> 443     #
</span><span class="inferred1"><a name="line444"></a> 444     # Eager loading is a way to find objects of a certain class and a number of named associations. This is
</span><span class="inferred0"><a name="line445"></a> 445     # one of the easiest ways of to prevent the dreaded 1+N problem in which fetching 100 posts that each need to display their author
</span><span class="inferred1"><a name="line446"></a> 446     # triggers 101 database queries. Through the use of eager loading, the 101 queries can be reduced to 2. Example:
</span><span class="inferred0"><a name="line447"></a> 447     #
</span><span class="inferred1"><a name="line448"></a> 448     #   class Post &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line449"></a> 449     #     belongs_to :author
</span><span class="inferred1"><a name="line450"></a> 450     #     has_many   :comments
</span><span class="inferred0"><a name="line451"></a> 451     #   end
</span><span class="inferred1"><a name="line452"></a> 452     #
</span><span class="inferred0"><a name="line453"></a> 453     # Consider the following loop using the class above:
</span><span class="inferred1"><a name="line454"></a> 454     #
</span><span class="inferred0"><a name="line455"></a> 455     #   for post in Post.all
</span><span class="inferred1"><a name="line456"></a> 456     #     puts &quot;Post:            &quot; + post.title
</span><span class="inferred0"><a name="line457"></a> 457     #     puts &quot;Written by:      &quot; + post.author.name
</span><span class="inferred1"><a name="line458"></a> 458     #     puts &quot;Last comment on: &quot; + post.comments.first.created_on
</span><span class="inferred0"><a name="line459"></a> 459     #   end
</span><span class="inferred1"><a name="line460"></a> 460     #
</span><span class="inferred0"><a name="line461"></a> 461     # To iterate over these one hundred posts, we'll generate 201 database queries. Let's first just optimize it for retrieving the author:
</span><span class="inferred1"><a name="line462"></a> 462     #
</span><span class="inferred0"><a name="line463"></a> 463     #   for post in Post.find(:all, :include =&gt; :author)
</span><span class="inferred1"><a name="line464"></a> 464     #
</span><span class="inferred0"><a name="line465"></a> 465     # This references the name of the +belongs_to+ association that also used the &lt;tt&gt;:author&lt;/tt&gt; symbol. After loading the posts, find
</span><span class="inferred1"><a name="line466"></a> 466     # will collect the +author_id+ from each one and load all the referenced authors with one query. Doing so will cut down the number of queries from 201 to 102.
</span><span class="inferred0"><a name="line467"></a> 467     #
</span><span class="inferred1"><a name="line468"></a> 468     # We can improve upon the situation further by referencing both associations in the finder with:
</span><span class="inferred0"><a name="line469"></a> 469     #
</span><span class="inferred1"><a name="line470"></a> 470     #   for post in Post.find(:all, :include =&gt; [ :author, :comments ])
</span><span class="inferred0"><a name="line471"></a> 471     #
</span><span class="inferred1"><a name="line472"></a> 472     # This will load all comments with a single query. This reduces the total number of queries to 3. More generally the number of queries
</span><span class="inferred0"><a name="line473"></a> 473     # will be 1 plus the number of associations named (except if some of the associations are polymorphic +belongs_to+ - see below).
</span><span class="inferred1"><a name="line474"></a> 474     #
</span><span class="inferred0"><a name="line475"></a> 475     # To include a deep hierarchy of associations, use a hash:
</span><span class="inferred1"><a name="line476"></a> 476     #
</span><span class="inferred0"><a name="line477"></a> 477     #   for post in Post.find(:all, :include =&gt; [ :author, { :comments =&gt; { :author =&gt; :gravatar } } ])
</span><span class="inferred1"><a name="line478"></a> 478     #
</span><span class="inferred0"><a name="line479"></a> 479     # That'll grab not only all the comments but all their authors and gravatar pictures.  You can mix and match
</span><span class="inferred1"><a name="line480"></a> 480     # symbols, arrays and hashes in any combination to describe the associations you want to load.
</span><span class="inferred0"><a name="line481"></a> 481     #
</span><span class="inferred1"><a name="line482"></a> 482     # All of this power shouldn't fool you into thinking that you can pull out huge amounts of data with no performance penalty just because you've reduced
</span><span class="inferred0"><a name="line483"></a> 483     # the number of queries. The database still needs to send all the data to Active Record and it still needs to be processed. So it's no
</span><span class="inferred1"><a name="line484"></a> 484     # catch-all for performance problems, but it's a great way to cut down on the number of queries in a situation as the one described above.
</span><span class="inferred0"><a name="line485"></a> 485     #
</span><span class="inferred1"><a name="line486"></a> 486     # Since only one table is loaded at a time, conditions or orders cannot reference tables other than the main one. If this is the case
</span><span class="inferred0"><a name="line487"></a> 487     # Active Record falls back to the previously used LEFT OUTER JOIN based strategy. For example
</span><span class="inferred1"><a name="line488"></a> 488     #  
</span><span class="inferred0"><a name="line489"></a> 489     #   Post.find(:all, :include =&gt; [ :author, :comments ], :conditions =&gt; ['comments.approved = ?', true])
</span><span class="inferred1"><a name="line490"></a> 490     #
</span><span class="inferred0"><a name="line491"></a> 491     # will result in a single SQL query with joins along the lines of: &lt;tt&gt;LEFT OUTER JOIN comments ON comments.post_id = posts.id&lt;/tt&gt; and
</span><span class="inferred1"><a name="line492"></a> 492     # &lt;tt&gt;LEFT OUTER JOIN authors ON authors.id = posts.author_id&lt;/tt&gt;. Note that using conditions like this can have unintended consequences.
</span><span class="inferred0"><a name="line493"></a> 493     # In the above example posts with no approved comments are not returned at all, because the conditions apply to the SQL statement as a whole
</span><span class="inferred1"><a name="line494"></a> 494     # and not just to the association. You must disambiguate column references for this fallback to happen, for example
</span><span class="inferred0"><a name="line495"></a> 495     # &lt;tt&gt;:order =&gt; &quot;author.name DESC&quot;&lt;/tt&gt; will work but &lt;tt&gt;:order =&gt; &quot;name DESC&quot;&lt;/tt&gt; will not. 
</span><span class="inferred1"><a name="line496"></a> 496     #
</span><span class="inferred0"><a name="line497"></a> 497     # If you do want eagerload only some members of an association it is usually more natural to &lt;tt&gt;:include&lt;/tt&gt; an association
</span><span class="inferred1"><a name="line498"></a> 498     # which has conditions defined on it:
</span><span class="inferred0"><a name="line499"></a> 499     #
</span><span class="inferred1"><a name="line500"></a> 500     #   class Post &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line501"></a> 501     #     has_many :approved_comments, :class_name =&gt; 'Comment', :conditions =&gt; ['approved = ?', true]
</span><span class="inferred1"><a name="line502"></a> 502     #   end
</span><span class="inferred0"><a name="line503"></a> 503     #
</span><span class="inferred1"><a name="line504"></a> 504     #   Post.find(:all, :include =&gt; :approved_comments)
</span><span class="inferred0"><a name="line505"></a> 505     #
</span><span class="inferred1"><a name="line506"></a> 506     # will load posts and eager load the +approved_comments+ association, which contains only those comments that have been approved.
</span><span class="inferred0"><a name="line507"></a> 507     #
</span><span class="inferred1"><a name="line508"></a> 508     # When eager loaded, conditions are interpolated in the context of the model class, not the model instance.  Conditions are lazily interpolated
</span><span class="inferred0"><a name="line509"></a> 509     # before the actual model exists.
</span><span class="inferred1"><a name="line510"></a> 510     #
</span><span class="inferred0"><a name="line511"></a> 511     # Eager loading is supported with polymorphic associations.
</span><span class="inferred1"><a name="line512"></a> 512     #
</span><span class="inferred0"><a name="line513"></a> 513     #   class Address &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line514"></a> 514     #     belongs_to :addressable, :polymorphic =&gt; true
</span><span class="inferred0"><a name="line515"></a> 515     #   end
</span><span class="inferred1"><a name="line516"></a> 516     #
</span><span class="inferred0"><a name="line517"></a> 517     # A call that tries to eager load the addressable model
</span><span class="inferred1"><a name="line518"></a> 518     #
</span><span class="inferred0"><a name="line519"></a> 519     #   Address.find(:all, :include =&gt; :addressable)
</span><span class="inferred1"><a name="line520"></a> 520     #
</span><span class="inferred0"><a name="line521"></a> 521     # will execute one query to load the addresses and load the addressables with one query per addressable type. 
</span><span class="inferred1"><a name="line522"></a> 522     # For example if all the addressables are either of class Person or Company then a total of 3 queries will be executed. The list of
</span><span class="inferred0"><a name="line523"></a> 523     # addressable types to load is determined on the back of the addresses loaded. This is not supported if Active Record has to fallback
</span><span class="inferred1"><a name="line524"></a> 524     # to the previous implementation of eager loading and will raise ActiveRecord::EagerLoadPolymorphicError. The reason is that the parent 
</span><span class="inferred0"><a name="line525"></a> 525     # model's type is a column value so its corresponding table name cannot be put in the +FROM+/+JOIN+ clauses of that query.
</span><span class="inferred1"><a name="line526"></a> 526     #
</span><span class="inferred0"><a name="line527"></a> 527     # == Table Aliasing
</span><span class="inferred1"><a name="line528"></a> 528     #
</span><span class="inferred0"><a name="line529"></a> 529     # Active Record uses table aliasing in the case that a table is referenced multiple times in a join.  If a table is referenced only once,
</span><span class="inferred1"><a name="line530"></a> 530     # the standard table name is used.  The second time, the table is aliased as &lt;tt&gt;#{reflection_name}_#{parent_table_name}&lt;/tt&gt;.  Indexes are appended
</span><span class="inferred0"><a name="line531"></a> 531     # for any more successive uses of the table name.
</span><span class="inferred1"><a name="line532"></a> 532     #
</span><span class="inferred0"><a name="line533"></a> 533     #   Post.find :all, :joins =&gt; :comments
</span><span class="inferred1"><a name="line534"></a> 534     #   # =&gt; SELECT ... FROM posts INNER JOIN comments ON ...
</span><span class="inferred0"><a name="line535"></a> 535     #   Post.find :all, :joins =&gt; :special_comments # STI
</span><span class="inferred1"><a name="line536"></a> 536     #   # =&gt; SELECT ... FROM posts INNER JOIN comments ON ... AND comments.type = 'SpecialComment'
</span><span class="inferred0"><a name="line537"></a> 537     #   Post.find :all, :joins =&gt; [:comments, :special_comments] # special_comments is the reflection name, posts is the parent table name
</span><span class="inferred1"><a name="line538"></a> 538     #   # =&gt; SELECT ... FROM posts INNER JOIN comments ON ... INNER JOIN comments special_comments_posts
</span><span class="inferred0"><a name="line539"></a> 539     #
</span><span class="inferred1"><a name="line540"></a> 540     # Acts as tree example:
</span><span class="inferred0"><a name="line541"></a> 541     #
</span><span class="inferred1"><a name="line542"></a> 542     #   TreeMixin.find :all, :joins =&gt; :children
</span><span class="inferred0"><a name="line543"></a> 543     #   # =&gt; SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
</span><span class="inferred1"><a name="line544"></a> 544     #   TreeMixin.find :all, :joins =&gt; {:children =&gt; :parent}
</span><span class="inferred0"><a name="line545"></a> 545     #   # =&gt; SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
</span><span class="inferred1"><a name="line546"></a> 546     #                               INNER JOIN parents_mixins ...
</span><span class="inferred0"><a name="line547"></a> 547     #   TreeMixin.find :all, :joins =&gt; {:children =&gt; {:parent =&gt; :children}}
</span><span class="inferred1"><a name="line548"></a> 548     #   # =&gt; SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
</span><span class="inferred0"><a name="line549"></a> 549     #                               INNER JOIN parents_mixins ...
</span><span class="inferred1"><a name="line550"></a> 550     #                               INNER JOIN mixins childrens_mixins_2
</span><span class="inferred0"><a name="line551"></a> 551     #
</span><span class="inferred1"><a name="line552"></a> 552     # Has and Belongs to Many join tables use the same idea, but add a &lt;tt&gt;_join&lt;/tt&gt; suffix:
</span><span class="inferred0"><a name="line553"></a> 553     #
</span><span class="inferred1"><a name="line554"></a> 554     #   Post.find :all, :joins =&gt; :categories
</span><span class="inferred0"><a name="line555"></a> 555     #   # =&gt; SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
</span><span class="inferred1"><a name="line556"></a> 556     #   Post.find :all, :joins =&gt; {:categories =&gt; :posts}
</span><span class="inferred0"><a name="line557"></a> 557     #   # =&gt; SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
</span><span class="inferred1"><a name="line558"></a> 558     #                              INNER JOIN categories_posts posts_categories_join INNER JOIN posts posts_categories
</span><span class="inferred0"><a name="line559"></a> 559     #   Post.find :all, :joins =&gt; {:categories =&gt; {:posts =&gt; :categories}}
</span><span class="inferred1"><a name="line560"></a> 560     #   # =&gt; SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
</span><span class="inferred0"><a name="line561"></a> 561     #                              INNER JOIN categories_posts posts_categories_join INNER JOIN posts posts_categories
</span><span class="inferred1"><a name="line562"></a> 562     #                              INNER JOIN categories_posts categories_posts_join INNER JOIN categories categories_posts_2
</span><span class="inferred0"><a name="line563"></a> 563     #
</span><span class="inferred1"><a name="line564"></a> 564     # If you wish to specify your own custom joins using a &lt;tt&gt;:joins&lt;/tt&gt; option, those table names will take precedence over the eager associations:
</span><span class="inferred0"><a name="line565"></a> 565     #
</span><span class="inferred1"><a name="line566"></a> 566     #   Post.find :all, :joins =&gt; :comments, :joins =&gt; &quot;inner join comments ...&quot;
</span><span class="inferred0"><a name="line567"></a> 567     #   # =&gt; SELECT ... FROM posts INNER JOIN comments_posts ON ... INNER JOIN comments ...
</span><span class="inferred1"><a name="line568"></a> 568     #   Post.find :all, :joins =&gt; [:comments, :special_comments], :joins =&gt; &quot;inner join comments ...&quot;
</span><span class="inferred0"><a name="line569"></a> 569     #   # =&gt; SELECT ... FROM posts INNER JOIN comments comments_posts ON ...
</span><span class="inferred1"><a name="line570"></a> 570     #                              INNER JOIN comments special_comments_posts ...
</span><span class="inferred0"><a name="line571"></a> 571     #                              INNER JOIN comments ...
</span><span class="inferred1"><a name="line572"></a> 572     #
</span><span class="inferred0"><a name="line573"></a> 573     # Table aliases are automatically truncated according to the maximum length of table identifiers according to the specific database.
</span><span class="inferred1"><a name="line574"></a> 574     #
</span><span class="inferred0"><a name="line575"></a> 575     # == Modules
</span><span class="inferred1"><a name="line576"></a> 576     #
</span><span class="inferred0"><a name="line577"></a> 577     # By default, associations will look for objects within the current module scope. Consider:
</span><span class="inferred1"><a name="line578"></a> 578     #
</span><span class="inferred0"><a name="line579"></a> 579     #   module MyApplication
</span><span class="inferred1"><a name="line580"></a> 580     #     module Business
</span><span class="inferred0"><a name="line581"></a> 581     #       class Firm &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line582"></a> 582     #          has_many :clients
</span><span class="inferred0"><a name="line583"></a> 583     #        end
</span><span class="inferred1"><a name="line584"></a> 584     #
</span><span class="inferred0"><a name="line585"></a> 585     #       class Company &lt; ActiveRecord::Base; end
</span><span class="inferred1"><a name="line586"></a> 586     #     end
</span><span class="inferred0"><a name="line587"></a> 587     #   end
</span><span class="inferred1"><a name="line588"></a> 588     #
</span><span class="inferred0"><a name="line589"></a> 589     # When Firm#clients is called, it will in turn call &lt;tt&gt;MyApplication::Business::Company.find(firm.id)&lt;/tt&gt;. If you want to associate
</span><span class="inferred1"><a name="line590"></a> 590     # with a class in another module scope, this can be done by specifying the complete class name.  Example:
</span><span class="inferred0"><a name="line591"></a> 591     #
</span><span class="inferred1"><a name="line592"></a> 592     #   module MyApplication
</span><span class="inferred0"><a name="line593"></a> 593     #     module Business
</span><span class="inferred1"><a name="line594"></a> 594     #       class Firm &lt; ActiveRecord::Base; end
</span><span class="inferred0"><a name="line595"></a> 595     #     end
</span><span class="inferred1"><a name="line596"></a> 596     #
</span><span class="inferred0"><a name="line597"></a> 597     #     module Billing
</span><span class="inferred1"><a name="line598"></a> 598     #       class Account &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line599"></a> 599     #         belongs_to :firm, :class_name =&gt; &quot;MyApplication::Business::Firm&quot;
</span><span class="inferred1"><a name="line600"></a> 600     #       end
</span><span class="inferred0"><a name="line601"></a> 601     #     end
</span><span class="inferred1"><a name="line602"></a> 602     #   end
</span><span class="inferred0"><a name="line603"></a> 603     #
</span><span class="inferred1"><a name="line604"></a> 604     # == Type safety with &lt;tt&gt;ActiveRecord::AssociationTypeMismatch&lt;/tt&gt;
</span><span class="inferred0"><a name="line605"></a> 605     #
</span><span class="inferred1"><a name="line606"></a> 606     # If you attempt to assign an object to an association that doesn't match the inferred or specified &lt;tt&gt;:class_name&lt;/tt&gt;, you'll
</span><span class="inferred0"><a name="line607"></a> 607     # get an &lt;tt&gt;ActiveRecord::AssociationTypeMismatch&lt;/tt&gt;.
</span><span class="inferred1"><a name="line608"></a> 608     #
</span><span class="inferred0"><a name="line609"></a> 609     # == Options
</span><span class="inferred1"><a name="line610"></a> 610     #
</span><span class="inferred0"><a name="line611"></a> 611     # All of the association macros can be specialized through options. This makes cases more complex than the simple and guessable ones
</span><span class="inferred1"><a name="line612"></a> 612     # possible.
</span><span class="marked0"><a name="line613"></a> 613     module ClassMethods
</span><span class="inferred1"><a name="line614"></a> 614       # Adds the following methods for retrieval and query of collections of associated objects:
</span><span class="inferred0"><a name="line615"></a> 615       # +collection+ is replaced with the symbol passed as the first argument, so
</span><span class="inferred1"><a name="line616"></a> 616       # &lt;tt&gt;has_many :clients&lt;/tt&gt; would add among others &lt;tt&gt;clients.empty?&lt;/tt&gt;.
</span><span class="inferred0"><a name="line617"></a> 617       # * &lt;tt&gt;collection(force_reload = false)&lt;/tt&gt; - Returns an array of all the associated objects.
</span><span class="inferred1"><a name="line618"></a> 618       #   An empty array is returned if none are found.
</span><span class="inferred0"><a name="line619"></a> 619       # * &lt;tt&gt;collection&lt;&lt;(object, ...)&lt;/tt&gt; - Adds one or more objects to the collection by setting their foreign keys to the collection's primary key.
</span><span class="inferred1"><a name="line620"></a> 620       # * &lt;tt&gt;collection.delete(object, ...)&lt;/tt&gt; - Removes one or more objects from the collection by setting their foreign keys to +NULL+.
</span><span class="inferred0"><a name="line621"></a> 621       #   This will also destroy the objects if they're declared as +belongs_to+ and dependent on this model.
</span><span class="inferred1"><a name="line622"></a> 622       # * &lt;tt&gt;collection=objects&lt;/tt&gt; - Replaces the collections content by deleting and adding objects as appropriate.
</span><span class="inferred0"><a name="line623"></a> 623       # * &lt;tt&gt;collection_singular_ids&lt;/tt&gt; - Returns an array of the associated objects' ids
</span><span class="inferred1"><a name="line624"></a> 624       # * &lt;tt&gt;collection_singular_ids=ids&lt;/tt&gt; - Replace the collection with the objects identified by the primary keys in +ids+
</span><span class="inferred0"><a name="line625"></a> 625       # * &lt;tt&gt;collection.clear&lt;/tt&gt; - Removes every object from the collection. This destroys the associated objects if they
</span><span class="inferred1"><a name="line626"></a> 626       #   are associated with &lt;tt&gt;:dependent =&gt; :destroy&lt;/tt&gt;, deletes them directly from the database if &lt;tt&gt;:dependent =&gt; :delete_all&lt;/tt&gt;,
</span><span class="inferred0"><a name="line627"></a> 627       #   otherwise sets their foreign keys to +NULL+.
</span><span class="inferred1"><a name="line628"></a> 628       # * &lt;tt&gt;collection.empty?&lt;/tt&gt; - Returns +true+ if there are no associated objects.
</span><span class="inferred0"><a name="line629"></a> 629       # * &lt;tt&gt;collection.size&lt;/tt&gt; - Returns the number of associated objects.
</span><span class="inferred1"><a name="line630"></a> 630       # * &lt;tt&gt;collection.find&lt;/tt&gt; - Finds an associated object according to the same rules as Base.find.
</span><span class="inferred0"><a name="line631"></a> 631       # * &lt;tt&gt;collection.build(attributes = {}, ...)&lt;/tt&gt; - Returns one or more new objects of the collection type that have been instantiated
</span><span class="inferred1"><a name="line632"></a> 632       #   with +attributes+ and linked to this object through a foreign key, but have not yet been saved. *Note:* This only works if an
</span><span class="inferred0"><a name="line633"></a> 633       #   associated object already exists, not if it's +nil+!
</span><span class="inferred1"><a name="line634"></a> 634       # * &lt;tt&gt;collection.create(attributes = {})&lt;/tt&gt; - Returns a new object of the collection type that has been instantiated
</span><span class="inferred0"><a name="line635"></a> 635       #   with +attributes+, linked to this object through a foreign key, and that has already been saved (if it passed the validation).
</span><span class="inferred1"><a name="line636"></a> 636       #   *Note:* This only works if an associated object already exists, not if it's +nil+!
</span><span class="inferred0"><a name="line637"></a> 637       #
</span><span class="inferred1"><a name="line638"></a> 638       # Example: A Firm class declares &lt;tt&gt;has_many :clients&lt;/tt&gt;, which will add:
</span><span class="inferred0"><a name="line639"></a> 639       # * &lt;tt&gt;Firm#clients&lt;/tt&gt; (similar to &lt;tt&gt;Clients.find :all, :conditions =&gt; &quot;firm_id = #{id}&quot;&lt;/tt&gt;)
</span><span class="inferred1"><a name="line640"></a> 640       # * &lt;tt&gt;Firm#clients&lt;&lt;&lt;/tt&gt;
</span><span class="inferred0"><a name="line641"></a> 641       # * &lt;tt&gt;Firm#clients.delete&lt;/tt&gt;
</span><span class="inferred1"><a name="line642"></a> 642       # * &lt;tt&gt;Firm#clients=&lt;/tt&gt;
</span><span class="inferred0"><a name="line643"></a> 643       # * &lt;tt&gt;Firm#client_ids&lt;/tt&gt;
</span><span class="inferred1"><a name="line644"></a> 644       # * &lt;tt&gt;Firm#client_ids=&lt;/tt&gt;
</span><span class="inferred0"><a name="line645"></a> 645       # * &lt;tt&gt;Firm#clients.clear&lt;/tt&gt;
</span><span class="inferred1"><a name="line646"></a> 646       # * &lt;tt&gt;Firm#clients.empty?&lt;/tt&gt; (similar to &lt;tt&gt;firm.clients.size == 0&lt;/tt&gt;)
</span><span class="inferred0"><a name="line647"></a> 647       # * &lt;tt&gt;Firm#clients.size&lt;/tt&gt; (similar to &lt;tt&gt;Client.count &quot;firm_id = #{id}&quot;&lt;/tt&gt;)
</span><span class="inferred1"><a name="line648"></a> 648       # * &lt;tt&gt;Firm#clients.find&lt;/tt&gt; (similar to &lt;tt&gt;Client.find(id, :conditions =&gt; &quot;firm_id = #{id}&quot;)&lt;/tt&gt;)
</span><span class="inferred0"><a name="line649"></a> 649       # * &lt;tt&gt;Firm#clients.build&lt;/tt&gt; (similar to &lt;tt&gt;Client.new(&quot;firm_id&quot; =&gt; id)&lt;/tt&gt;)
</span><span class="inferred1"><a name="line650"></a> 650       # * &lt;tt&gt;Firm#clients.create&lt;/tt&gt; (similar to &lt;tt&gt;c = Client.new(&quot;firm_id&quot; =&gt; id); c.save; c&lt;/tt&gt;)
</span><span class="inferred0"><a name="line651"></a> 651       # The declaration can also include an options hash to specialize the behavior of the association.
</span><span class="inferred1"><a name="line652"></a> 652       #
</span><span class="inferred0"><a name="line653"></a> 653       # Options are:
</span><span class="inferred1"><a name="line654"></a> 654       # * &lt;tt&gt;:class_name&lt;/tt&gt; - Specify the class name of the association. Use it only if that name can't be inferred
</span><span class="inferred0"><a name="line655"></a> 655       #   from the association name. So &lt;tt&gt;has_many :products&lt;/tt&gt; will by default be linked to the Product class, but
</span><span class="inferred1"><a name="line656"></a> 656       #   if the real class name is SpecialProduct, you'll have to specify it with this option.
</span><span class="inferred0"><a name="line657"></a> 657       # * &lt;tt&gt;:conditions&lt;/tt&gt; - Specify the conditions that the associated objects must meet in order to be included as a +WHERE+
</span><span class="inferred1"><a name="line658"></a> 658       #   SQL fragment, such as &lt;tt&gt;price &gt; 5 AND name LIKE 'B%'&lt;/tt&gt;.  Record creations from the association are scoped if a hash
</span><span class="inferred0"><a name="line659"></a> 659       #   is used.  &lt;tt&gt;has_many :posts, :conditions =&gt; {:published =&gt; true}&lt;/tt&gt; will create published posts with &lt;tt&gt;@blog.posts.create&lt;/tt&gt;
</span><span class="inferred1"><a name="line660"></a> 660       #   or &lt;tt&gt;@blog.posts.build&lt;/tt&gt;.
</span><span class="inferred0"><a name="line661"></a> 661       # * &lt;tt&gt;:order&lt;/tt&gt; - Specify the order in which the associated objects are returned as an &lt;tt&gt;ORDER BY&lt;/tt&gt; SQL fragment,
</span><span class="inferred1"><a name="line662"></a> 662       #   such as &lt;tt&gt;last_name, first_name DESC&lt;/tt&gt;.
</span><span class="inferred0"><a name="line663"></a> 663       # * &lt;tt&gt;:foreign_key&lt;/tt&gt; - Specify the foreign key used for the association. By default this is guessed to be the name
</span><span class="inferred1"><a name="line664"></a> 664       #   of this class in lower-case and &quot;_id&quot; suffixed. So a Person class that makes a +has_many+ association will use &quot;person_id&quot;
</span><span class="inferred0"><a name="line665"></a> 665       #   as the default &lt;tt&gt;:foreign_key&lt;/tt&gt;.
</span><span class="inferred1"><a name="line666"></a> 666       # * &lt;tt&gt;:dependent&lt;/tt&gt; - If set to &lt;tt&gt;:destroy&lt;/tt&gt; all the associated objects are destroyed
</span><span class="inferred0"><a name="line667"></a> 667       #   alongside this object by calling their +destroy+ method.  If set to &lt;tt&gt;:delete_all&lt;/tt&gt; all associated
</span><span class="inferred1"><a name="line668"></a> 668       #   objects are deleted *without* calling their +destroy+ method.  If set to &lt;tt&gt;:nullify&lt;/tt&gt; all associated
</span><span class="inferred0"><a name="line669"></a> 669       #   objects' foreign keys are set to +NULL+ *without* calling their +save+ callbacks. *Warning:* This option is ignored when also using
</span><span class="inferred1"><a name="line670"></a> 670       #   the &lt;tt&gt;:through&lt;/tt&gt; option.
</span><span class="inferred0"><a name="line671"></a> 671       # * &lt;tt&gt;:finder_sql&lt;/tt&gt; - Specify a complete SQL statement to fetch the association. This is a good way to go for complex
</span><span class="inferred1"><a name="line672"></a> 672       #   associations that depend on multiple tables. Note: When this option is used, +find_in_collection+ is _not_ added.
</span><span class="inferred0"><a name="line673"></a> 673       # * &lt;tt&gt;:counter_sql&lt;/tt&gt; - Specify a complete SQL statement to fetch the size of the association. If &lt;tt&gt;:finder_sql&lt;/tt&gt; is
</span><span class="inferred1"><a name="line674"></a> 674       #   specified but not &lt;tt&gt;:counter_sql&lt;/tt&gt;, &lt;tt&gt;:counter_sql&lt;/tt&gt; will be generated by replacing &lt;tt&gt;SELECT ... FROM&lt;/tt&gt; with &lt;tt&gt;SELECT COUNT(*) FROM&lt;/tt&gt;.
</span><span class="inferred0"><a name="line675"></a> 675       # * &lt;tt&gt;:extend&lt;/tt&gt; - Specify a named module for extending the proxy. See &quot;Association extensions&quot;.
</span><span class="inferred1"><a name="line676"></a> 676       # * &lt;tt&gt;:include&lt;/tt&gt; - Specify second-order associations that should be eager loaded when the collection is loaded.
</span><span class="inferred0"><a name="line677"></a> 677       # * &lt;tt&gt;:group&lt;/tt&gt; - An attribute name by which the result should be grouped. Uses the &lt;tt&gt;GROUP BY&lt;/tt&gt; SQL-clause.
</span><span class="inferred1"><a name="line678"></a> 678       # * &lt;tt&gt;:limit&lt;/tt&gt; - An integer determining the limit on the number of rows that should be returned.
</span><span class="inferred0"><a name="line679"></a> 679       # * &lt;tt&gt;:offset&lt;/tt&gt; - An integer determining the offset from where the rows should be fetched. So at 5, it would skip the first 4 rows.
</span><span class="inferred1"><a name="line680"></a> 680       # * &lt;tt&gt;:select&lt;/tt&gt; - By default, this is &lt;tt&gt;*&lt;/tt&gt; as in &lt;tt&gt;SELECT * FROM&lt;/tt&gt;, but can be changed if you, for example, want to do a join
</span><span class="inferred0"><a name="line681"></a> 681       #   but not include the joined columns. Do not forget to include the primary and foreign keys, otherwise it will rise an error.
</span><span class="inferred1"><a name="line682"></a> 682       # * &lt;tt&gt;:as&lt;/tt&gt; - Specifies a polymorphic interface (See &lt;tt&gt;belongs_to&lt;/tt&gt;).
</span><span class="inferred0"><a name="line683"></a> 683       # * &lt;tt&gt;:through&lt;/tt&gt; - Specifies a Join Model through which to perform the query.  Options for &lt;tt&gt;:class_name&lt;/tt&gt; and &lt;tt&gt;:foreign_key&lt;/tt&gt;
</span><span class="inferred1"><a name="line684"></a> 684       #   are ignored, as the association uses the source reflection. You can only use a &lt;tt&gt;:through&lt;/tt&gt; query through a &lt;tt&gt;belongs_to&lt;/tt&gt;
</span><span class="inferred0"><a name="line685"></a> 685       #   or &lt;tt&gt;has_many&lt;/tt&gt; association on the join model.
</span><span class="inferred1"><a name="line686"></a> 686       # * &lt;tt&gt;:source&lt;/tt&gt; - Specifies the source association name used by &lt;tt&gt;has_many :through&lt;/tt&gt; queries.  Only use it if the name cannot be
</span><span class="inferred0"><a name="line687"></a> 687       #   inferred from the association.  &lt;tt&gt;has_many :subscribers, :through =&gt; :subscriptions&lt;/tt&gt; will look for either &lt;tt&gt;:subscribers&lt;/tt&gt; or
</span><span class="inferred1"><a name="line688"></a> 688       #   &lt;tt&gt;:subscriber&lt;/tt&gt; on Subscription, unless a &lt;tt&gt;:source&lt;/tt&gt; is given.
</span><span class="inferred0"><a name="line689"></a> 689       # * &lt;tt&gt;:source_type&lt;/tt&gt; - Specifies type of the source association used by &lt;tt&gt;has_many :through&lt;/tt&gt; queries where the source
</span><span class="inferred1"><a name="line690"></a> 690       #   association is a polymorphic +belongs_to+.
</span><span class="inferred0"><a name="line691"></a> 691       # * &lt;tt&gt;:uniq&lt;/tt&gt; - If true, duplicates will be omitted from the collection. Useful in conjunction with &lt;tt&gt;:through&lt;/tt&gt;.
</span><span class="inferred1"><a name="line692"></a> 692       # * &lt;tt&gt;:readonly&lt;/tt&gt; - If true, all the associated objects are readonly through the association.
</span><span class="inferred0"><a name="line693"></a> 693       # * &lt;tt&gt;:validate&lt;/tt&gt; - If false, don't validate the associated objects when saving the parent object. true by default.
</span><span class="inferred1"><a name="line694"></a> 694       #
</span><span class="inferred0"><a name="line695"></a> 695       # Option examples:
</span><span class="inferred1"><a name="line696"></a> 696       #   has_many :comments, :order =&gt; &quot;posted_on&quot;
</span><span class="inferred0"><a name="line697"></a> 697       #   has_many :comments, :include =&gt; :author
</span><span class="inferred1"><a name="line698"></a> 698       #   has_many :people, :class_name =&gt; &quot;Person&quot;, :conditions =&gt; &quot;deleted = 0&quot;, :order =&gt; &quot;name&quot;
</span><span class="inferred0"><a name="line699"></a> 699       #   has_many :tracks, :order =&gt; &quot;position&quot;, :dependent =&gt; :destroy
</span><span class="inferred1"><a name="line700"></a> 700       #   has_many :comments, :dependent =&gt; :nullify
</span><span class="inferred0"><a name="line701"></a> 701       #   has_many :tags, :as =&gt; :taggable
</span><span class="inferred1"><a name="line702"></a> 702       #   has_many :reports, :readonly =&gt; true
</span><span class="inferred0"><a name="line703"></a> 703       #   has_many :subscribers, :through =&gt; :subscriptions, :source =&gt; :user
</span><span class="inferred1"><a name="line704"></a> 704       #   has_many :subscribers, :class_name =&gt; &quot;Person&quot;, :finder_sql =&gt;
</span><span class="inferred0"><a name="line705"></a> 705       #       'SELECT DISTINCT people.* ' +
</span><span class="inferred1"><a name="line706"></a> 706       #       'FROM people p, post_subscriptions ps ' +
</span><span class="inferred0"><a name="line707"></a> 707       #       'WHERE ps.post_id = #{id} AND ps.person_id = p.id ' +
</span><span class="inferred1"><a name="line708"></a> 708       #       'ORDER BY p.first_name'
</span><span class="marked0"><a name="line709"></a> 709       def has_many(association_id, options = {}, &amp;extension)
</span><span class="marked1"><a name="line710"></a> 710         reflection = create_has_many_reflection(association_id, options, &amp;extension)
</span><span class="inferred0"><a name="line711"></a> 711 
</span><span class="marked1"><a name="line712"></a> 712         configure_dependency_for_has_many(reflection)
</span><span class="inferred0"><a name="line713"></a> 713 
</span><span class="marked1"><a name="line714"></a> 714         add_multiple_associated_validation_callbacks(reflection.name) unless options[:validate] == false
</span><span class="marked0"><a name="line715"></a> 715         add_multiple_associated_save_callbacks(reflection.name)
</span><span class="marked1"><a name="line716"></a> 716         add_association_callbacks(reflection.name, reflection.options)
</span><span class="inferred0"><a name="line717"></a> 717 
</span><span class="marked1"><a name="line718"></a> 718         if options[:through]
</span><span class="marked0"><a name="line719"></a> 719           collection_accessor_methods(reflection, HasManyThroughAssociation)
</span><span class="inferred1"><a name="line720"></a> 720         else
</span><span class="marked0"><a name="line721"></a> 721           collection_accessor_methods(reflection, HasManyAssociation)
</span><span class="inferred1"><a name="line722"></a> 722         end
</span><span class="inferred0"><a name="line723"></a> 723       end
</span><span class="inferred1"><a name="line724"></a> 724 
</span><span class="inferred0"><a name="line725"></a> 725       # Adds the following methods for retrieval and query of a single associated object:
</span><span class="inferred1"><a name="line726"></a> 726       # +association+ is replaced with the symbol passed as the first argument, so
</span><span class="inferred0"><a name="line727"></a> 727       # &lt;tt&gt;has_one :manager&lt;/tt&gt; would add among others &lt;tt&gt;manager.nil?&lt;/tt&gt;.
</span><span class="inferred1"><a name="line728"></a> 728       # * &lt;tt&gt;association(force_reload = false)&lt;/tt&gt; - Returns the associated object. +nil+ is returned if none is found.
</span><span class="inferred0"><a name="line729"></a> 729       # * &lt;tt&gt;association=(associate)&lt;/tt&gt; - Assigns the associate object, extracts the primary key, sets it as the foreign key,
</span><span class="inferred1"><a name="line730"></a> 730       #   and saves the associate object.
</span><span class="inferred0"><a name="line731"></a> 731       # * &lt;tt&gt;association.nil?&lt;/tt&gt; - Returns +true+ if there is no associated object.
</span><span class="inferred1"><a name="line732"></a> 732       # * &lt;tt&gt;build_association(attributes = {})&lt;/tt&gt; - Returns a new object of the associated type that has been instantiated
</span><span class="inferred0"><a name="line733"></a> 733       #   with +attributes+ and linked to this object through a foreign key, but has not yet been saved. Note: This ONLY works if
</span><span class="inferred1"><a name="line734"></a> 734       #   an association already exists. It will NOT work if the association is +nil+.
</span><span class="inferred0"><a name="line735"></a> 735       # * &lt;tt&gt;create_association(attributes = {})&lt;/tt&gt; - Returns a new object of the associated type that has been instantiated
</span><span class="inferred1"><a name="line736"></a> 736       #   with +attributes+, linked to this object through a foreign key, and that has already been saved (if it passed the validation).
</span><span class="inferred0"><a name="line737"></a> 737       #
</span><span class="inferred1"><a name="line738"></a> 738       # Example: An Account class declares &lt;tt&gt;has_one :beneficiary&lt;/tt&gt;, which will add:
</span><span class="inferred0"><a name="line739"></a> 739       # * &lt;tt&gt;Account#beneficiary&lt;/tt&gt; (similar to &lt;tt&gt;Beneficiary.find(:first, :conditions =&gt; &quot;account_id = #{id}&quot;)&lt;/tt&gt;)
</span><span class="inferred1"><a name="line740"></a> 740       # * &lt;tt&gt;Account#beneficiary=(beneficiary)&lt;/tt&gt; (similar to &lt;tt&gt;beneficiary.account_id = account.id; beneficiary.save&lt;/tt&gt;)
</span><span class="inferred0"><a name="line741"></a> 741       # * &lt;tt&gt;Account#beneficiary.nil?&lt;/tt&gt;
</span><span class="inferred1"><a name="line742"></a> 742       # * &lt;tt&gt;Account#build_beneficiary&lt;/tt&gt; (similar to &lt;tt&gt;Beneficiary.new(&quot;account_id&quot; =&gt; id)&lt;/tt&gt;)
</span><span class="inferred0"><a name="line743"></a> 743       # * &lt;tt&gt;Account#create_beneficiary&lt;/tt&gt; (similar to &lt;tt&gt;b = Beneficiary.new(&quot;account_id&quot; =&gt; id); b.save; b&lt;/tt&gt;)
</span><span class="inferred1"><a name="line744"></a> 744       #
</span><span class="inferred0"><a name="line745"></a> 745       # The declaration can also include an options hash to specialize the behavior of the association.
</span><span class="inferred1"><a name="line746"></a> 746       #
</span><span class="inferred0"><a name="line747"></a> 747       # Options are:
</span><span class="inferred1"><a name="line748"></a> 748       # * &lt;tt&gt;:class_name&lt;/tt&gt; - Specify the class name of the association. Use it only if that name can't be inferred
</span><span class="inferred0"><a name="line749"></a> 749       #   from the association name. So &lt;tt&gt;has_one :manager&lt;/tt&gt; will by default be linked to the Manager class, but
</span><span class="inferred1"><a name="line750"></a> 750       #   if the real class name is Person, you'll have to specify it with this option.
</span><span class="inferred0"><a name="line751"></a> 751       # * &lt;tt&gt;:conditions&lt;/tt&gt; - Specify the conditions that the associated object must meet in order to be included as a +WHERE+
</span><span class="inferred1"><a name="line752"></a> 752       #   SQL fragment, such as &lt;tt&gt;rank = 5&lt;/tt&gt;.
</span><span class="inferred0"><a name="line753"></a> 753       # * &lt;tt&gt;:order&lt;/tt&gt; - Specify the order in which the associated objects are returned as an &lt;tt&gt;ORDER BY&lt;/tt&gt; SQL fragment,
</span><span class="inferred1"><a name="line754"></a> 754       #   such as &lt;tt&gt;last_name, first_name DESC&lt;/tt&gt;.
</span><span class="inferred0"><a name="line755"></a> 755       # * &lt;tt&gt;:dependent&lt;/tt&gt; - If set to &lt;tt&gt;:destroy&lt;/tt&gt;, the associated object is destroyed when this object is. If set to
</span><span class="inferred1"><a name="line756"></a> 756       #   &lt;tt&gt;:delete&lt;/tt&gt;, the associated object is deleted *without* calling its destroy method. If set to &lt;tt&gt;:nullify&lt;/tt&gt;, the associated
</span><span class="inferred0"><a name="line757"></a> 757       #   object's foreign key is set to +NULL+. Also, association is assigned.
</span><span class="inferred1"><a name="line758"></a> 758       # * &lt;tt&gt;:foreign_key&lt;/tt&gt; - Specify the foreign key used for the association. By default this is guessed to be the name
</span><span class="inferred0"><a name="line759"></a> 759       #   of this class in lower-case and &quot;_id&quot; suffixed. So a Person class that makes a +has_one+ association will use &quot;person_id&quot;
</span><span class="inferred1"><a name="line760"></a> 760       #   as the default &lt;tt&gt;:foreign_key&lt;/tt&gt;.
</span><span class="inferred0"><a name="line761"></a> 761       # * &lt;tt&gt;:include&lt;/tt&gt; - Specify second-order associations that should be eager loaded when this object is loaded.
</span><span class="inferred1"><a name="line762"></a> 762       # * &lt;tt&gt;:as&lt;/tt&gt; - Specifies a polymorphic interface (See &lt;tt&gt;belongs_to&lt;/tt&gt;).
</span><span class="inferred0"><a name="line763"></a> 763       # * &lt;tt&gt;:select&lt;/tt&gt; - By default, this is &lt;tt&gt;*&lt;/tt&gt; as in &lt;tt&gt;SELECT * FROM&lt;/tt&gt;, but can be changed if, for example, you want to do a join
</span><span class="inferred1"><a name="line764"></a> 764       #   but not include the joined columns. Do not forget to include the primary and foreign keys, otherwise it will raise an error.
</span><span class="inferred0"><a name="line765"></a> 765       # * &lt;tt&gt;:through&lt;/tt&gt;: Specifies a Join Model through which to perform the query.  Options for &lt;tt&gt;:class_name&lt;/tt&gt; and &lt;tt&gt;:foreign_key&lt;/tt&gt;
</span><span class="inferred1"><a name="line766"></a> 766       #   are ignored, as the association uses the source reflection. You can only use a &lt;tt&gt;:through&lt;/tt&gt; query through a 
</span><span class="inferred0"><a name="line767"></a> 767       #   &lt;tt&gt;has_one&lt;/tt&gt; or &lt;tt&gt;belongs_to&lt;/tt&gt; association on the join model.
</span><span class="inferred1"><a name="line768"></a> 768       # * &lt;tt&gt;:source&lt;/tt&gt; - Specifies the source association name used by &lt;tt&gt;has_one :through&lt;/tt&gt; queries.  Only use it if the name cannot be
</span><span class="inferred0"><a name="line769"></a> 769       #   inferred from the association.  &lt;tt&gt;has_one :favorite, :through =&gt; :favorites&lt;/tt&gt; will look for a
</span><span class="inferred1"><a name="line770"></a> 770       #   &lt;tt&gt;:favorite&lt;/tt&gt; on Favorite, unless a &lt;tt&gt;:source&lt;/tt&gt; is given.      
</span><span class="inferred0"><a name="line771"></a> 771       # * &lt;tt&gt;:source_type&lt;/tt&gt; - Specifies type of the source association used by &lt;tt&gt;has_one :through&lt;/tt&gt; queries where the source
</span><span class="inferred1"><a name="line772"></a> 772       #   association is a polymorphic +belongs_to+.      
</span><span class="inferred0"><a name="line773"></a> 773       # * &lt;tt&gt;:readonly&lt;/tt&gt; - If true, the associated object is readonly through the association.
</span><span class="inferred1"><a name="line774"></a> 774       # * &lt;tt&gt;:validate&lt;/tt&gt; - If false, don't validate the associated object when saving the parent object. +false+ by default.
</span><span class="inferred0"><a name="line775"></a> 775       #
</span><span class="inferred1"><a name="line776"></a> 776       # Option examples:
</span><span class="inferred0"><a name="line777"></a> 777       #   has_one :credit_card, :dependent =&gt; :destroy  # destroys the associated credit card
</span><span class="inferred1"><a name="line778"></a> 778       #   has_one :credit_card, :dependent =&gt; :nullify  # updates the associated records foreign key value to NULL rather than destroying it
</span><span class="inferred0"><a name="line779"></a> 779       #   has_one :last_comment, :class_name =&gt; &quot;Comment&quot;, :order =&gt; &quot;posted_on&quot;
</span><span class="inferred1"><a name="line780"></a> 780       #   has_one :project_manager, :class_name =&gt; &quot;Person&quot;, :conditions =&gt; &quot;role = 'project_manager'&quot;
</span><span class="inferred0"><a name="line781"></a> 781       #   has_one :attachment, :as =&gt; :attachable
</span><span class="inferred1"><a name="line782"></a> 782       #   has_one :boss, :readonly =&gt; :true
</span><span class="inferred0"><a name="line783"></a> 783       #   has_one :club, :through =&gt; :membership
</span><span class="inferred1"><a name="line784"></a> 784       #   has_one :primary_address, :through =&gt; :addressables, :conditions =&gt; [&quot;addressable.primary = ?&quot;, true], :source =&gt; :addressable
</span><span class="marked0"><a name="line785"></a> 785       def has_one(association_id, options = {})
</span><span class="uncovered1"><a name="line786"></a> 786         if options[:through]
</span><span class="uncovered0"><a name="line787"></a> 787           reflection = create_has_one_through_reflection(association_id, options)
</span><span class="uncovered1"><a name="line788"></a> 788           association_accessor_methods(reflection, ActiveRecord::Associations::HasOneThroughAssociation)
</span><span class="uncovered0"><a name="line789"></a> 789         else
</span><span class="uncovered1"><a name="line790"></a> 790           reflection = create_has_one_reflection(association_id, options)
</span><span class="uncovered0"><a name="line791"></a> 791 
</span><span class="uncovered1"><a name="line792"></a> 792           ivar = &quot;@#{reflection.name}&quot;
</span><span class="uncovered0"><a name="line793"></a> 793 
</span><span class="uncovered1"><a name="line794"></a> 794           method_name = &quot;has_one_after_save_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered0"><a name="line795"></a> 795           define_method(method_name) do
</span><span class="uncovered1"><a name="line796"></a> 796             association = instance_variable_get(&quot;#{ivar}&quot;) if instance_variable_defined?(&quot;#{ivar}&quot;)
</span><span class="uncovered0"><a name="line797"></a> 797 
</span><span class="uncovered1"><a name="line798"></a> 798             if !association.nil? &amp;&amp; (new_record? || association.new_record? || association[&quot;#{reflection.primary_key_name}&quot;] != id)
</span><span class="uncovered0"><a name="line799"></a> 799               association[&quot;#{reflection.primary_key_name}&quot;] = id
</span><span class="uncovered1"><a name="line800"></a> 800               association.save(true)
</span><span class="uncovered0"><a name="line801"></a> 801             end
</span><span class="uncovered1"><a name="line802"></a> 802           end
</span><span class="uncovered0"><a name="line803"></a> 803           after_save method_name
</span><span class="uncovered1"><a name="line804"></a> 804 
</span><span class="uncovered0"><a name="line805"></a> 805           add_single_associated_validation_callbacks(reflection.name) if options[:validate] == true
</span><span class="uncovered1"><a name="line806"></a> 806           association_accessor_methods(reflection, HasOneAssociation)
</span><span class="uncovered0"><a name="line807"></a> 807           association_constructor_method(:build,  reflection, HasOneAssociation)
</span><span class="uncovered1"><a name="line808"></a> 808           association_constructor_method(:create, reflection, HasOneAssociation)
</span><span class="uncovered0"><a name="line809"></a> 809 
</span><span class="uncovered1"><a name="line810"></a> 810           configure_dependency_for_has_one(reflection)
</span><span class="uncovered0"><a name="line811"></a> 811         end
</span><span class="uncovered1"><a name="line812"></a> 812       end
</span><span class="inferred0"><a name="line813"></a> 813 
</span><span class="inferred1"><a name="line814"></a> 814       # Adds the following methods for retrieval and query for a single associated object for which this object holds an id:
</span><span class="inferred0"><a name="line815"></a> 815       # +association+ is replaced with the symbol passed as the first argument, so
</span><span class="inferred1"><a name="line816"></a> 816       # &lt;tt&gt;belongs_to :author&lt;/tt&gt; would add among others &lt;tt&gt;author.nil?&lt;/tt&gt;.
</span><span class="inferred0"><a name="line817"></a> 817       # * &lt;tt&gt;association(force_reload = false)&lt;/tt&gt; - Returns the associated object. +nil+ is returned if none is found.
</span><span class="inferred1"><a name="line818"></a> 818       # * &lt;tt&gt;association=(associate)&lt;/tt&gt; - Assigns the associate object, extracts the primary key, and sets it as the foreign key.
</span><span class="inferred0"><a name="line819"></a> 819       # * &lt;tt&gt;association.nil?&lt;/tt&gt; - Returns +true+ if there is no associated object.
</span><span class="inferred1"><a name="line820"></a> 820       # * &lt;tt&gt;build_association(attributes = {})&lt;/tt&gt; - Returns a new object of the associated type that has been instantiated
</span><span class="inferred0"><a name="line821"></a> 821       #   with +attributes+ and linked to this object through a foreign key, but has not yet been saved.
</span><span class="inferred1"><a name="line822"></a> 822       # * &lt;tt&gt;create_association(attributes = {})&lt;/tt&gt; - Returns a new object of the associated type that has been instantiated
</span><span class="inferred0"><a name="line823"></a> 823       #   with +attributes+, linked to this object through a foreign key, and that has already been saved (if it passed the validation).
</span><span class="inferred1"><a name="line824"></a> 824       #
</span><span class="inferred0"><a name="line825"></a> 825       # Example: A Post class declares &lt;tt&gt;belongs_to :author&lt;/tt&gt;, which will add:
</span><span class="inferred1"><a name="line826"></a> 826       # * &lt;tt&gt;Post#author&lt;/tt&gt; (similar to &lt;tt&gt;Author.find(author_id)&lt;/tt&gt;)
</span><span class="inferred0"><a name="line827"></a> 827       # * &lt;tt&gt;Post#author=(author)&lt;/tt&gt; (similar to &lt;tt&gt;post.author_id = author.id&lt;/tt&gt;)
</span><span class="inferred1"><a name="line828"></a> 828       # * &lt;tt&gt;Post#author?&lt;/tt&gt; (similar to &lt;tt&gt;post.author == some_author&lt;/tt&gt;)
</span><span class="inferred0"><a name="line829"></a> 829       # * &lt;tt&gt;Post#author.nil?&lt;/tt&gt;
</span><span class="inferred1"><a name="line830"></a> 830       # * &lt;tt&gt;Post#build_author&lt;/tt&gt; (similar to &lt;tt&gt;post.author = Author.new&lt;/tt&gt;)
</span><span class="inferred0"><a name="line831"></a> 831       # * &lt;tt&gt;Post#create_author&lt;/tt&gt; (similar to &lt;tt&gt;post.author = Author.new; post.author.save; post.author&lt;/tt&gt;)
</span><span class="inferred1"><a name="line832"></a> 832       # The declaration can also include an options hash to specialize the behavior of the association.
</span><span class="inferred0"><a name="line833"></a> 833       #
</span><span class="inferred1"><a name="line834"></a> 834       # Options are:
</span><span class="inferred0"><a name="line835"></a> 835       # * &lt;tt&gt;:class_name&lt;/tt&gt; - Specify the class name of the association. Use it only if that name can't be inferred
</span><span class="inferred1"><a name="line836"></a> 836       #   from the association name. So &lt;tt&gt;has_one :author&lt;/tt&gt; will by default be linked to the Author class, but
</span><span class="inferred0"><a name="line837"></a> 837       #   if the real class name is Person, you'll have to specify it with this option.
</span><span class="inferred1"><a name="line838"></a> 838       # * &lt;tt&gt;:conditions&lt;/tt&gt; - Specify the conditions that the associated object must meet in order to be included as a +WHERE+
</span><span class="inferred0"><a name="line839"></a> 839       #   SQL fragment, such as &lt;tt&gt;authorized = 1&lt;/tt&gt;.
</span><span class="inferred1"><a name="line840"></a> 840       # * &lt;tt&gt;:select&lt;/tt&gt; - By default, this is &lt;tt&gt;*&lt;/tt&gt; as in &lt;tt&gt;SELECT * FROM&lt;/tt&gt;, but can be changed if, for example, you want to do a join
</span><span class="inferred0"><a name="line841"></a> 841       #   but not include the joined columns. Do not forget to include the primary and foreign keys, otherwise it will raise an error.
</span><span class="inferred1"><a name="line842"></a> 842       # * &lt;tt&gt;:foreign_key&lt;/tt&gt; - Specify the foreign key used for the association. By default this is guessed to be the name
</span><span class="inferred0"><a name="line843"></a> 843       #   of the association with an &quot;_id&quot; suffix. So a class that defines a &lt;tt&gt;belongs_to :person&lt;/tt&gt; association will use
</span><span class="inferred1"><a name="line844"></a> 844       #   &quot;person_id&quot; as the default &lt;tt&gt;:foreign_key&lt;/tt&gt;. Similarly, &lt;tt&gt;belongs_to :favorite_person, :class_name =&gt; &quot;Person&quot;&lt;/tt&gt;
</span><span class="inferred0"><a name="line845"></a> 845       #   will use a foreign key of &quot;favorite_person_id&quot;.
</span><span class="inferred1"><a name="line846"></a> 846       # * &lt;tt&gt;:dependent&lt;/tt&gt; - If set to &lt;tt&gt;:destroy&lt;/tt&gt;, the associated object is destroyed when this object is. If set to
</span><span class="inferred0"><a name="line847"></a> 847       #   &lt;tt&gt;:delete&lt;/tt&gt;, the associated object is deleted *without* calling its destroy method. This option should not be specified when
</span><span class="inferred1"><a name="line848"></a> 848       #   &lt;tt&gt;belongs_to&lt;/tt&gt; is used in conjunction with a &lt;tt&gt;has_many&lt;/tt&gt; relationship on another class because of the potential to leave
</span><span class="inferred0"><a name="line849"></a> 849       #   orphaned records behind.
</span><span class="inferred1"><a name="line850"></a> 850       # * &lt;tt&gt;:counter_cache&lt;/tt&gt; - Caches the number of belonging objects on the associate class through the use of +increment_counter+
</span><span class="inferred0"><a name="line851"></a> 851       #   and +decrement_counter+. The counter cache is incremented when an object of this class is created and decremented when it's
</span><span class="inferred1"><a name="line852"></a> 852       #   destroyed. This requires that a column named &lt;tt&gt;#{table_name}_count&lt;/tt&gt; (such as +comments_count+ for a belonging Comment class)
</span><span class="inferred0"><a name="line853"></a> 853       #   is used on the associate class (such as a Post class). You can also specify a custom counter cache column by providing
</span><span class="inferred1"><a name="line854"></a> 854       #   a column name instead of a +true+/+false+ value to this option (e.g., &lt;tt&gt;:counter_cache =&gt; :my_custom_counter&lt;/tt&gt;.)
</span><span class="inferred0"><a name="line855"></a> 855       #   When creating a counter cache column, the database statement or migration must specify a default value of &lt;tt&gt;0&lt;/tt&gt;, failing to do 
</span><span class="inferred1"><a name="line856"></a> 856       #   this results in a counter with +NULL+ value, which will never increment.
</span><span class="inferred0"><a name="line857"></a> 857       #   Note: Specifying a counter cache will add it to that model's list of readonly attributes using +attr_readonly+.
</span><span class="inferred1"><a name="line858"></a> 858       # * &lt;tt&gt;:include&lt;/tt&gt; - Specify second-order associations that should be eager loaded when this object is loaded.
</span><span class="inferred0"><a name="line859"></a> 859       # * &lt;tt&gt;:polymorphic&lt;/tt&gt; - Specify this association is a polymorphic association by passing +true+.
</span><span class="inferred1"><a name="line860"></a> 860       #   Note: If you've enabled the counter cache, then you may want to add the counter cache attribute
</span><span class="inferred0"><a name="line861"></a> 861       #   to the +attr_readonly+ list in the associated classes (e.g. &lt;tt&gt;class Post; attr_readonly :comments_count; end&lt;/tt&gt;).
</span><span class="inferred1"><a name="line862"></a> 862       # * &lt;tt&gt;:readonly&lt;/tt&gt; - If true, the associated object is readonly through the association.
</span><span class="inferred0"><a name="line863"></a> 863       # * &lt;tt&gt;:validate&lt;/tt&gt; - If false, don't validate the associated objects when saving the parent object. +false+ by default.
</span><span class="inferred1"><a name="line864"></a> 864       #
</span><span class="inferred0"><a name="line865"></a> 865       # Option examples:
</span><span class="inferred1"><a name="line866"></a> 866       #   belongs_to :firm, :foreign_key =&gt; &quot;client_of&quot;
</span><span class="inferred0"><a name="line867"></a> 867       #   belongs_to :author, :class_name =&gt; &quot;Person&quot;, :foreign_key =&gt; &quot;author_id&quot;
</span><span class="inferred1"><a name="line868"></a> 868       #   belongs_to :valid_coupon, :class_name =&gt; &quot;Coupon&quot;, :foreign_key =&gt; &quot;coupon_id&quot;,
</span><span class="inferred0"><a name="line869"></a> 869       #              :conditions =&gt; 'discounts &gt; #{payments_count}'
</span><span class="inferred1"><a name="line870"></a> 870       #   belongs_to :attachable, :polymorphic =&gt; true
</span><span class="inferred0"><a name="line871"></a> 871       #   belongs_to :project, :readonly =&gt; true
</span><span class="inferred1"><a name="line872"></a> 872       #   belongs_to :post, :counter_cache =&gt; true
</span><span class="marked0"><a name="line873"></a> 873       def belongs_to(association_id, options = {})
</span><span class="marked1"><a name="line874"></a> 874         reflection = create_belongs_to_reflection(association_id, options)
</span><span class="inferred0"><a name="line875"></a> 875 
</span><span class="marked1"><a name="line876"></a> 876         ivar = &quot;@#{reflection.name}&quot;
</span><span class="inferred0"><a name="line877"></a> 877 
</span><span class="marked1"><a name="line878"></a> 878         if reflection.options[:polymorphic]
</span><span class="uncovered0"><a name="line879"></a> 879           association_accessor_methods(reflection, BelongsToPolymorphicAssociation)
</span><span class="uncovered1"><a name="line880"></a> 880 
</span><span class="uncovered0"><a name="line881"></a> 881           method_name = &quot;polymorphic_belongs_to_before_save_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered1"><a name="line882"></a> 882           define_method(method_name) do
</span><span class="uncovered0"><a name="line883"></a> 883             association = instance_variable_get(&quot;#{ivar}&quot;) if instance_variable_defined?(&quot;#{ivar}&quot;)
</span><span class="uncovered1"><a name="line884"></a> 884 
</span><span class="uncovered0"><a name="line885"></a> 885             if association &amp;&amp; association.target
</span><span class="uncovered1"><a name="line886"></a> 886               if association.new_record?
</span><span class="uncovered0"><a name="line887"></a> 887                 association.save(true)
</span><span class="uncovered1"><a name="line888"></a> 888               end
</span><span class="uncovered0"><a name="line889"></a> 889 
</span><span class="uncovered1"><a name="line890"></a> 890               if association.updated?
</span><span class="uncovered0"><a name="line891"></a> 891                 self[&quot;#{reflection.primary_key_name}&quot;] = association.id
</span><span class="uncovered1"><a name="line892"></a> 892                 self[&quot;#{reflection.options[:foreign_type]}&quot;] = association.class.base_class.name.to_s
</span><span class="uncovered0"><a name="line893"></a> 893               end
</span><span class="uncovered1"><a name="line894"></a> 894             end
</span><span class="uncovered0"><a name="line895"></a> 895           end
</span><span class="uncovered1"><a name="line896"></a> 896           before_save method_name
</span><span class="inferred0"><a name="line897"></a> 897         else
</span><span class="marked1"><a name="line898"></a> 898           association_accessor_methods(reflection, BelongsToAssociation)
</span><span class="marked0"><a name="line899"></a> 899           association_constructor_method(:build,  reflection, BelongsToAssociation)
</span><span class="marked1"><a name="line900"></a> 900           association_constructor_method(:create, reflection, BelongsToAssociation)
</span><span class="inferred0"><a name="line901"></a> 901 
</span><span class="marked1"><a name="line902"></a> 902           method_name = &quot;belongs_to_before_save_for_#{reflection.name}&quot;.to_sym
</span><span class="marked0"><a name="line903"></a> 903           define_method(method_name) do
</span><span class="uncovered1"><a name="line904"></a> 904             association = instance_variable_get(&quot;#{ivar}&quot;) if instance_variable_defined?(&quot;#{ivar}&quot;)
</span><span class="uncovered0"><a name="line905"></a> 905 
</span><span class="uncovered1"><a name="line906"></a> 906             if !association.nil?
</span><span class="uncovered0"><a name="line907"></a> 907               if association.new_record?
</span><span class="uncovered1"><a name="line908"></a> 908                 association.save(true)
</span><span class="uncovered0"><a name="line909"></a> 909               end
</span><span class="uncovered1"><a name="line910"></a> 910 
</span><span class="uncovered0"><a name="line911"></a> 911               if association.updated?
</span><span class="uncovered1"><a name="line912"></a> 912                 self[&quot;#{reflection.primary_key_name}&quot;] = association.id
</span><span class="uncovered0"><a name="line913"></a> 913               end
</span><span class="uncovered1"><a name="line914"></a> 914             end
</span><span class="uncovered0"><a name="line915"></a> 915           end
</span><span class="marked1"><a name="line916"></a> 916           before_save method_name
</span><span class="inferred0"><a name="line917"></a> 917         end
</span><span class="inferred1"><a name="line918"></a> 918 
</span><span class="inferred0"><a name="line919"></a> 919         # Create the callbacks to update counter cache
</span><span class="marked1"><a name="line920"></a> 920         if options[:counter_cache]
</span><span class="uncovered0"><a name="line921"></a> 921           cache_column = options[:counter_cache] == true ?
</span><span class="uncovered1"><a name="line922"></a> 922             &quot;#{self.to_s.underscore.pluralize}_count&quot; :
</span><span class="uncovered0"><a name="line923"></a> 923             options[:counter_cache]
</span><span class="uncovered1"><a name="line924"></a> 924 
</span><span class="uncovered0"><a name="line925"></a> 925           method_name = &quot;belongs_to_counter_cache_after_create_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered1"><a name="line926"></a> 926           define_method(method_name) do
</span><span class="uncovered0"><a name="line927"></a> 927             association = send(&quot;#{reflection.name}&quot;)
</span><span class="uncovered1"><a name="line928"></a> 928             association.class.increment_counter(&quot;#{cache_column}&quot;, send(&quot;#{reflection.primary_key_name}&quot;)) unless association.nil?
</span><span class="uncovered0"><a name="line929"></a> 929           end
</span><span class="uncovered1"><a name="line930"></a> 930           after_create method_name
</span><span class="uncovered0"><a name="line931"></a> 931 
</span><span class="uncovered1"><a name="line932"></a> 932           method_name = &quot;belongs_to_counter_cache_before_destroy_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered0"><a name="line933"></a> 933           define_method(method_name) do
</span><span class="uncovered1"><a name="line934"></a> 934             association = send(&quot;#{reflection.name}&quot;)
</span><span class="uncovered0"><a name="line935"></a> 935             association.class.decrement_counter(&quot;#{cache_column}&quot;, send(&quot;#{reflection.primary_key_name}&quot;)) unless association.nil?
</span><span class="uncovered1"><a name="line936"></a> 936           end
</span><span class="uncovered0"><a name="line937"></a> 937           before_destroy method_name
</span><span class="uncovered1"><a name="line938"></a> 938 
</span><span class="uncovered0"><a name="line939"></a> 939           module_eval(
</span><span class="uncovered1"><a name="line940"></a> 940             &quot;#{reflection.class_name}.send(:attr_readonly,\&quot;#{cache_column}\&quot;.intern) if defined?(#{reflection.class_name}) &amp;&amp; #{reflection.class_name}.respond_to?(:attr_readonly)&quot;
</span><span class="uncovered0"><a name="line941"></a> 941           )
</span><span class="uncovered1"><a name="line942"></a> 942         end
</span><span class="inferred0"><a name="line943"></a> 943 
</span><span class="marked1"><a name="line944"></a> 944         add_single_associated_validation_callbacks(reflection.name) if options[:validate] == true
</span><span class="inferred0"><a name="line945"></a> 945 
</span><span class="marked1"><a name="line946"></a> 946         configure_dependency_for_belongs_to(reflection)
</span><span class="inferred0"><a name="line947"></a> 947       end
</span><span class="inferred1"><a name="line948"></a> 948 
</span><span class="inferred0"><a name="line949"></a> 949       # Associates two classes via an intermediate join table.  Unless the join table is explicitly specified as
</span><span class="inferred1"><a name="line950"></a> 950       # an option, it is guessed using the lexical order of the class names. So a join between Developer and Project
</span><span class="inferred0"><a name="line951"></a> 951       # will give the default join table name of &quot;developers_projects&quot; because &quot;D&quot; outranks &quot;P&quot;.  Note that this precedence
</span><span class="inferred1"><a name="line952"></a> 952       # is calculated using the &lt;tt&gt;&lt;&lt;/tt&gt; operator for String.  This means that if the strings are of different lengths,
</span><span class="inferred0"><a name="line953"></a> 953       # and the strings are equal when compared up to the shortest length, then the longer string is considered of higher
</span><span class="inferred1"><a name="line954"></a> 954       # lexical precedence than the shorter one.  For example, one would expect the tables &quot;paper_boxes&quot; and &quot;papers&quot;
</span><span class="inferred0"><a name="line955"></a> 955       # to generate a join table name of &quot;papers_paper_boxes&quot; because of the length of the name &quot;paper_boxes&quot;,
</span><span class="inferred1"><a name="line956"></a> 956       # but it in fact generates a join table name of &quot;paper_boxes_papers&quot;.  Be aware of this caveat, and use the
</span><span class="inferred0"><a name="line957"></a> 957       # custom &lt;tt&gt;:join_table&lt;/tt&gt; option if you need to.
</span><span class="inferred1"><a name="line958"></a> 958       #
</span><span class="inferred0"><a name="line959"></a> 959       # Deprecated: Any additional fields added to the join table will be placed as attributes when pulling records out through
</span><span class="inferred1"><a name="line960"></a> 960       # +has_and_belongs_to_many+ associations. Records returned from join tables with additional attributes will be marked as
</span><span class="inferred0"><a name="line961"></a> 961       # readonly (because we can't save changes to the additional attributes). It's strongly recommended that you upgrade any
</span><span class="inferred1"><a name="line962"></a> 962       # associations with attributes to a real join model (see introduction).
</span><span class="inferred0"><a name="line963"></a> 963       #
</span><span class="inferred1"><a name="line964"></a> 964       # Adds the following methods for retrieval and query:
</span><span class="inferred0"><a name="line965"></a> 965       # +collection+ is replaced with the symbol passed as the first argument, so
</span><span class="inferred1"><a name="line966"></a> 966       # &lt;tt&gt;has_and_belongs_to_many :categories&lt;/tt&gt; would add among others &lt;tt&gt;categories.empty?&lt;/tt&gt;.
</span><span class="inferred0"><a name="line967"></a> 967       # * &lt;tt&gt;collection(force_reload = false)&lt;/tt&gt; - Returns an array of all the associated objects.
</span><span class="inferred1"><a name="line968"></a> 968       #   An empty array is returned if none are found.
</span><span class="inferred0"><a name="line969"></a> 969       # * &lt;tt&gt;collection&lt;&lt;(object, ...)&lt;/tt&gt; - Adds one or more objects to the collection by creating associations in the join table
</span><span class="inferred1"><a name="line970"></a> 970       #   (&lt;tt&gt;collection.push&lt;/tt&gt; and &lt;tt&gt;collection.concat&lt;/tt&gt; are aliases to this method).
</span><span class="inferred0"><a name="line971"></a> 971       # * &lt;tt&gt;collection.delete(object, ...)&lt;/tt&gt; - Removes one or more objects from the collection by removing their associations from the join table.
</span><span class="inferred1"><a name="line972"></a> 972       #   This does not destroy the objects.
</span><span class="inferred0"><a name="line973"></a> 973       # * &lt;tt&gt;collection=objects&lt;/tt&gt; - Replaces the collection's content by deleting and adding objects as appropriate.
</span><span class="inferred1"><a name="line974"></a> 974       # * &lt;tt&gt;collection_singular_ids&lt;/tt&gt; - Returns an array of the associated objects' ids.
</span><span class="inferred0"><a name="line975"></a> 975       # * &lt;tt&gt;collection_singular_ids=ids&lt;/tt&gt; - Replace the collection by the objects identified by the primary keys in +ids+.
</span><span class="inferred1"><a name="line976"></a> 976       # * &lt;tt&gt;collection.clear&lt;/tt&gt; - Removes every object from the collection. This does not destroy the objects.
</span><span class="inferred0"><a name="line977"></a> 977       # * &lt;tt&gt;collection.empty?&lt;/tt&gt; - Returns +true+ if there are no associated objects.
</span><span class="inferred1"><a name="line978"></a> 978       # * &lt;tt&gt;collection.size&lt;/tt&gt; - Returns the number of associated objects.
</span><span class="inferred0"><a name="line979"></a> 979       # * &lt;tt&gt;collection.find(id)&lt;/tt&gt; - Finds an associated object responding to the +id+ and that
</span><span class="inferred1"><a name="line980"></a> 980       #   meets the condition that it has to be associated with this object.
</span><span class="inferred0"><a name="line981"></a> 981       # * &lt;tt&gt;collection.build(attributes = {})&lt;/tt&gt; - Returns a new object of the collection type that has been instantiated
</span><span class="inferred1"><a name="line982"></a> 982       #   with +attributes+ and linked to this object through the join table, but has not yet been saved.
</span><span class="inferred0"><a name="line983"></a> 983       # * &lt;tt&gt;collection.create(attributes = {})&lt;/tt&gt; - Returns a new object of the collection type that has been instantiated
</span><span class="inferred1"><a name="line984"></a> 984       #   with +attributes+, linked to this object through the join table, and that has already been saved (if it passed the validation).
</span><span class="inferred0"><a name="line985"></a> 985       #
</span><span class="inferred1"><a name="line986"></a> 986       # Example: A Developer class declares &lt;tt&gt;has_and_belongs_to_many :projects&lt;/tt&gt;, which will add:
</span><span class="inferred0"><a name="line987"></a> 987       # * &lt;tt&gt;Developer#projects&lt;/tt&gt;
</span><span class="inferred1"><a name="line988"></a> 988       # * &lt;tt&gt;Developer#projects&lt;&lt;&lt;/tt&gt;
</span><span class="inferred0"><a name="line989"></a> 989       # * &lt;tt&gt;Developer#projects.delete&lt;/tt&gt;
</span><span class="inferred1"><a name="line990"></a> 990       # * &lt;tt&gt;Developer#projects=&lt;/tt&gt;
</span><span class="inferred0"><a name="line991"></a> 991       # * &lt;tt&gt;Developer#project_ids&lt;/tt&gt;
</span><span class="inferred1"><a name="line992"></a> 992       # * &lt;tt&gt;Developer#project_ids=&lt;/tt&gt;
</span><span class="inferred0"><a name="line993"></a> 993       # * &lt;tt&gt;Developer#projects.clear&lt;/tt&gt;
</span><span class="inferred1"><a name="line994"></a> 994       # * &lt;tt&gt;Developer#projects.empty?&lt;/tt&gt;
</span><span class="inferred0"><a name="line995"></a> 995       # * &lt;tt&gt;Developer#projects.size&lt;/tt&gt;
</span><span class="inferred1"><a name="line996"></a> 996       # * &lt;tt&gt;Developer#projects.find(id)&lt;/tt&gt;
</span><span class="inferred0"><a name="line997"></a> 997       # * &lt;tt&gt;Developer#projects.build&lt;/tt&gt; (similar to &lt;tt&gt;Project.new(&quot;project_id&quot; =&gt; id)&lt;/tt&gt;)
</span><span class="inferred1"><a name="line998"></a> 998       # * &lt;tt&gt;Developer#projects.create&lt;/tt&gt; (similar to &lt;tt&gt;c = Project.new(&quot;project_id&quot; =&gt; id); c.save; c&lt;/tt&gt;)
</span><span class="inferred0"><a name="line999"></a> 999       # The declaration may include an options hash to specialize the behavior of the association.
</span><span class="inferred1"><a name="line1000"></a>1000       #
</span><span class="inferred0"><a name="line1001"></a>1001       # Options are:
</span><span class="inferred1"><a name="line1002"></a>1002       # * &lt;tt&gt;:class_name&lt;/tt&gt; - Specify the class name of the association. Use it only if that name can't be inferred
</span><span class="inferred0"><a name="line1003"></a>1003       #   from the association name. So &lt;tt&gt;has_and_belongs_to_many :projects&lt;/tt&gt; will by default be linked to the
</span><span class="inferred1"><a name="line1004"></a>1004       #   Project class, but if the real class name is SuperProject, you'll have to specify it with this option.
</span><span class="inferred0"><a name="line1005"></a>1005       # * &lt;tt&gt;:join_table&lt;/tt&gt; - Specify the name of the join table if the default based on lexical order isn't what you want.
</span><span class="inferred1"><a name="line1006"></a>1006       #   WARNING: If you're overwriting the table name of either class, the +table_name+ method MUST be declared underneath any
</span><span class="inferred0"><a name="line1007"></a>1007       #   +has_and_belongs_to_many+ declaration in order to work.
</span><span class="inferred1"><a name="line1008"></a>1008       # * &lt;tt&gt;:foreign_key&lt;/tt&gt; - Specify the foreign key used for the association. By default this is guessed to be the name
</span><span class="inferred0"><a name="line1009"></a>1009       #   of this class in lower-case and &quot;_id&quot; suffixed. So a Person class that makes a +has_and_belongs_to_many+ association
</span><span class="inferred1"><a name="line1010"></a>1010       #   will use &quot;person_id&quot; as the default &lt;tt&gt;:foreign_key&lt;/tt&gt;.
</span><span class="inferred0"><a name="line1011"></a>1011       # * &lt;tt&gt;:association_foreign_key&lt;/tt&gt; - Specify the association foreign key used for the association. By default this is
</span><span class="inferred1"><a name="line1012"></a>1012       #   guessed to be the name of the associated class in lower-case and &quot;_id&quot; suffixed. So if the associated class is Project,
</span><span class="inferred0"><a name="line1013"></a>1013       #   the +has_and_belongs_to_many+ association will use &quot;project_id&quot; as the default &lt;tt&gt;:association_foreign_key&lt;/tt&gt;.
</span><span class="inferred1"><a name="line1014"></a>1014       # * &lt;tt&gt;:conditions&lt;/tt&gt; - Specify the conditions that the associated object must meet in order to be included as a +WHERE+
</span><span class="inferred0"><a name="line1015"></a>1015       #   SQL fragment, such as &lt;tt&gt;authorized = 1&lt;/tt&gt;.  Record creations from the association are scoped if a hash is used.  
</span><span class="inferred1"><a name="line1016"></a>1016       #   &lt;tt&gt;has_many :posts, :conditions =&gt; {:published =&gt; true}&lt;/tt&gt; will create published posts with &lt;tt&gt;@blog.posts.create&lt;/tt&gt; 
</span><span class="inferred0"><a name="line1017"></a>1017       #   or &lt;tt&gt;@blog.posts.build&lt;/tt&gt;.
</span><span class="inferred1"><a name="line1018"></a>1018       # * &lt;tt&gt;:order&lt;/tt&gt; - Specify the order in which the associated objects are returned as an &lt;tt&gt;ORDER BY&lt;/tt&gt; SQL fragment,
</span><span class="inferred0"><a name="line1019"></a>1019       #   such as &lt;tt&gt;last_name, first_name DESC&lt;/tt&gt;
</span><span class="inferred1"><a name="line1020"></a>1020       # * &lt;tt&gt;:uniq&lt;/tt&gt; - If true, duplicate associated objects will be ignored by accessors and query methods.
</span><span class="inferred0"><a name="line1021"></a>1021       # * &lt;tt&gt;:finder_sql&lt;/tt&gt; - Overwrite the default generated SQL statement used to fetch the association with a manual statement
</span><span class="inferred1"><a name="line1022"></a>1022       # * &lt;tt&gt;:delete_sql&lt;/tt&gt; - Overwrite the default generated SQL statement used to remove links between the associated
</span><span class="inferred0"><a name="line1023"></a>1023       #   classes with a manual statement.
</span><span class="inferred1"><a name="line1024"></a>1024       # * &lt;tt&gt;:insert_sql&lt;/tt&gt; - Overwrite the default generated SQL statement used to add links between the associated classes
</span><span class="inferred0"><a name="line1025"></a>1025       #   with a manual statement.
</span><span class="inferred1"><a name="line1026"></a>1026       # * &lt;tt&gt;:extend&lt;/tt&gt; - Anonymous module for extending the proxy, see &quot;Association extensions&quot;.
</span><span class="inferred0"><a name="line1027"></a>1027       # * &lt;tt&gt;:include&lt;/tt&gt; - Specify second-order associations that should be eager loaded when the collection is loaded.
</span><span class="inferred1"><a name="line1028"></a>1028       # * &lt;tt&gt;:group&lt;/tt&gt; - An attribute name by which the result should be grouped. Uses the &lt;tt&gt;GROUP BY&lt;/tt&gt; SQL-clause.
</span><span class="inferred0"><a name="line1029"></a>1029       # * &lt;tt&gt;:limit&lt;/tt&gt; - An integer determining the limit on the number of rows that should be returned.
</span><span class="inferred1"><a name="line1030"></a>1030       # * &lt;tt&gt;:offset&lt;/tt&gt; - An integer determining the offset from where the rows should be fetched. So at 5, it would skip the first 4 rows.
</span><span class="inferred0"><a name="line1031"></a>1031       # * &lt;tt&gt;:select&lt;/tt&gt; - By default, this is &lt;tt&gt;*&lt;/tt&gt; as in &lt;tt&gt;SELECT * FROM&lt;/tt&gt;, but can be changed if, for example, you want to do a join
</span><span class="inferred1"><a name="line1032"></a>1032       #   but not include the joined columns. Do not forget to include the primary and foreign keys, otherwise it will raise an error.
</span><span class="inferred0"><a name="line1033"></a>1033       # * &lt;tt&gt;:readonly&lt;/tt&gt; - If true, all the associated objects are readonly through the association.
</span><span class="inferred1"><a name="line1034"></a>1034       # * &lt;tt&gt;:validate&lt;/tt&gt; - If false, don't validate the associated objects when saving the parent object. +true+ by default.
</span><span class="inferred0"><a name="line1035"></a>1035       #
</span><span class="inferred1"><a name="line1036"></a>1036       # Option examples:
</span><span class="inferred0"><a name="line1037"></a>1037       #   has_and_belongs_to_many :projects
</span><span class="inferred1"><a name="line1038"></a>1038       #   has_and_belongs_to_many :projects, :include =&gt; [ :milestones, :manager ]
</span><span class="inferred0"><a name="line1039"></a>1039       #   has_and_belongs_to_many :nations, :class_name =&gt; &quot;Country&quot;
</span><span class="inferred1"><a name="line1040"></a>1040       #   has_and_belongs_to_many :categories, :join_table =&gt; &quot;prods_cats&quot;
</span><span class="inferred0"><a name="line1041"></a>1041       #   has_and_belongs_to_many :categories, :readonly =&gt; true
</span><span class="inferred1"><a name="line1042"></a>1042       #   has_and_belongs_to_many :active_projects, :join_table =&gt; 'developers_projects', :delete_sql =&gt;
</span><span class="inferred0"><a name="line1043"></a>1043       #   'DELETE FROM developers_projects WHERE active=1 AND developer_id = #{id} AND project_id = #{record.id}'
</span><span class="marked1"><a name="line1044"></a>1044       def has_and_belongs_to_many(association_id, options = {}, &amp;extension)
</span><span class="uncovered0"><a name="line1045"></a>1045         reflection = create_has_and_belongs_to_many_reflection(association_id, options, &amp;extension)
</span><span class="uncovered1"><a name="line1046"></a>1046 
</span><span class="uncovered0"><a name="line1047"></a>1047         add_multiple_associated_validation_callbacks(reflection.name) unless options[:validate] == false
</span><span class="uncovered1"><a name="line1048"></a>1048         add_multiple_associated_save_callbacks(reflection.name)
</span><span class="uncovered0"><a name="line1049"></a>1049         collection_accessor_methods(reflection, HasAndBelongsToManyAssociation)
</span><span class="uncovered1"><a name="line1050"></a>1050 
</span><span class="uncovered0"><a name="line1051"></a>1051         # Don't use a before_destroy callback since users' before_destroy
</span><span class="uncovered1"><a name="line1052"></a>1052         # callbacks will be executed after the association is wiped out.
</span><span class="uncovered0"><a name="line1053"></a>1053         old_method = &quot;destroy_without_habtm_shim_for_#{reflection.name}&quot;
</span><span class="uncovered1"><a name="line1054"></a>1054         class_eval &lt;&lt;-end_eval unless method_defined?(old_method)
</span><span class="uncovered0"><a name="line1055"></a>1055           alias_method :#{old_method}, :destroy_without_callbacks
</span><span class="uncovered1"><a name="line1056"></a>1056           def destroy_without_callbacks
</span><span class="uncovered0"><a name="line1057"></a>1057             #{reflection.name}.clear
</span><span class="uncovered1"><a name="line1058"></a>1058             #{old_method}
</span><span class="uncovered0"><a name="line1059"></a>1059           end
</span><span class="uncovered1"><a name="line1060"></a>1060         end_eval
</span><span class="uncovered0"><a name="line1061"></a>1061 
</span><span class="uncovered1"><a name="line1062"></a>1062         add_association_callbacks(reflection.name, options)
</span><span class="uncovered0"><a name="line1063"></a>1063       end
</span><span class="inferred1"><a name="line1064"></a>1064 
</span><span class="marked0"><a name="line1065"></a>1065       private
</span><span class="inferred1"><a name="line1066"></a>1066         # Generate a join table name from two provided tables names.
</span><span class="inferred0"><a name="line1067"></a>1067         # The order of names in join name is determined by lexical precedence.
</span><span class="inferred1"><a name="line1068"></a>1068         #   join_table_name(&quot;members&quot;, &quot;clubs&quot;)
</span><span class="inferred0"><a name="line1069"></a>1069         #   =&gt; &quot;clubs_members&quot;
</span><span class="inferred1"><a name="line1070"></a>1070         #   join_table_name(&quot;members&quot;, &quot;special_clubs&quot;)
</span><span class="inferred0"><a name="line1071"></a>1071         #   =&gt; &quot;members_special_clubs&quot;
</span><span class="marked1"><a name="line1072"></a>1072         def join_table_name(first_table_name, second_table_name)
</span><span class="uncovered0"><a name="line1073"></a>1073           if first_table_name &lt; second_table_name
</span><span class="uncovered1"><a name="line1074"></a>1074             join_table = &quot;#{first_table_name}_#{second_table_name}&quot;
</span><span class="uncovered0"><a name="line1075"></a>1075           else
</span><span class="uncovered1"><a name="line1076"></a>1076             join_table = &quot;#{second_table_name}_#{first_table_name}&quot;
</span><span class="uncovered0"><a name="line1077"></a>1077           end
</span><span class="uncovered1"><a name="line1078"></a>1078 
</span><span class="uncovered0"><a name="line1079"></a>1079           table_name_prefix + join_table + table_name_suffix
</span><span class="uncovered1"><a name="line1080"></a>1080         end
</span><span class="inferred0"><a name="line1081"></a>1081 
</span><span class="marked1"><a name="line1082"></a>1082         def association_accessor_methods(reflection, association_proxy_class)
</span><span class="marked0"><a name="line1083"></a>1083           ivar = &quot;@#{reflection.name}&quot;
</span><span class="inferred1"><a name="line1084"></a>1084 
</span><span class="marked0"><a name="line1085"></a>1085           define_method(reflection.name) do |*params|
</span><span class="uncovered1"><a name="line1086"></a>1086             force_reload = params.first unless params.empty?
</span><span class="uncovered0"><a name="line1087"></a>1087 
</span><span class="uncovered1"><a name="line1088"></a>1088             association = instance_variable_get(ivar) if instance_variable_defined?(ivar)
</span><span class="uncovered0"><a name="line1089"></a>1089 
</span><span class="uncovered1"><a name="line1090"></a>1090             if association.nil? || force_reload
</span><span class="uncovered0"><a name="line1091"></a>1091               association = association_proxy_class.new(self, reflection)
</span><span class="uncovered1"><a name="line1092"></a>1092               retval = association.reload
</span><span class="uncovered0"><a name="line1093"></a>1093               if retval.nil? and association_proxy_class == BelongsToAssociation
</span><span class="uncovered1"><a name="line1094"></a>1094                 instance_variable_set(ivar, nil)
</span><span class="uncovered0"><a name="line1095"></a>1095                 return nil
</span><span class="uncovered1"><a name="line1096"></a>1096               end
</span><span class="uncovered0"><a name="line1097"></a>1097               instance_variable_set(ivar, association)
</span><span class="uncovered1"><a name="line1098"></a>1098             end
</span><span class="uncovered0"><a name="line1099"></a>1099 
</span><span class="uncovered1"><a name="line1100"></a>1100             association.target.nil? ? nil : association
</span><span class="uncovered0"><a name="line1101"></a>1101           end
</span><span class="inferred1"><a name="line1102"></a>1102 
</span><span class="marked0"><a name="line1103"></a>1103           define_method(&quot;#{reflection.name}=&quot;) do |new_value|
</span><span class="uncovered1"><a name="line1104"></a>1104             association = instance_variable_get(ivar) if instance_variable_defined?(ivar)
</span><span class="uncovered0"><a name="line1105"></a>1105 
</span><span class="uncovered1"><a name="line1106"></a>1106             if association.nil? || association.target != new_value
</span><span class="uncovered0"><a name="line1107"></a>1107               association = association_proxy_class.new(self, reflection)
</span><span class="uncovered1"><a name="line1108"></a>1108             end
</span><span class="uncovered0"><a name="line1109"></a>1109 
</span><span class="uncovered1"><a name="line1110"></a>1110             if association_proxy_class == HasOneThroughAssociation
</span><span class="uncovered0"><a name="line1111"></a>1111               association.create_through_record(new_value)
</span><span class="uncovered1"><a name="line1112"></a>1112               self.send(reflection.name, new_value)
</span><span class="uncovered0"><a name="line1113"></a>1113             else
</span><span class="uncovered1"><a name="line1114"></a>1114               association.replace(new_value)
</span><span class="uncovered0"><a name="line1115"></a>1115               instance_variable_set(ivar, new_value.nil? ? nil : association)
</span><span class="uncovered1"><a name="line1116"></a>1116             end
</span><span class="uncovered0"><a name="line1117"></a>1117           end
</span><span class="inferred1"><a name="line1118"></a>1118 
</span><span class="marked0"><a name="line1119"></a>1119           define_method(&quot;set_#{reflection.name}_target&quot;) do |target|
</span><span class="uncovered1"><a name="line1120"></a>1120             return if target.nil? and association_proxy_class == BelongsToAssociation
</span><span class="uncovered0"><a name="line1121"></a>1121             association = association_proxy_class.new(self, reflection)
</span><span class="uncovered1"><a name="line1122"></a>1122             association.target = target
</span><span class="uncovered0"><a name="line1123"></a>1123             instance_variable_set(ivar, association)
</span><span class="uncovered1"><a name="line1124"></a>1124           end
</span><span class="uncovered0"><a name="line1125"></a>1125         end
</span><span class="inferred1"><a name="line1126"></a>1126 
</span><span class="marked0"><a name="line1127"></a>1127         def collection_reader_method(reflection, association_proxy_class)
</span><span class="marked1"><a name="line1128"></a>1128           define_method(reflection.name) do |*params|
</span><span class="uncovered0"><a name="line1129"></a>1129             ivar = &quot;@#{reflection.name}&quot;
</span><span class="uncovered1"><a name="line1130"></a>1130 
</span><span class="uncovered0"><a name="line1131"></a>1131             force_reload = params.first unless params.empty?
</span><span class="uncovered1"><a name="line1132"></a>1132             association = instance_variable_get(ivar) if instance_variable_defined?(ivar)
</span><span class="uncovered0"><a name="line1133"></a>1133 
</span><span class="uncovered1"><a name="line1134"></a>1134             unless association.respond_to?(:loaded?)
</span><span class="uncovered0"><a name="line1135"></a>1135               association = association_proxy_class.new(self, reflection)
</span><span class="uncovered1"><a name="line1136"></a>1136               instance_variable_set(ivar, association)
</span><span class="uncovered0"><a name="line1137"></a>1137             end
</span><span class="uncovered1"><a name="line1138"></a>1138 
</span><span class="uncovered0"><a name="line1139"></a>1139             association.reload if force_reload
</span><span class="uncovered1"><a name="line1140"></a>1140 
</span><span class="uncovered0"><a name="line1141"></a>1141             association
</span><span class="uncovered1"><a name="line1142"></a>1142           end
</span><span class="inferred0"><a name="line1143"></a>1143 
</span><span class="marked1"><a name="line1144"></a>1144           define_method(&quot;#{reflection.name.to_s.singularize}_ids&quot;) do
</span><span class="uncovered0"><a name="line1145"></a>1145             send(reflection.name).map(&amp;:id)
</span><span class="uncovered1"><a name="line1146"></a>1146           end
</span><span class="uncovered0"><a name="line1147"></a>1147         end
</span><span class="inferred1"><a name="line1148"></a>1148 
</span><span class="marked0"><a name="line1149"></a>1149         def collection_accessor_methods(reflection, association_proxy_class, writer = true)
</span><span class="marked1"><a name="line1150"></a>1150           collection_reader_method(reflection, association_proxy_class)
</span><span class="inferred0"><a name="line1151"></a>1151 
</span><span class="marked1"><a name="line1152"></a>1152           if writer
</span><span class="marked0"><a name="line1153"></a>1153             define_method(&quot;#{reflection.name}=&quot;) do |new_value|
</span><span class="uncovered1"><a name="line1154"></a>1154               # Loads proxy class instance (defined in collection_reader_method) if not already loaded
</span><span class="uncovered0"><a name="line1155"></a>1155               association = send(reflection.name)
</span><span class="uncovered1"><a name="line1156"></a>1156               association.replace(new_value)
</span><span class="uncovered0"><a name="line1157"></a>1157               association
</span><span class="uncovered1"><a name="line1158"></a>1158             end
</span><span class="inferred0"><a name="line1159"></a>1159 
</span><span class="marked1"><a name="line1160"></a>1160             define_method(&quot;#{reflection.name.to_s.singularize}_ids=&quot;) do |new_value|
</span><span class="uncovered0"><a name="line1161"></a>1161               ids = (new_value || []).reject { |nid| nid.blank? }
</span><span class="uncovered1"><a name="line1162"></a>1162               send(&quot;#{reflection.name}=&quot;, reflection.class_name.constantize.find(ids))
</span><span class="uncovered0"><a name="line1163"></a>1163             end
</span><span class="uncovered1"><a name="line1164"></a>1164           end
</span><span class="uncovered0"><a name="line1165"></a>1165         end
</span><span class="inferred1"><a name="line1166"></a>1166         
</span><span class="marked0"><a name="line1167"></a>1167         def add_single_associated_validation_callbacks(association_name)
</span><span class="uncovered1"><a name="line1168"></a>1168           method_name = &quot;validate_associated_records_for_#{association_name}&quot;.to_sym
</span><span class="uncovered0"><a name="line1169"></a>1169           define_method(method_name) do
</span><span class="uncovered1"><a name="line1170"></a>1170             association = instance_variable_get(&quot;@#{association_name}&quot;)
</span><span class="uncovered0"><a name="line1171"></a>1171             if !association.nil?
</span><span class="uncovered1"><a name="line1172"></a>1172               errors.add &quot;#{association_name}&quot; unless association.target.nil? || association.valid?
</span><span class="uncovered0"><a name="line1173"></a>1173             end
</span><span class="uncovered1"><a name="line1174"></a>1174           end
</span><span class="uncovered0"><a name="line1175"></a>1175         
</span><span class="uncovered1"><a name="line1176"></a>1176           validate method_name
</span><span class="uncovered0"><a name="line1177"></a>1177         end
</span><span class="inferred1"><a name="line1178"></a>1178         
</span><span class="marked0"><a name="line1179"></a>1179         def add_multiple_associated_validation_callbacks(association_name)
</span><span class="marked1"><a name="line1180"></a>1180           method_name = &quot;validate_associated_records_for_#{association_name}&quot;.to_sym
</span><span class="marked0"><a name="line1181"></a>1181           ivar = &quot;@#{association_name}&quot;
</span><span class="inferred1"><a name="line1182"></a>1182 
</span><span class="marked0"><a name="line1183"></a>1183           define_method(method_name) do
</span><span class="uncovered1"><a name="line1184"></a>1184             association = instance_variable_get(ivar) if instance_variable_defined?(ivar)
</span><span class="uncovered0"><a name="line1185"></a>1185 
</span><span class="uncovered1"><a name="line1186"></a>1186             if association.respond_to?(:loaded?)
</span><span class="uncovered0"><a name="line1187"></a>1187               if new_record?
</span><span class="uncovered1"><a name="line1188"></a>1188                 association
</span><span class="uncovered0"><a name="line1189"></a>1189               elsif association.loaded?
</span><span class="uncovered1"><a name="line1190"></a>1190                 association.select { |record| record.new_record? }
</span><span class="uncovered0"><a name="line1191"></a>1191               else
</span><span class="uncovered1"><a name="line1192"></a>1192                 association.target.select { |record| record.new_record? }
</span><span class="uncovered0"><a name="line1193"></a>1193               end.each do |record|
</span><span class="uncovered1"><a name="line1194"></a>1194                 errors.add &quot;#{association_name}&quot; unless record.valid?
</span><span class="uncovered0"><a name="line1195"></a>1195               end
</span><span class="uncovered1"><a name="line1196"></a>1196             end
</span><span class="uncovered0"><a name="line1197"></a>1197           end
</span><span class="inferred1"><a name="line1198"></a>1198 
</span><span class="marked0"><a name="line1199"></a>1199           validate method_name
</span><span class="inferred1"><a name="line1200"></a>1200         end
</span><span class="inferred0"><a name="line1201"></a>1201 
</span><span class="marked1"><a name="line1202"></a>1202         def add_multiple_associated_save_callbacks(association_name)
</span><span class="marked0"><a name="line1203"></a>1203           ivar = &quot;@#{association_name}&quot;
</span><span class="inferred1"><a name="line1204"></a>1204 
</span><span class="marked0"><a name="line1205"></a>1205           method_name = &quot;before_save_associated_records_for_#{association_name}&quot;.to_sym
</span><span class="marked1"><a name="line1206"></a>1206           define_method(method_name) do
</span><span class="uncovered0"><a name="line1207"></a>1207             @new_record_before_save = new_record?
</span><span class="uncovered1"><a name="line1208"></a>1208             true
</span><span class="uncovered0"><a name="line1209"></a>1209           end
</span><span class="marked1"><a name="line1210"></a>1210           before_save method_name
</span><span class="inferred0"><a name="line1211"></a>1211 
</span><span class="marked1"><a name="line1212"></a>1212           method_name = &quot;after_create_or_update_associated_records_for_#{association_name}&quot;.to_sym
</span><span class="marked0"><a name="line1213"></a>1213           define_method(method_name) do
</span><span class="uncovered1"><a name="line1214"></a>1214             association = instance_variable_get(&quot;#{ivar}&quot;) if instance_variable_defined?(&quot;#{ivar}&quot;)
</span><span class="uncovered0"><a name="line1215"></a>1215 
</span><span class="uncovered1"><a name="line1216"></a>1216             records_to_save = if @new_record_before_save
</span><span class="uncovered0"><a name="line1217"></a>1217               association
</span><span class="uncovered1"><a name="line1218"></a>1218             elsif association.respond_to?(:loaded?) &amp;&amp; association.loaded?
</span><span class="uncovered0"><a name="line1219"></a>1219               association.select { |record| record.new_record? }
</span><span class="uncovered1"><a name="line1220"></a>1220             elsif association.respond_to?(:loaded?) &amp;&amp; !association.loaded?
</span><span class="uncovered0"><a name="line1221"></a>1221               association.target.select { |record| record.new_record? }
</span><span class="uncovered1"><a name="line1222"></a>1222             else
</span><span class="uncovered0"><a name="line1223"></a>1223               []
</span><span class="uncovered1"><a name="line1224"></a>1224             end
</span><span class="uncovered0"><a name="line1225"></a>1225             records_to_save.each { |record| association.send(:insert_record, record) } unless records_to_save.blank?
</span><span class="uncovered1"><a name="line1226"></a>1226 
</span><span class="uncovered0"><a name="line1227"></a>1227             # reconstruct the SQL queries now that we know the owner's id
</span><span class="uncovered1"><a name="line1228"></a>1228             association.send(:construct_sql) if association.respond_to?(:construct_sql)
</span><span class="uncovered0"><a name="line1229"></a>1229           end
</span><span class="inferred1"><a name="line1230"></a>1230 
</span><span class="inferred0"><a name="line1231"></a>1231           # Doesn't use after_save as that would save associations added in after_create/after_update twice
</span><span class="marked1"><a name="line1232"></a>1232           after_create method_name
</span><span class="marked0"><a name="line1233"></a>1233           after_update method_name
</span><span class="inferred1"><a name="line1234"></a>1234         end
</span><span class="inferred0"><a name="line1235"></a>1235 
</span><span class="marked1"><a name="line1236"></a>1236         def association_constructor_method(constructor, reflection, association_proxy_class)
</span><span class="marked0"><a name="line1237"></a>1237           define_method(&quot;#{constructor}_#{reflection.name}&quot;) do |*params|
</span><span class="uncovered1"><a name="line1238"></a>1238             ivar = &quot;@#{reflection.name}&quot;
</span><span class="uncovered0"><a name="line1239"></a>1239 
</span><span class="uncovered1"><a name="line1240"></a>1240             attributees      = params.first unless params.empty?
</span><span class="uncovered0"><a name="line1241"></a>1241             replace_existing = params[1].nil? ? true : params[1]
</span><span class="uncovered1"><a name="line1242"></a>1242             association      = instance_variable_get(ivar) if instance_variable_defined?(ivar)
</span><span class="uncovered0"><a name="line1243"></a>1243 
</span><span class="uncovered1"><a name="line1244"></a>1244             if association.nil?
</span><span class="uncovered0"><a name="line1245"></a>1245               association = association_proxy_class.new(self, reflection)
</span><span class="uncovered1"><a name="line1246"></a>1246               instance_variable_set(ivar, association)
</span><span class="uncovered0"><a name="line1247"></a>1247             end
</span><span class="uncovered1"><a name="line1248"></a>1248 
</span><span class="uncovered0"><a name="line1249"></a>1249             if association_proxy_class == HasOneAssociation
</span><span class="uncovered1"><a name="line1250"></a>1250               association.send(constructor, attributees, replace_existing)
</span><span class="uncovered0"><a name="line1251"></a>1251             else
</span><span class="uncovered1"><a name="line1252"></a>1252               association.send(constructor, attributees)
</span><span class="uncovered0"><a name="line1253"></a>1253             end
</span><span class="uncovered1"><a name="line1254"></a>1254           end
</span><span class="marked0"><a name="line1255"></a>1255         end
</span><span class="inferred1"><a name="line1256"></a>1256 
</span><span class="marked0"><a name="line1257"></a>1257         def find_with_associations(options = {})
</span><span class="uncovered1"><a name="line1258"></a>1258           catch :invalid_query do
</span><span class="uncovered0"><a name="line1259"></a>1259             join_dependency = JoinDependency.new(self, merge_includes(scope(:find, :include), options[:include]), options[:joins])
</span><span class="uncovered1"><a name="line1260"></a>1260             rows = select_all_rows(options, join_dependency)
</span><span class="uncovered0"><a name="line1261"></a>1261             return join_dependency.instantiate(rows)
</span><span class="uncovered1"><a name="line1262"></a>1262           end
</span><span class="uncovered0"><a name="line1263"></a>1263           []
</span><span class="uncovered1"><a name="line1264"></a>1264         end
</span><span class="inferred0"><a name="line1265"></a>1265 
</span><span class="inferred1"><a name="line1266"></a>1266         # See HasManyAssociation#delete_records.  Dependent associations
</span><span class="inferred0"><a name="line1267"></a>1267         # delete children, otherwise foreign key is set to NULL.
</span><span class="marked1"><a name="line1268"></a>1268         def configure_dependency_for_has_many(reflection)
</span><span class="marked0"><a name="line1269"></a>1269           if reflection.options.include?(:dependent)
</span><span class="uncovered1"><a name="line1270"></a>1270             # Add polymorphic type if the :as option is present
</span><span class="uncovered0"><a name="line1271"></a>1271             dependent_conditions = []
</span><span class="uncovered1"><a name="line1272"></a>1272             dependent_conditions &lt;&lt; &quot;#{reflection.primary_key_name} = \#{record.quoted_id}&quot;
</span><span class="uncovered0"><a name="line1273"></a>1273             dependent_conditions &lt;&lt; &quot;#{reflection.options[:as]}_type = '#{base_class.name}'&quot; if reflection.options[:as]
</span><span class="uncovered1"><a name="line1274"></a>1274             dependent_conditions &lt;&lt; sanitize_sql(reflection.options[:conditions]) if reflection.options[:conditions]
</span><span class="uncovered0"><a name="line1275"></a>1275             dependent_conditions = dependent_conditions.collect {|where| &quot;(#{where})&quot; }.join(&quot; AND &quot;)
</span><span class="uncovered1"><a name="line1276"></a>1276 
</span><span class="uncovered0"><a name="line1277"></a>1277             case reflection.options[:dependent]
</span><span class="uncovered1"><a name="line1278"></a>1278               when :destroy
</span><span class="uncovered0"><a name="line1279"></a>1279                 method_name = &quot;has_many_dependent_destroy_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered1"><a name="line1280"></a>1280                 define_method(method_name) do
</span><span class="uncovered0"><a name="line1281"></a>1281                   send(&quot;#{reflection.name}&quot;).each { |o| o.destroy }
</span><span class="uncovered1"><a name="line1282"></a>1282                 end
</span><span class="uncovered0"><a name="line1283"></a>1283                 before_destroy method_name
</span><span class="uncovered1"><a name="line1284"></a>1284               when :delete_all
</span><span class="uncovered0"><a name="line1285"></a>1285                 module_eval &quot;before_destroy { |record| #{reflection.class_name}.delete_all(%(#{dependent_conditions})) }&quot;
</span><span class="uncovered1"><a name="line1286"></a>1286               when :nullify
</span><span class="uncovered0"><a name="line1287"></a>1287                 module_eval &quot;before_destroy { |record| #{reflection.class_name}.update_all(%(#{reflection.primary_key_name} = NULL),  %(#{dependent_conditions})) }&quot;
</span><span class="uncovered1"><a name="line1288"></a>1288               else
</span><span class="uncovered0"><a name="line1289"></a>1289                 raise ArgumentError, &quot;The :dependent option expects either :destroy, :delete_all, or :nullify (#{reflection.options[:dependent].inspect})&quot;
</span><span class="uncovered1"><a name="line1290"></a>1290             end
</span><span class="uncovered0"><a name="line1291"></a>1291           end
</span><span class="marked1"><a name="line1292"></a>1292         end
</span><span class="inferred0"><a name="line1293"></a>1293 
</span><span class="marked1"><a name="line1294"></a>1294         def configure_dependency_for_has_one(reflection)
</span><span class="uncovered0"><a name="line1295"></a>1295           if reflection.options.include?(:dependent)
</span><span class="uncovered1"><a name="line1296"></a>1296             case reflection.options[:dependent]
</span><span class="uncovered0"><a name="line1297"></a>1297               when :destroy
</span><span class="uncovered1"><a name="line1298"></a>1298                 method_name = &quot;has_one_dependent_destroy_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered0"><a name="line1299"></a>1299                 define_method(method_name) do
</span><span class="uncovered1"><a name="line1300"></a>1300                   association = send(&quot;#{reflection.name}&quot;)
</span><span class="uncovered0"><a name="line1301"></a>1301                   association.destroy unless association.nil?
</span><span class="uncovered1"><a name="line1302"></a>1302                 end
</span><span class="uncovered0"><a name="line1303"></a>1303                 before_destroy method_name
</span><span class="uncovered1"><a name="line1304"></a>1304               when :delete
</span><span class="uncovered0"><a name="line1305"></a>1305                 method_name = &quot;has_one_dependent_delete_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered1"><a name="line1306"></a>1306                 define_method(method_name) do
</span><span class="uncovered0"><a name="line1307"></a>1307                   association = send(&quot;#{reflection.name}&quot;)
</span><span class="uncovered1"><a name="line1308"></a>1308                   association.class.delete(association.id) unless association.nil?
</span><span class="uncovered0"><a name="line1309"></a>1309                 end
</span><span class="uncovered1"><a name="line1310"></a>1310                 before_destroy method_name
</span><span class="uncovered0"><a name="line1311"></a>1311               when :nullify
</span><span class="uncovered1"><a name="line1312"></a>1312                 method_name = &quot;has_one_dependent_nullify_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered0"><a name="line1313"></a>1313                 define_method(method_name) do
</span><span class="uncovered1"><a name="line1314"></a>1314                   association = send(&quot;#{reflection.name}&quot;)
</span><span class="uncovered0"><a name="line1315"></a>1315                   association.update_attribute(&quot;#{reflection.primary_key_name}&quot;, nil) unless association.nil?
</span><span class="uncovered1"><a name="line1316"></a>1316                 end
</span><span class="uncovered0"><a name="line1317"></a>1317                 before_destroy method_name
</span><span class="uncovered1"><a name="line1318"></a>1318               else
</span><span class="uncovered0"><a name="line1319"></a>1319                 raise ArgumentError, &quot;The :dependent option expects either :destroy, :delete or :nullify (#{reflection.options[:dependent].inspect})&quot;
</span><span class="uncovered1"><a name="line1320"></a>1320             end
</span><span class="uncovered0"><a name="line1321"></a>1321           end
</span><span class="uncovered1"><a name="line1322"></a>1322         end
</span><span class="inferred0"><a name="line1323"></a>1323 
</span><span class="marked1"><a name="line1324"></a>1324         def configure_dependency_for_belongs_to(reflection)
</span><span class="marked0"><a name="line1325"></a>1325           if reflection.options.include?(:dependent)
</span><span class="uncovered1"><a name="line1326"></a>1326             case reflection.options[:dependent]
</span><span class="uncovered0"><a name="line1327"></a>1327               when :destroy
</span><span class="uncovered1"><a name="line1328"></a>1328                 method_name = &quot;belongs_to_dependent_destroy_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered0"><a name="line1329"></a>1329                 define_method(method_name) do
</span><span class="uncovered1"><a name="line1330"></a>1330                   association = send(&quot;#{reflection.name}&quot;)
</span><span class="uncovered0"><a name="line1331"></a>1331                   association.destroy unless association.nil?
</span><span class="uncovered1"><a name="line1332"></a>1332                 end
</span><span class="uncovered0"><a name="line1333"></a>1333                 before_destroy method_name
</span><span class="uncovered1"><a name="line1334"></a>1334               when :delete
</span><span class="uncovered0"><a name="line1335"></a>1335                 method_name = &quot;belongs_to_dependent_delete_for_#{reflection.name}&quot;.to_sym
</span><span class="uncovered1"><a name="line1336"></a>1336                 define_method(method_name) do
</span><span class="uncovered0"><a name="line1337"></a>1337                   association = send(&quot;#{reflection.name}&quot;)
</span><span class="uncovered1"><a name="line1338"></a>1338                   association.class.delete(association.id) unless association.nil?
</span><span class="uncovered0"><a name="line1339"></a>1339                 end
</span><span class="uncovered1"><a name="line1340"></a>1340                 before_destroy method_name
</span><span class="uncovered0"><a name="line1341"></a>1341               else
</span><span class="uncovered1"><a name="line1342"></a>1342                 raise ArgumentError, &quot;The :dependent option expects either :destroy or :delete (#{reflection.options[:dependent].inspect})&quot;
</span><span class="uncovered0"><a name="line1343"></a>1343             end
</span><span class="uncovered1"><a name="line1344"></a>1344           end
</span><span class="marked0"><a name="line1345"></a>1345         end
</span><span class="inferred1"><a name="line1346"></a>1346 
</span><span class="marked0"><a name="line1347"></a>1347         def create_has_many_reflection(association_id, options, &amp;extension)
</span><span class="marked1"><a name="line1348"></a>1348           options.assert_valid_keys(
</span><span class="inferred0"><a name="line1349"></a>1349             :class_name, :table_name, :foreign_key,
</span><span class="inferred1"><a name="line1350"></a>1350             :dependent,
</span><span class="inferred0"><a name="line1351"></a>1351             :select, :conditions, :include, :order, :group, :limit, :offset,
</span><span class="inferred1"><a name="line1352"></a>1352             :as, :through, :source, :source_type,
</span><span class="inferred0"><a name="line1353"></a>1353             :uniq,
</span><span class="inferred1"><a name="line1354"></a>1354             :finder_sql, :counter_sql,
</span><span class="inferred0"><a name="line1355"></a>1355             :before_add, :after_add, :before_remove, :after_remove,
</span><span class="inferred1"><a name="line1356"></a>1356             :extend, :readonly,
</span><span class="inferred0"><a name="line1357"></a>1357             :validate
</span><span class="inferred1"><a name="line1358"></a>1358           )
</span><span class="inferred0"><a name="line1359"></a>1359 
</span><span class="marked1"><a name="line1360"></a>1360           options[:extend] = create_extension_modules(association_id, extension, options[:extend])
</span><span class="inferred0"><a name="line1361"></a>1361 
</span><span class="marked1"><a name="line1362"></a>1362           create_reflection(:has_many, association_id, options, self)
</span><span class="inferred0"><a name="line1363"></a>1363         end
</span><span class="inferred1"><a name="line1364"></a>1364 
</span><span class="marked0"><a name="line1365"></a>1365         def create_has_one_reflection(association_id, options)
</span><span class="uncovered1"><a name="line1366"></a>1366           options.assert_valid_keys(
</span><span class="uncovered0"><a name="line1367"></a>1367             :class_name, :foreign_key, :remote, :select, :conditions, :order, :include, :dependent, :counter_cache, :extend, :as, :readonly, :validate
</span><span class="uncovered1"><a name="line1368"></a>1368           )
</span><span class="uncovered0"><a name="line1369"></a>1369 
</span><span class="uncovered1"><a name="line1370"></a>1370           create_reflection(:has_one, association_id, options, self)
</span><span class="uncovered0"><a name="line1371"></a>1371         end
</span><span class="inferred1"><a name="line1372"></a>1372         
</span><span class="marked0"><a name="line1373"></a>1373         def create_has_one_through_reflection(association_id, options)
</span><span class="uncovered1"><a name="line1374"></a>1374           options.assert_valid_keys(
</span><span class="uncovered0"><a name="line1375"></a>1375             :class_name, :foreign_key, :remote, :select, :conditions, :order, :include, :dependent, :counter_cache, :extend, :as, :through, :source, :source_type, :validate
</span><span class="uncovered1"><a name="line1376"></a>1376           )
</span><span class="uncovered0"><a name="line1377"></a>1377           create_reflection(:has_one, association_id, options, self)
</span><span class="uncovered1"><a name="line1378"></a>1378         end
</span><span class="inferred0"><a name="line1379"></a>1379 
</span><span class="marked1"><a name="line1380"></a>1380         def create_belongs_to_reflection(association_id, options)
</span><span class="marked0"><a name="line1381"></a>1381           options.assert_valid_keys(
</span><span class="inferred1"><a name="line1382"></a>1382             :class_name, :foreign_key, :foreign_type, :remote, :select, :conditions, :include, :dependent,
</span><span class="inferred0"><a name="line1383"></a>1383             :counter_cache, :extend, :polymorphic, :readonly, :validate
</span><span class="inferred1"><a name="line1384"></a>1384           )
</span><span class="inferred0"><a name="line1385"></a>1385 
</span><span class="marked1"><a name="line1386"></a>1386           reflection = create_reflection(:belongs_to, association_id, options, self)
</span><span class="inferred0"><a name="line1387"></a>1387 
</span><span class="marked1"><a name="line1388"></a>1388           if options[:polymorphic]
</span><span class="uncovered0"><a name="line1389"></a>1389             reflection.options[:foreign_type] ||= reflection.class_name.underscore + &quot;_type&quot;
</span><span class="uncovered1"><a name="line1390"></a>1390           end
</span><span class="inferred0"><a name="line1391"></a>1391 
</span><span class="marked1"><a name="line1392"></a>1392           reflection
</span><span class="inferred0"><a name="line1393"></a>1393         end
</span><span class="inferred1"><a name="line1394"></a>1394 
</span><span class="marked0"><a name="line1395"></a>1395         def create_has_and_belongs_to_many_reflection(association_id, options, &amp;extension)
</span><span class="uncovered1"><a name="line1396"></a>1396           options.assert_valid_keys(
</span><span class="uncovered0"><a name="line1397"></a>1397             :class_name, :table_name, :join_table, :foreign_key, :association_foreign_key,
</span><span class="uncovered1"><a name="line1398"></a>1398             :select, :conditions, :include, :order, :group, :limit, :offset,
</span><span class="uncovered0"><a name="line1399"></a>1399             :uniq,
</span><span class="uncovered1"><a name="line1400"></a>1400             :finder_sql, :delete_sql, :insert_sql,
</span><span class="uncovered0"><a name="line1401"></a>1401             :before_add, :after_add, :before_remove, :after_remove,
</span><span class="uncovered1"><a name="line1402"></a>1402             :extend, :readonly,
</span><span class="uncovered0"><a name="line1403"></a>1403             :validate
</span><span class="uncovered1"><a name="line1404"></a>1404           )
</span><span class="uncovered0"><a name="line1405"></a>1405 
</span><span class="uncovered1"><a name="line1406"></a>1406           options[:extend] = create_extension_modules(association_id, extension, options[:extend])
</span><span class="uncovered0"><a name="line1407"></a>1407 
</span><span class="uncovered1"><a name="line1408"></a>1408           reflection = create_reflection(:has_and_belongs_to_many, association_id, options, self)
</span><span class="uncovered0"><a name="line1409"></a>1409 
</span><span class="uncovered1"><a name="line1410"></a>1410           reflection.options[:join_table] ||= join_table_name(undecorated_table_name(self.to_s), undecorated_table_name(reflection.class_name))
</span><span class="uncovered0"><a name="line1411"></a>1411 
</span><span class="uncovered1"><a name="line1412"></a>1412           reflection
</span><span class="uncovered0"><a name="line1413"></a>1413         end
</span><span class="inferred1"><a name="line1414"></a>1414 
</span><span class="marked0"><a name="line1415"></a>1415         def reflect_on_included_associations(associations)
</span><span class="uncovered1"><a name="line1416"></a>1416           [ associations ].flatten.collect { |association| reflect_on_association(association.to_s.intern) }
</span><span class="uncovered0"><a name="line1417"></a>1417         end
</span><span class="inferred1"><a name="line1418"></a>1418 
</span><span class="marked0"><a name="line1419"></a>1419         def guard_against_unlimitable_reflections(reflections, options)
</span><span class="uncovered1"><a name="line1420"></a>1420           if (options[:offset] || options[:limit]) &amp;&amp; !using_limitable_reflections?(reflections)
</span><span class="uncovered0"><a name="line1421"></a>1421             raise(
</span><span class="uncovered1"><a name="line1422"></a>1422               ConfigurationError,
</span><span class="uncovered0"><a name="line1423"></a>1423               &quot;You can not use offset and limit together with has_many or has_and_belongs_to_many associations&quot;
</span><span class="uncovered1"><a name="line1424"></a>1424             )
</span><span class="uncovered0"><a name="line1425"></a>1425           end
</span><span class="uncovered1"><a name="line1426"></a>1426         end
</span><span class="inferred0"><a name="line1427"></a>1427 
</span><span class="marked1"><a name="line1428"></a>1428         def select_all_rows(options, join_dependency)
</span><span class="uncovered0"><a name="line1429"></a>1429           connection.select_all(
</span><span class="uncovered1"><a name="line1430"></a>1430             construct_finder_sql_with_included_associations(options, join_dependency),
</span><span class="uncovered0"><a name="line1431"></a>1431             &quot;#{name} Load Including Associations&quot;
</span><span class="uncovered1"><a name="line1432"></a>1432           )
</span><span class="uncovered0"><a name="line1433"></a>1433         end
</span><span class="inferred1"><a name="line1434"></a>1434 
</span><span class="marked0"><a name="line1435"></a>1435         def construct_finder_sql_with_included_associations(options, join_dependency)
</span><span class="uncovered1"><a name="line1436"></a>1436           scope = scope(:find)
</span><span class="uncovered0"><a name="line1437"></a>1437           sql = &quot;SELECT #{column_aliases(join_dependency)} FROM #{(scope &amp;&amp; scope[:from]) || options[:from] || quoted_table_name} &quot;
</span><span class="uncovered1"><a name="line1438"></a>1438           sql &lt;&lt; join_dependency.join_associations.collect{|join| join.association_join }.join
</span><span class="uncovered0"><a name="line1439"></a>1439 
</span><span class="uncovered1"><a name="line1440"></a>1440           add_joins!(sql, options, scope)
</span><span class="uncovered0"><a name="line1441"></a>1441           add_conditions!(sql, options[:conditions], scope)
</span><span class="uncovered1"><a name="line1442"></a>1442           add_limited_ids_condition!(sql, options, join_dependency) if !using_limitable_reflections?(join_dependency.reflections) &amp;&amp; ((scope &amp;&amp; scope[:limit]) || options[:limit])
</span><span class="uncovered0"><a name="line1443"></a>1443 
</span><span class="uncovered1"><a name="line1444"></a>1444           add_group!(sql, options[:group], scope)
</span><span class="uncovered0"><a name="line1445"></a>1445           add_order!(sql, options[:order], scope)
</span><span class="uncovered1"><a name="line1446"></a>1446           add_limit!(sql, options, scope) if using_limitable_reflections?(join_dependency.reflections)
</span><span class="uncovered0"><a name="line1447"></a>1447           add_lock!(sql, options, scope)
</span><span class="uncovered1"><a name="line1448"></a>1448 
</span><span class="uncovered0"><a name="line1449"></a>1449           return sanitize_sql(sql)
</span><span class="uncovered1"><a name="line1450"></a>1450         end
</span><span class="inferred0"><a name="line1451"></a>1451 
</span><span class="marked1"><a name="line1452"></a>1452         def add_limited_ids_condition!(sql, options, join_dependency)
</span><span class="uncovered0"><a name="line1453"></a>1453           unless (id_list = select_limited_ids_list(options, join_dependency)).empty?
</span><span class="uncovered1"><a name="line1454"></a>1454             sql &lt;&lt; &quot;#{condition_word(sql)} #{connection.quote_table_name table_name}.#{primary_key} IN (#{id_list}) &quot;
</span><span class="uncovered0"><a name="line1455"></a>1455           else
</span><span class="uncovered1"><a name="line1456"></a>1456             throw :invalid_query
</span><span class="uncovered0"><a name="line1457"></a>1457           end
</span><span class="uncovered1"><a name="line1458"></a>1458         end
</span><span class="inferred0"><a name="line1459"></a>1459 
</span><span class="marked1"><a name="line1460"></a>1460         def select_limited_ids_list(options, join_dependency)
</span><span class="uncovered0"><a name="line1461"></a>1461           pk = columns_hash[primary_key]
</span><span class="uncovered1"><a name="line1462"></a>1462 
</span><span class="uncovered0"><a name="line1463"></a>1463           connection.select_all(
</span><span class="uncovered1"><a name="line1464"></a>1464             construct_finder_sql_for_association_limiting(options, join_dependency),
</span><span class="uncovered0"><a name="line1465"></a>1465             &quot;#{name} Load IDs For Limited Eager Loading&quot;
</span><span class="uncovered1"><a name="line1466"></a>1466           ).collect { |row| connection.quote(row[primary_key], pk) }.join(&quot;, &quot;)
</span><span class="uncovered0"><a name="line1467"></a>1467         end
</span><span class="inferred1"><a name="line1468"></a>1468 
</span><span class="marked0"><a name="line1469"></a>1469         def construct_finder_sql_for_association_limiting(options, join_dependency)
</span><span class="uncovered1"><a name="line1470"></a>1470           scope       = scope(:find)
</span><span class="uncovered0"><a name="line1471"></a>1471 
</span><span class="uncovered1"><a name="line1472"></a>1472           # Only join tables referenced in order or conditions since this is particularly slow on the pre-query.
</span><span class="uncovered0"><a name="line1473"></a>1473           tables_from_conditions = conditions_tables(options)
</span><span class="uncovered1"><a name="line1474"></a>1474           tables_from_order      = order_tables(options)
</span><span class="uncovered0"><a name="line1475"></a>1475           all_tables             = tables_from_conditions + tables_from_order
</span><span class="uncovered1"><a name="line1476"></a>1476           distinct_join_associations = all_tables.uniq.map{|table|
</span><span class="uncovered0"><a name="line1477"></a>1477             join_dependency.joins_for_table_name(table)
</span><span class="uncovered1"><a name="line1478"></a>1478           }.flatten.compact.uniq
</span><span class="uncovered0"><a name="line1479"></a>1479 
</span><span class="uncovered1"><a name="line1480"></a>1480           order = options[:order]
</span><span class="uncovered0"><a name="line1481"></a>1481           if scoped_order = (scope &amp;&amp; scope[:order])
</span><span class="uncovered1"><a name="line1482"></a>1482             order = order ? &quot;#{order}, #{scoped_order}&quot; : scoped_order
</span><span class="uncovered0"><a name="line1483"></a>1483           end
</span><span class="uncovered1"><a name="line1484"></a>1484 
</span><span class="uncovered0"><a name="line1485"></a>1485           is_distinct = !options[:joins].blank? || include_eager_conditions?(options, tables_from_conditions) || include_eager_order?(options, tables_from_order)
</span><span class="uncovered1"><a name="line1486"></a>1486           sql = &quot;SELECT &quot;
</span><span class="uncovered0"><a name="line1487"></a>1487           if is_distinct
</span><span class="uncovered1"><a name="line1488"></a>1488             sql &lt;&lt; connection.distinct(&quot;#{connection.quote_table_name table_name}.#{primary_key}&quot;, order)
</span><span class="uncovered0"><a name="line1489"></a>1489           else
</span><span class="uncovered1"><a name="line1490"></a>1490             sql &lt;&lt; primary_key
</span><span class="uncovered0"><a name="line1491"></a>1491           end
</span><span class="uncovered1"><a name="line1492"></a>1492           sql &lt;&lt; &quot; FROM #{connection.quote_table_name table_name} &quot;
</span><span class="uncovered0"><a name="line1493"></a>1493 
</span><span class="uncovered1"><a name="line1494"></a>1494           if is_distinct
</span><span class="uncovered0"><a name="line1495"></a>1495             sql &lt;&lt; distinct_join_associations.collect(&amp;:association_join).join
</span><span class="uncovered1"><a name="line1496"></a>1496             add_joins!(sql, options, scope)
</span><span class="uncovered0"><a name="line1497"></a>1497           end
</span><span class="uncovered1"><a name="line1498"></a>1498 
</span><span class="uncovered0"><a name="line1499"></a>1499           add_conditions!(sql, options[:conditions], scope)
</span><span class="uncovered1"><a name="line1500"></a>1500           add_group!(sql, options[:group], scope)
</span><span class="uncovered0"><a name="line1501"></a>1501 
</span><span class="uncovered1"><a name="line1502"></a>1502           if order &amp;&amp; is_distinct
</span><span class="uncovered0"><a name="line1503"></a>1503             connection.add_order_by_for_association_limiting!(sql, :order =&gt; order)
</span><span class="uncovered1"><a name="line1504"></a>1504           else
</span><span class="uncovered0"><a name="line1505"></a>1505             add_order!(sql, options[:order], scope)
</span><span class="uncovered1"><a name="line1506"></a>1506           end
</span><span class="uncovered0"><a name="line1507"></a>1507 
</span><span class="uncovered1"><a name="line1508"></a>1508           add_limit!(sql, options, scope)
</span><span class="uncovered0"><a name="line1509"></a>1509 
</span><span class="uncovered1"><a name="line1510"></a>1510           return sanitize_sql(sql)
</span><span class="uncovered0"><a name="line1511"></a>1511         end
</span><span class="inferred1"><a name="line1512"></a>1512 
</span><span class="marked0"><a name="line1513"></a>1513         def conditions_tables(options)
</span><span class="uncovered1"><a name="line1514"></a>1514           # look in both sets of conditions
</span><span class="uncovered0"><a name="line1515"></a>1515           conditions = [scope(:find, :conditions), options[:conditions]].inject([]) do |all, cond|
</span><span class="uncovered1"><a name="line1516"></a>1516             case cond
</span><span class="uncovered0"><a name="line1517"></a>1517               when nil   then all
</span><span class="uncovered1"><a name="line1518"></a>1518               when Array then all &lt;&lt; cond.first
</span><span class="uncovered0"><a name="line1519"></a>1519               else            all &lt;&lt; cond
</span><span class="uncovered1"><a name="line1520"></a>1520             end
</span><span class="uncovered0"><a name="line1521"></a>1521           end
</span><span class="uncovered1"><a name="line1522"></a>1522           conditions.join(' ').scan(/([\.a-zA-Z_]+).?\./).flatten
</span><span class="uncovered0"><a name="line1523"></a>1523         end
</span><span class="inferred1"><a name="line1524"></a>1524 
</span><span class="marked0"><a name="line1525"></a>1525         def order_tables(options)
</span><span class="uncovered1"><a name="line1526"></a>1526           order = [options[:order], scope(:find, :order) ].join(&quot;, &quot;)
</span><span class="uncovered0"><a name="line1527"></a>1527           return [] unless order &amp;&amp; order.is_a?(String)
</span><span class="uncovered1"><a name="line1528"></a>1528           order.scan(/([\.a-zA-Z_]+).?\./).flatten
</span><span class="uncovered0"><a name="line1529"></a>1529         end
</span><span class="inferred1"><a name="line1530"></a>1530 
</span><span class="marked0"><a name="line1531"></a>1531         def selects_tables(options)
</span><span class="uncovered1"><a name="line1532"></a>1532           select = options[:select]
</span><span class="uncovered0"><a name="line1533"></a>1533           return [] unless select &amp;&amp; select.is_a?(String)
</span><span class="uncovered1"><a name="line1534"></a>1534           select.scan(/&quot;?([\.a-zA-Z_]+)&quot;?.?\./).flatten
</span><span class="uncovered0"><a name="line1535"></a>1535         end
</span><span class="inferred1"><a name="line1536"></a>1536 
</span><span class="inferred0"><a name="line1537"></a>1537         # Checks if the conditions reference a table other than the current model table
</span><span class="marked1"><a name="line1538"></a>1538         def include_eager_conditions?(options, tables = nil)
</span><span class="uncovered0"><a name="line1539"></a>1539           ((tables || conditions_tables(options)) - [table_name]).any?
</span><span class="uncovered1"><a name="line1540"></a>1540         end
</span><span class="inferred0"><a name="line1541"></a>1541 
</span><span class="inferred1"><a name="line1542"></a>1542         # Checks if the query order references a table other than the current model's table.
</span><span class="marked0"><a name="line1543"></a>1543         def include_eager_order?(options, tables = nil)
</span><span class="uncovered1"><a name="line1544"></a>1544           ((tables || order_tables(options)) - [table_name]).any?
</span><span class="uncovered0"><a name="line1545"></a>1545         end
</span><span class="inferred1"><a name="line1546"></a>1546 
</span><span class="marked0"><a name="line1547"></a>1547         def include_eager_select?(options)
</span><span class="uncovered1"><a name="line1548"></a>1548           (selects_tables(options) - [table_name]).any?
</span><span class="uncovered0"><a name="line1549"></a>1549         end
</span><span class="inferred1"><a name="line1550"></a>1550 
</span><span class="marked0"><a name="line1551"></a>1551         def references_eager_loaded_tables?(options)
</span><span class="uncovered1"><a name="line1552"></a>1552           include_eager_order?(options) || include_eager_conditions?(options) || include_eager_select?(options)
</span><span class="uncovered0"><a name="line1553"></a>1553         end
</span><span class="inferred1"><a name="line1554"></a>1554 
</span><span class="marked0"><a name="line1555"></a>1555         def using_limitable_reflections?(reflections)
</span><span class="uncovered1"><a name="line1556"></a>1556           reflections.reject { |r| [ :belongs_to, :has_one ].include?(r.macro) }.length.zero?
</span><span class="uncovered0"><a name="line1557"></a>1557         end
</span><span class="inferred1"><a name="line1558"></a>1558 
</span><span class="marked0"><a name="line1559"></a>1559         def column_aliases(join_dependency)
</span><span class="uncovered1"><a name="line1560"></a>1560           join_dependency.joins.collect{|join| join.column_names_with_alias.collect{|column_name, aliased_name|
</span><span class="uncovered0"><a name="line1561"></a>1561               &quot;#{connection.quote_table_name join.aliased_table_name}.#{connection.quote_column_name column_name} AS #{aliased_name}&quot;}}.flatten.join(&quot;, &quot;)
</span><span class="uncovered1"><a name="line1562"></a>1562         end
</span><span class="inferred0"><a name="line1563"></a>1563 
</span><span class="marked1"><a name="line1564"></a>1564         def add_association_callbacks(association_name, options)
</span><span class="marked0"><a name="line1565"></a>1565           callbacks = %w(before_add after_add before_remove after_remove)
</span><span class="marked1"><a name="line1566"></a>1566           callbacks.each do |callback_name|
</span><span class="marked0"><a name="line1567"></a>1567             full_callback_name = &quot;#{callback_name}_for_#{association_name}&quot;
</span><span class="marked1"><a name="line1568"></a>1568             defined_callbacks = options[callback_name.to_sym]
</span><span class="marked0"><a name="line1569"></a>1569             if options.has_key?(callback_name.to_sym)
</span><span class="inferred1"><a name="line1570"></a>1570               class_inheritable_reader full_callback_name.to_sym
</span><span class="inferred0"><a name="line1571"></a>1571               write_inheritable_attribute(full_callback_name.to_sym, [defined_callbacks].flatten)
</span><span class="inferred1"><a name="line1572"></a>1572             else
</span><span class="marked0"><a name="line1573"></a>1573               write_inheritable_attribute(full_callback_name.to_sym, [])
</span><span class="inferred1"><a name="line1574"></a>1574             end
</span><span class="inferred0"><a name="line1575"></a>1575           end
</span><span class="inferred1"><a name="line1576"></a>1576         end
</span><span class="inferred0"><a name="line1577"></a>1577 
</span><span class="marked1"><a name="line1578"></a>1578         def condition_word(sql)
</span><span class="uncovered0"><a name="line1579"></a>1579           sql =~ /where/i ? &quot; AND &quot; : &quot;WHERE &quot;
</span><span class="uncovered1"><a name="line1580"></a>1580         end
</span><span class="inferred0"><a name="line1581"></a>1581 
</span><span class="marked1"><a name="line1582"></a>1582         def create_extension_modules(association_id, block_extension, extensions)
</span><span class="marked0"><a name="line1583"></a>1583           if block_extension
</span><span class="uncovered1"><a name="line1584"></a>1584             extension_module_name = &quot;#{self.to_s}#{association_id.to_s.camelize}AssociationExtension&quot;
</span><span class="uncovered0"><a name="line1585"></a>1585 
</span><span class="uncovered1"><a name="line1586"></a>1586             silence_warnings do
</span><span class="uncovered0"><a name="line1587"></a>1587               Object.const_set(extension_module_name, Module.new(&amp;block_extension))
</span><span class="uncovered1"><a name="line1588"></a>1588             end
</span><span class="uncovered0"><a name="line1589"></a>1589             Array(extensions).push(extension_module_name.constantize)
</span><span class="inferred1"><a name="line1590"></a>1590           else
</span><span class="marked0"><a name="line1591"></a>1591             Array(extensions)
</span><span class="inferred1"><a name="line1592"></a>1592           end
</span><span class="marked0"><a name="line1593"></a>1593         end
</span><span class="inferred1"><a name="line1594"></a>1594 
</span><span class="marked0"><a name="line1595"></a>1595         class JoinDependency # :nodoc:
</span><span class="marked1"><a name="line1596"></a>1596           attr_reader :joins, :reflections, :table_aliases
</span><span class="inferred0"><a name="line1597"></a>1597 
</span><span class="marked1"><a name="line1598"></a>1598           def initialize(base, associations, joins)
</span><span class="uncovered0"><a name="line1599"></a>1599             @joins                 = [JoinBase.new(base, joins)]
</span><span class="uncovered1"><a name="line1600"></a>1600             @associations          = associations
</span><span class="uncovered0"><a name="line1601"></a>1601             @reflections           = []
</span><span class="uncovered1"><a name="line1602"></a>1602             @base_records_hash     = {}
</span><span class="uncovered0"><a name="line1603"></a>1603             @base_records_in_order = []
</span><span class="uncovered1"><a name="line1604"></a>1604             @table_aliases         = Hash.new { |aliases, table| aliases[table] = 0 }
</span><span class="uncovered0"><a name="line1605"></a>1605             @table_aliases[base.table_name] = 1
</span><span class="uncovered1"><a name="line1606"></a>1606             build(associations)
</span><span class="uncovered0"><a name="line1607"></a>1607           end
</span><span class="inferred1"><a name="line1608"></a>1608 
</span><span class="marked0"><a name="line1609"></a>1609           def join_associations
</span><span class="uncovered1"><a name="line1610"></a>1610             @joins[1..-1].to_a
</span><span class="uncovered0"><a name="line1611"></a>1611           end
</span><span class="inferred1"><a name="line1612"></a>1612 
</span><span class="marked0"><a name="line1613"></a>1613           def join_base
</span><span class="uncovered1"><a name="line1614"></a>1614             @joins[0]
</span><span class="uncovered0"><a name="line1615"></a>1615           end
</span><span class="inferred1"><a name="line1616"></a>1616 
</span><span class="marked0"><a name="line1617"></a>1617           def instantiate(rows)
</span><span class="uncovered1"><a name="line1618"></a>1618             rows.each_with_index do |row, i|
</span><span class="uncovered0"><a name="line1619"></a>1619               primary_id = join_base.record_id(row)
</span><span class="uncovered1"><a name="line1620"></a>1620               unless @base_records_hash[primary_id]
</span><span class="uncovered0"><a name="line1621"></a>1621                 @base_records_in_order &lt;&lt; (@base_records_hash[primary_id] = join_base.instantiate(row))
</span><span class="uncovered1"><a name="line1622"></a>1622               end
</span><span class="uncovered0"><a name="line1623"></a>1623               construct(@base_records_hash[primary_id], @associations, join_associations.dup, row)
</span><span class="uncovered1"><a name="line1624"></a>1624             end
</span><span class="uncovered0"><a name="line1625"></a>1625             remove_duplicate_results!(join_base.active_record, @base_records_in_order, @associations)
</span><span class="uncovered1"><a name="line1626"></a>1626             return @base_records_in_order
</span><span class="uncovered0"><a name="line1627"></a>1627           end
</span><span class="inferred1"><a name="line1628"></a>1628 
</span><span class="marked0"><a name="line1629"></a>1629           def remove_duplicate_results!(base, records, associations)
</span><span class="uncovered1"><a name="line1630"></a>1630             case associations
</span><span class="uncovered0"><a name="line1631"></a>1631               when Symbol, String
</span><span class="uncovered1"><a name="line1632"></a>1632                 reflection = base.reflections[associations]
</span><span class="uncovered0"><a name="line1633"></a>1633                 if reflection &amp;&amp; [:has_many, :has_and_belongs_to_many].include?(reflection.macro)
</span><span class="uncovered1"><a name="line1634"></a>1634                   records.each { |record| record.send(reflection.name).target.uniq! }
</span><span class="uncovered0"><a name="line1635"></a>1635                 end
</span><span class="uncovered1"><a name="line1636"></a>1636               when Array
</span><span class="uncovered0"><a name="line1637"></a>1637                 associations.each do |association|
</span><span class="uncovered1"><a name="line1638"></a>1638                   remove_duplicate_results!(base, records, association)
</span><span class="uncovered0"><a name="line1639"></a>1639                 end
</span><span class="uncovered1"><a name="line1640"></a>1640               when Hash
</span><span class="uncovered0"><a name="line1641"></a>1641                 associations.keys.each do |name|
</span><span class="uncovered1"><a name="line1642"></a>1642                   reflection = base.reflections[name]
</span><span class="uncovered0"><a name="line1643"></a>1643                   is_collection = [:has_many, :has_and_belongs_to_many].include?(reflection.macro)
</span><span class="uncovered1"><a name="line1644"></a>1644 
</span><span class="uncovered0"><a name="line1645"></a>1645                   parent_records = records.map do |record|
</span><span class="uncovered1"><a name="line1646"></a>1646                     descendant = record.send(reflection.name)
</span><span class="uncovered0"><a name="line1647"></a>1647                     next unless descendant
</span><span class="uncovered1"><a name="line1648"></a>1648                     descendant.target.uniq! if is_collection
</span><span class="uncovered0"><a name="line1649"></a>1649                     descendant
</span><span class="uncovered1"><a name="line1650"></a>1650                   end.flatten.compact
</span><span class="uncovered0"><a name="line1651"></a>1651 
</span><span class="uncovered1"><a name="line1652"></a>1652                   remove_duplicate_results!(reflection.class_name.constantize, parent_records, associations[name]) unless parent_records.empty?
</span><span class="uncovered0"><a name="line1653"></a>1653                 end
</span><span class="uncovered1"><a name="line1654"></a>1654             end
</span><span class="uncovered0"><a name="line1655"></a>1655           end
</span><span class="inferred1"><a name="line1656"></a>1656 
</span><span class="marked0"><a name="line1657"></a>1657           def join_for_table_name(table_name)
</span><span class="uncovered1"><a name="line1658"></a>1658             join = (@joins.select{|j|j.aliased_table_name == table_name.gsub(/^\&quot;(.*)\&quot;$/){$1} }.first) rescue nil
</span><span class="uncovered0"><a name="line1659"></a>1659             return join unless join.nil?
</span><span class="uncovered1"><a name="line1660"></a>1660             @joins.select{|j|j.is_a?(JoinAssociation) &amp;&amp; j.aliased_join_table_name == table_name.gsub(/^\&quot;(.*)\&quot;$/){$1} }.first rescue nil
</span><span class="uncovered0"><a name="line1661"></a>1661           end
</span><span class="inferred1"><a name="line1662"></a>1662 
</span><span class="marked0"><a name="line1663"></a>1663           def joins_for_table_name(table_name)
</span><span class="uncovered1"><a name="line1664"></a>1664             join = join_for_table_name(table_name)
</span><span class="uncovered0"><a name="line1665"></a>1665             result = nil
</span><span class="uncovered1"><a name="line1666"></a>1666             if join &amp;&amp; join.is_a?(JoinAssociation)
</span><span class="uncovered0"><a name="line1667"></a>1667               result = [join]
</span><span class="uncovered1"><a name="line1668"></a>1668               if join.parent &amp;&amp; join.parent.is_a?(JoinAssociation)
</span><span class="uncovered0"><a name="line1669"></a>1669                 result = joins_for_table_name(join.parent.aliased_table_name) +
</span><span class="uncovered1"><a name="line1670"></a>1670                          result
</span><span class="uncovered0"><a name="line1671"></a>1671               end
</span><span class="uncovered1"><a name="line1672"></a>1672             end
</span><span class="uncovered0"><a name="line1673"></a>1673             result
</span><span class="uncovered1"><a name="line1674"></a>1674           end
</span><span class="inferred0"><a name="line1675"></a>1675 
</span><span class="marked1"><a name="line1676"></a>1676           protected
</span><span class="marked0"><a name="line1677"></a>1677             def build(associations, parent = nil)
</span><span class="uncovered1"><a name="line1678"></a>1678               parent ||= @joins.last
</span><span class="uncovered0"><a name="line1679"></a>1679               case associations
</span><span class="uncovered1"><a name="line1680"></a>1680                 when Symbol, String
</span><span class="uncovered0"><a name="line1681"></a>1681                   reflection = parent.reflections[associations.to_s.intern] or
</span><span class="uncovered1"><a name="line1682"></a>1682                   raise ConfigurationError, &quot;Association named '#{ associations }' was not found; perhaps you misspelled it?&quot;
</span><span class="uncovered0"><a name="line1683"></a>1683                   @reflections &lt;&lt; reflection
</span><span class="uncovered1"><a name="line1684"></a>1684                   @joins &lt;&lt; build_join_association(reflection, parent)
</span><span class="uncovered0"><a name="line1685"></a>1685                 when Array
</span><span class="uncovered1"><a name="line1686"></a>1686                   associations.each do |association|
</span><span class="uncovered0"><a name="line1687"></a>1687                     build(association, parent)
</span><span class="uncovered1"><a name="line1688"></a>1688                   end
</span><span class="uncovered0"><a name="line1689"></a>1689                 when Hash
</span><span class="uncovered1"><a name="line1690"></a>1690                   associations.keys.sort{|a,b|a.to_s&lt;=&gt;b.to_s}.each do |name|
</span><span class="uncovered0"><a name="line1691"></a>1691                     build(name, parent)
</span><span class="uncovered1"><a name="line1692"></a>1692                     build(associations[name])
</span><span class="uncovered0"><a name="line1693"></a>1693                   end
</span><span class="uncovered1"><a name="line1694"></a>1694                 else
</span><span class="uncovered0"><a name="line1695"></a>1695                   raise ConfigurationError, associations.inspect
</span><span class="uncovered1"><a name="line1696"></a>1696               end
</span><span class="uncovered0"><a name="line1697"></a>1697             end
</span><span class="inferred1"><a name="line1698"></a>1698 
</span><span class="inferred0"><a name="line1699"></a>1699             # overridden in InnerJoinDependency subclass
</span><span class="marked1"><a name="line1700"></a>1700             def build_join_association(reflection, parent)
</span><span class="uncovered0"><a name="line1701"></a>1701               JoinAssociation.new(reflection, self, parent)
</span><span class="uncovered1"><a name="line1702"></a>1702             end
</span><span class="inferred0"><a name="line1703"></a>1703 
</span><span class="marked1"><a name="line1704"></a>1704             def construct(parent, associations, joins, row)
</span><span class="uncovered0"><a name="line1705"></a>1705               case associations
</span><span class="uncovered1"><a name="line1706"></a>1706                 when Symbol, String
</span><span class="uncovered0"><a name="line1707"></a>1707                   while (join = joins.shift).reflection.name.to_s != associations.to_s
</span><span class="uncovered1"><a name="line1708"></a>1708                     raise ConfigurationError, &quot;Not Enough Associations&quot; if joins.empty?
</span><span class="uncovered0"><a name="line1709"></a>1709                   end
</span><span class="uncovered1"><a name="line1710"></a>1710                   construct_association(parent, join, row)
</span><span class="uncovered0"><a name="line1711"></a>1711                 when Array
</span><span class="uncovered1"><a name="line1712"></a>1712                   associations.each do |association|
</span><span class="uncovered0"><a name="line1713"></a>1713                     construct(parent, association, joins, row)
</span><span class="uncovered1"><a name="line1714"></a>1714                   end
</span><span class="uncovered0"><a name="line1715"></a>1715                 when Hash
</span><span class="uncovered1"><a name="line1716"></a>1716                   associations.keys.sort{|a,b|a.to_s&lt;=&gt;b.to_s}.each do |name|
</span><span class="uncovered0"><a name="line1717"></a>1717                     association = construct_association(parent, joins.shift, row)
</span><span class="uncovered1"><a name="line1718"></a>1718                     construct(association, associations[name], joins, row) if association
</span><span class="uncovered0"><a name="line1719"></a>1719                   end
</span><span class="uncovered1"><a name="line1720"></a>1720                 else
</span><span class="uncovered0"><a name="line1721"></a>1721                   raise ConfigurationError, associations.inspect
</span><span class="uncovered1"><a name="line1722"></a>1722               end
</span><span class="uncovered0"><a name="line1723"></a>1723             end
</span><span class="inferred1"><a name="line1724"></a>1724 
</span><span class="marked0"><a name="line1725"></a>1725             def construct_association(record, join, row)
</span><span class="uncovered1"><a name="line1726"></a>1726               case join.reflection.macro
</span><span class="uncovered0"><a name="line1727"></a>1727                 when :has_many, :has_and_belongs_to_many
</span><span class="uncovered1"><a name="line1728"></a>1728                   collection = record.send(join.reflection.name)
</span><span class="uncovered0"><a name="line1729"></a>1729                   collection.loaded
</span><span class="uncovered1"><a name="line1730"></a>1730 
</span><span class="uncovered0"><a name="line1731"></a>1731                   return nil if record.id.to_s != join.parent.record_id(row).to_s or row[join.aliased_primary_key].nil?
</span><span class="uncovered1"><a name="line1732"></a>1732                   association = join.instantiate(row)
</span><span class="uncovered0"><a name="line1733"></a>1733                   collection.target.push(association)
</span><span class="uncovered1"><a name="line1734"></a>1734                 when :has_one
</span><span class="uncovered0"><a name="line1735"></a>1735                   return if record.id.to_s != join.parent.record_id(row).to_s
</span><span class="uncovered1"><a name="line1736"></a>1736                   return if record.instance_variable_defined?(&quot;@#{join.reflection.name}&quot;)
</span><span class="uncovered0"><a name="line1737"></a>1737                   association = join.instantiate(row) unless row[join.aliased_primary_key].nil?
</span><span class="uncovered1"><a name="line1738"></a>1738                   record.send(&quot;set_#{join.reflection.name}_target&quot;, association)
</span><span class="uncovered0"><a name="line1739"></a>1739                 when :belongs_to
</span><span class="uncovered1"><a name="line1740"></a>1740                   return if record.id.to_s != join.parent.record_id(row).to_s or row[join.aliased_primary_key].nil?
</span><span class="uncovered0"><a name="line1741"></a>1741                   association = join.instantiate(row)
</span><span class="uncovered1"><a name="line1742"></a>1742                   record.send(&quot;set_#{join.reflection.name}_target&quot;, association)
</span><span class="uncovered0"><a name="line1743"></a>1743                 else
</span><span class="uncovered1"><a name="line1744"></a>1744                   raise ConfigurationError, &quot;unknown macro: #{join.reflection.macro}&quot;
</span><span class="uncovered0"><a name="line1745"></a>1745               end
</span><span class="uncovered1"><a name="line1746"></a>1746               return association
</span><span class="uncovered0"><a name="line1747"></a>1747             end
</span><span class="inferred1"><a name="line1748"></a>1748 
</span><span class="marked0"><a name="line1749"></a>1749           class JoinBase # :nodoc:
</span><span class="marked1"><a name="line1750"></a>1750             attr_reader :active_record, :table_joins
</span><span class="marked0"><a name="line1751"></a>1751             delegate    :table_name, :column_names, :primary_key, :reflections, :sanitize_sql, :to =&gt; :active_record
</span><span class="inferred1"><a name="line1752"></a>1752 
</span><span class="marked0"><a name="line1753"></a>1753             def initialize(active_record, joins = nil)
</span><span class="uncovered1"><a name="line1754"></a>1754               @active_record = active_record
</span><span class="uncovered0"><a name="line1755"></a>1755               @cached_record = {}
</span><span class="uncovered1"><a name="line1756"></a>1756               @table_joins   = joins
</span><span class="uncovered0"><a name="line1757"></a>1757             end
</span><span class="inferred1"><a name="line1758"></a>1758 
</span><span class="marked0"><a name="line1759"></a>1759             def aliased_prefix
</span><span class="uncovered1"><a name="line1760"></a>1760               &quot;t0&quot;
</span><span class="uncovered0"><a name="line1761"></a>1761             end
</span><span class="inferred1"><a name="line1762"></a>1762 
</span><span class="marked0"><a name="line1763"></a>1763             def aliased_primary_key
</span><span class="uncovered1"><a name="line1764"></a>1764               &quot;#{ aliased_prefix }_r0&quot;
</span><span class="uncovered0"><a name="line1765"></a>1765             end
</span><span class="inferred1"><a name="line1766"></a>1766 
</span><span class="marked0"><a name="line1767"></a>1767             def aliased_table_name
</span><span class="uncovered1"><a name="line1768"></a>1768               active_record.table_name
</span><span class="uncovered0"><a name="line1769"></a>1769             end
</span><span class="inferred1"><a name="line1770"></a>1770 
</span><span class="marked0"><a name="line1771"></a>1771             def column_names_with_alias
</span><span class="uncovered1"><a name="line1772"></a>1772               unless defined?(@column_names_with_alias)
</span><span class="uncovered0"><a name="line1773"></a>1773                 @column_names_with_alias = []
</span><span class="uncovered1"><a name="line1774"></a>1774 
</span><span class="uncovered0"><a name="line1775"></a>1775                 ([primary_key] + (column_names - [primary_key])).each_with_index do |column_name, i|
</span><span class="uncovered1"><a name="line1776"></a>1776                   @column_names_with_alias &lt;&lt; [column_name, &quot;#{ aliased_prefix }_r#{ i }&quot;]
</span><span class="uncovered0"><a name="line1777"></a>1777                 end
</span><span class="uncovered1"><a name="line1778"></a>1778               end
</span><span class="uncovered0"><a name="line1779"></a>1779 
</span><span class="uncovered1"><a name="line1780"></a>1780               @column_names_with_alias
</span><span class="uncovered0"><a name="line1781"></a>1781             end
</span><span class="inferred1"><a name="line1782"></a>1782 
</span><span class="marked0"><a name="line1783"></a>1783             def extract_record(row)
</span><span class="uncovered1"><a name="line1784"></a>1784               column_names_with_alias.inject({}){|record, (cn, an)| record[cn] = row[an]; record}
</span><span class="uncovered0"><a name="line1785"></a>1785             end
</span><span class="inferred1"><a name="line1786"></a>1786 
</span><span class="marked0"><a name="line1787"></a>1787             def record_id(row)
</span><span class="uncovered1"><a name="line1788"></a>1788               row[aliased_primary_key]
</span><span class="uncovered0"><a name="line1789"></a>1789             end
</span><span class="inferred1"><a name="line1790"></a>1790 
</span><span class="marked0"><a name="line1791"></a>1791             def instantiate(row)
</span><span class="uncovered1"><a name="line1792"></a>1792               @cached_record[record_id(row)] ||= active_record.send(:instantiate, extract_record(row))
</span><span class="uncovered0"><a name="line1793"></a>1793             end
</span><span class="uncovered1"><a name="line1794"></a>1794           end
</span><span class="inferred0"><a name="line1795"></a>1795 
</span><span class="marked1"><a name="line1796"></a>1796           class JoinAssociation &lt; JoinBase # :nodoc:
</span><span class="marked0"><a name="line1797"></a>1797             attr_reader :reflection, :parent, :aliased_table_name, :aliased_prefix, :aliased_join_table_name, :parent_table_name
</span><span class="marked1"><a name="line1798"></a>1798             delegate    :options, :klass, :through_reflection, :source_reflection, :to =&gt; :reflection
</span><span class="inferred0"><a name="line1799"></a>1799 
</span><span class="marked1"><a name="line1800"></a>1800             def initialize(reflection, join_dependency, parent = nil)
</span><span class="uncovered0"><a name="line1801"></a>1801               reflection.check_validity!
</span><span class="uncovered1"><a name="line1802"></a>1802               if reflection.options[:polymorphic]
</span><span class="uncovered0"><a name="line1803"></a>1803                 raise EagerLoadPolymorphicError.new(reflection)
</span><span class="uncovered1"><a name="line1804"></a>1804               end
</span><span class="uncovered0"><a name="line1805"></a>1805 
</span><span class="uncovered1"><a name="line1806"></a>1806               super(reflection.klass)
</span><span class="uncovered0"><a name="line1807"></a>1807               @join_dependency    = join_dependency
</span><span class="uncovered1"><a name="line1808"></a>1808               @parent             = parent
</span><span class="uncovered0"><a name="line1809"></a>1809               @reflection         = reflection
</span><span class="uncovered1"><a name="line1810"></a>1810               @aliased_prefix     = &quot;t#{ join_dependency.joins.size }&quot;
</span><span class="uncovered0"><a name="line1811"></a>1811               @parent_table_name  = parent.active_record.table_name
</span><span class="uncovered1"><a name="line1812"></a>1812               @aliased_table_name = aliased_table_name_for(table_name)
</span><span class="uncovered0"><a name="line1813"></a>1813               
</span><span class="uncovered1"><a name="line1814"></a>1814               if reflection.macro == :has_and_belongs_to_many
</span><span class="uncovered0"><a name="line1815"></a>1815                 @aliased_join_table_name = aliased_table_name_for(reflection.options[:join_table], &quot;_join&quot;)
</span><span class="uncovered1"><a name="line1816"></a>1816               end
</span><span class="uncovered0"><a name="line1817"></a>1817         
</span><span class="uncovered1"><a name="line1818"></a>1818               if [:has_many, :has_one].include?(reflection.macro) &amp;&amp; reflection.options[:through]
</span><span class="uncovered0"><a name="line1819"></a>1819                 @aliased_join_table_name = aliased_table_name_for(reflection.through_reflection.klass.table_name, &quot;_join&quot;)
</span><span class="uncovered1"><a name="line1820"></a>1820               end
</span><span class="uncovered0"><a name="line1821"></a>1821             end
</span><span class="inferred1"><a name="line1822"></a>1822 
</span><span class="marked0"><a name="line1823"></a>1823             def association_join
</span><span class="uncovered1"><a name="line1824"></a>1824               connection = reflection.active_record.connection
</span><span class="uncovered0"><a name="line1825"></a>1825               join = case reflection.macro
</span><span class="uncovered1"><a name="line1826"></a>1826                 when :has_and_belongs_to_many
</span><span class="uncovered0"><a name="line1827"></a>1827                   &quot; #{join_type} %s ON %s.%s = %s.%s &quot; % [
</span><span class="uncovered1"><a name="line1828"></a>1828                      table_alias_for(options[:join_table], aliased_join_table_name),
</span><span class="uncovered0"><a name="line1829"></a>1829                      connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered1"><a name="line1830"></a>1830                      options[:foreign_key] || reflection.active_record.to_s.foreign_key,
</span><span class="uncovered0"><a name="line1831"></a>1831                      connection.quote_table_name(parent.aliased_table_name),
</span><span class="uncovered1"><a name="line1832"></a>1832                      reflection.active_record.primary_key] +
</span><span class="uncovered0"><a name="line1833"></a>1833                   &quot; #{join_type} %s ON %s.%s = %s.%s &quot; % [
</span><span class="uncovered1"><a name="line1834"></a>1834                      table_name_and_alias,
</span><span class="uncovered0"><a name="line1835"></a>1835                      connection.quote_table_name(aliased_table_name),
</span><span class="uncovered1"><a name="line1836"></a>1836                      klass.primary_key,
</span><span class="uncovered0"><a name="line1837"></a>1837                      connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered1"><a name="line1838"></a>1838                      options[:association_foreign_key] || klass.to_s.foreign_key
</span><span class="uncovered0"><a name="line1839"></a>1839                      ]
</span><span class="uncovered1"><a name="line1840"></a>1840                 when :has_many, :has_one
</span><span class="uncovered0"><a name="line1841"></a>1841                   case
</span><span class="uncovered1"><a name="line1842"></a>1842                     when reflection.options[:through]
</span><span class="uncovered0"><a name="line1843"></a>1843                       through_conditions = through_reflection.options[:conditions] ? &quot;AND #{interpolate_sql(sanitize_sql(through_reflection.options[:conditions]))}&quot; : ''
</span><span class="uncovered1"><a name="line1844"></a>1844 
</span><span class="uncovered0"><a name="line1845"></a>1845                       jt_foreign_key = jt_as_extra = jt_source_extra = jt_sti_extra = nil
</span><span class="uncovered1"><a name="line1846"></a>1846                       first_key = second_key = as_extra = nil
</span><span class="uncovered0"><a name="line1847"></a>1847 
</span><span class="uncovered1"><a name="line1848"></a>1848                       if through_reflection.options[:as] # has_many :through against a polymorphic join
</span><span class="uncovered0"><a name="line1849"></a>1849                         jt_foreign_key = through_reflection.options[:as].to_s + '_id'
</span><span class="uncovered1"><a name="line1850"></a>1850                         jt_as_extra = &quot; AND %s.%s = %s&quot; % [
</span><span class="uncovered0"><a name="line1851"></a>1851                           connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered1"><a name="line1852"></a>1852                           connection.quote_column_name(through_reflection.options[:as].to_s + '_type'),
</span><span class="uncovered0"><a name="line1853"></a>1853                           klass.quote_value(parent.active_record.base_class.name)
</span><span class="uncovered1"><a name="line1854"></a>1854                         ]
</span><span class="uncovered0"><a name="line1855"></a>1855                       else
</span><span class="uncovered1"><a name="line1856"></a>1856                         jt_foreign_key = through_reflection.primary_key_name
</span><span class="uncovered0"><a name="line1857"></a>1857                       end
</span><span class="uncovered1"><a name="line1858"></a>1858 
</span><span class="uncovered0"><a name="line1859"></a>1859                       case source_reflection.macro
</span><span class="uncovered1"><a name="line1860"></a>1860                       when :has_many
</span><span class="uncovered0"><a name="line1861"></a>1861                         if source_reflection.options[:as]
</span><span class="uncovered1"><a name="line1862"></a>1862                           first_key   = &quot;#{source_reflection.options[:as]}_id&quot;
</span><span class="uncovered0"><a name="line1863"></a>1863                           second_key  = options[:foreign_key] || primary_key
</span><span class="uncovered1"><a name="line1864"></a>1864                           as_extra    = &quot; AND %s.%s = %s&quot; % [
</span><span class="uncovered0"><a name="line1865"></a>1865                             connection.quote_table_name(aliased_table_name),
</span><span class="uncovered1"><a name="line1866"></a>1866                             connection.quote_column_name(&quot;#{source_reflection.options[:as]}_type&quot;),
</span><span class="uncovered0"><a name="line1867"></a>1867                             klass.quote_value(source_reflection.active_record.base_class.name)
</span><span class="uncovered1"><a name="line1868"></a>1868                           ]
</span><span class="uncovered0"><a name="line1869"></a>1869                         else
</span><span class="uncovered1"><a name="line1870"></a>1870                           first_key   = through_reflection.klass.base_class.to_s.foreign_key
</span><span class="uncovered0"><a name="line1871"></a>1871                           second_key  = options[:foreign_key] || primary_key
</span><span class="uncovered1"><a name="line1872"></a>1872                         end
</span><span class="uncovered0"><a name="line1873"></a>1873 
</span><span class="uncovered1"><a name="line1874"></a>1874                         unless through_reflection.klass.descends_from_active_record?
</span><span class="uncovered0"><a name="line1875"></a>1875                           jt_sti_extra = &quot; AND %s.%s = %s&quot; % [
</span><span class="uncovered1"><a name="line1876"></a>1876                             connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered0"><a name="line1877"></a>1877                             connection.quote_column_name(through_reflection.active_record.inheritance_column),
</span><span class="uncovered1"><a name="line1878"></a>1878                             through_reflection.klass.quote_value(through_reflection.klass.sti_name)]
</span><span class="uncovered0"><a name="line1879"></a>1879                         end
</span><span class="uncovered1"><a name="line1880"></a>1880                       when :belongs_to
</span><span class="uncovered0"><a name="line1881"></a>1881                         first_key = primary_key
</span><span class="uncovered1"><a name="line1882"></a>1882                         if reflection.options[:source_type]
</span><span class="uncovered0"><a name="line1883"></a>1883                           second_key = source_reflection.association_foreign_key
</span><span class="uncovered1"><a name="line1884"></a>1884                           jt_source_extra = &quot; AND %s.%s = %s&quot; % [
</span><span class="uncovered0"><a name="line1885"></a>1885                             connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered1"><a name="line1886"></a>1886                             connection.quote_column_name(reflection.source_reflection.options[:foreign_type]),
</span><span class="uncovered0"><a name="line1887"></a>1887                             klass.quote_value(reflection.options[:source_type])
</span><span class="uncovered1"><a name="line1888"></a>1888                           ]
</span><span class="uncovered0"><a name="line1889"></a>1889                         else
</span><span class="uncovered1"><a name="line1890"></a>1890                           second_key = source_reflection.primary_key_name
</span><span class="uncovered0"><a name="line1891"></a>1891                         end
</span><span class="uncovered1"><a name="line1892"></a>1892                       end
</span><span class="uncovered0"><a name="line1893"></a>1893 
</span><span class="uncovered1"><a name="line1894"></a>1894                       &quot; #{join_type} %s ON (%s.%s = %s.%s%s%s%s) &quot; % [
</span><span class="uncovered0"><a name="line1895"></a>1895                         table_alias_for(through_reflection.klass.table_name, aliased_join_table_name),
</span><span class="uncovered1"><a name="line1896"></a>1896                         connection.quote_table_name(parent.aliased_table_name),
</span><span class="uncovered0"><a name="line1897"></a>1897                         connection.quote_column_name(parent.primary_key),
</span><span class="uncovered1"><a name="line1898"></a>1898                         connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered0"><a name="line1899"></a>1899                         connection.quote_column_name(jt_foreign_key),
</span><span class="uncovered1"><a name="line1900"></a>1900                         jt_as_extra, jt_source_extra, jt_sti_extra
</span><span class="uncovered0"><a name="line1901"></a>1901                       ] +
</span><span class="uncovered1"><a name="line1902"></a>1902                       &quot; #{join_type} %s ON (%s.%s = %s.%s%s) &quot; % [
</span><span class="uncovered0"><a name="line1903"></a>1903                         table_name_and_alias,
</span><span class="uncovered1"><a name="line1904"></a>1904                         connection.quote_table_name(aliased_table_name),
</span><span class="uncovered0"><a name="line1905"></a>1905                         connection.quote_column_name(first_key),
</span><span class="uncovered1"><a name="line1906"></a>1906                         connection.quote_table_name(aliased_join_table_name),
</span><span class="uncovered0"><a name="line1907"></a>1907                         connection.quote_column_name(second_key),
</span><span class="uncovered1"><a name="line1908"></a>1908                         as_extra
</span><span class="uncovered0"><a name="line1909"></a>1909                       ]
</span><span class="uncovered1"><a name="line1910"></a>1910 
</span><span class="uncovered0"><a name="line1911"></a>1911                     when reflection.options[:as] &amp;&amp; [:has_many, :has_one].include?(reflection.macro)
</span><span class="uncovered1"><a name="line1912"></a>1912                       &quot; #{join_type} %s ON %s.%s = %s.%s AND %s.%s = %s&quot; % [
</span><span class="uncovered0"><a name="line1913"></a>1913                         table_name_and_alias,
</span><span class="uncovered1"><a name="line1914"></a>1914                         connection.quote_table_name(aliased_table_name),
</span><span class="uncovered0"><a name="line1915"></a>1915                         &quot;#{reflection.options[:as]}_id&quot;,
</span><span class="uncovered1"><a name="line1916"></a>1916                         connection.quote_table_name(parent.aliased_table_name),
</span><span class="uncovered0"><a name="line1917"></a>1917                         parent.primary_key,
</span><span class="uncovered1"><a name="line1918"></a>1918                         connection.quote_table_name(aliased_table_name),
</span><span class="uncovered0"><a name="line1919"></a>1919                         &quot;#{reflection.options[:as]}_type&quot;,
</span><span class="uncovered1"><a name="line1920"></a>1920                         klass.quote_value(parent.active_record.base_class.name)
</span><span class="uncovered0"><a name="line1921"></a>1921                       ]
</span><span class="uncovered1"><a name="line1922"></a>1922                     else
</span><span class="uncovered0"><a name="line1923"></a>1923                       foreign_key = options[:foreign_key] || reflection.active_record.name.foreign_key
</span><span class="uncovered1"><a name="line1924"></a>1924                       &quot; #{join_type} %s ON %s.%s = %s.%s &quot; % [
</span><span class="uncovered0"><a name="line1925"></a>1925                         table_name_and_alias,
</span><span class="uncovered1"><a name="line1926"></a>1926                         aliased_table_name,
</span><span class="uncovered0"><a name="line1927"></a>1927                         foreign_key,
</span><span class="uncovered1"><a name="line1928"></a>1928                         parent.aliased_table_name,
</span><span class="uncovered0"><a name="line1929"></a>1929                         parent.primary_key
</span><span class="uncovered1"><a name="line1930"></a>1930                       ]
</span><span class="uncovered0"><a name="line1931"></a>1931                   end
</span><span class="uncovered1"><a name="line1932"></a>1932                 when :belongs_to
</span><span class="uncovered0"><a name="line1933"></a>1933                   &quot; #{join_type} %s ON %s.%s = %s.%s &quot; % [
</span><span class="uncovered1"><a name="line1934"></a>1934                      table_name_and_alias,
</span><span class="uncovered0"><a name="line1935"></a>1935                      connection.quote_table_name(aliased_table_name),
</span><span class="uncovered1"><a name="line1936"></a>1936                      reflection.klass.primary_key,
</span><span class="uncovered0"><a name="line1937"></a>1937                      connection.quote_table_name(parent.aliased_table_name),
</span><span class="uncovered1"><a name="line1938"></a>1938                      options[:foreign_key] || reflection.primary_key_name
</span><span class="uncovered0"><a name="line1939"></a>1939                     ]
</span><span class="uncovered1"><a name="line1940"></a>1940                 else
</span><span class="uncovered0"><a name="line1941"></a>1941                   &quot;&quot;
</span><span class="uncovered1"><a name="line1942"></a>1942               end || ''
</span><span class="uncovered0"><a name="line1943"></a>1943               join &lt;&lt; %(AND %s) % [
</span><span class="uncovered1"><a name="line1944"></a>1944                 klass.send(:type_condition, aliased_table_name)] unless klass.descends_from_active_record?
</span><span class="uncovered0"><a name="line1945"></a>1945 
</span><span class="uncovered1"><a name="line1946"></a>1946               [through_reflection, reflection].each do |ref|
</span><span class="uncovered0"><a name="line1947"></a>1947                 join &lt;&lt; &quot;AND #{interpolate_sql(sanitize_sql(ref.options[:conditions]))} &quot; if ref &amp;&amp; ref.options[:conditions]
</span><span class="uncovered1"><a name="line1948"></a>1948               end
</span><span class="uncovered0"><a name="line1949"></a>1949 
</span><span class="uncovered1"><a name="line1950"></a>1950               join
</span><span class="uncovered0"><a name="line1951"></a>1951             end
</span><span class="inferred1"><a name="line1952"></a>1952 
</span><span class="marked0"><a name="line1953"></a>1953             protected
</span><span class="inferred1"><a name="line1954"></a>1954             
</span><span class="marked0"><a name="line1955"></a>1955               def aliased_table_name_for(name, suffix = nil)
</span><span class="uncovered1"><a name="line1956"></a>1956                 if !parent.table_joins.blank? &amp;&amp; parent.table_joins.to_s.downcase =~ %r{join(\s+\w+)?\s+#{name.downcase}\son}
</span><span class="uncovered0"><a name="line1957"></a>1957                   @join_dependency.table_aliases[name] += 1
</span><span class="uncovered1"><a name="line1958"></a>1958                 end
</span><span class="uncovered0"><a name="line1959"></a>1959 
</span><span class="uncovered1"><a name="line1960"></a>1960                 unless @join_dependency.table_aliases[name].zero?
</span><span class="uncovered0"><a name="line1961"></a>1961                   # if the table name has been used, then use an alias
</span><span class="uncovered1"><a name="line1962"></a>1962                   name = active_record.connection.table_alias_for &quot;#{pluralize(reflection.name)}_#{parent_table_name}#{suffix}&quot;
</span><span class="uncovered0"><a name="line1963"></a>1963                   table_index = @join_dependency.table_aliases[name]
</span><span class="uncovered1"><a name="line1964"></a>1964                   @join_dependency.table_aliases[name] += 1
</span><span class="uncovered0"><a name="line1965"></a>1965                   name = name[0..active_record.connection.table_alias_length-3] + &quot;_#{table_index+1}&quot; if table_index &gt; 0
</span><span class="uncovered1"><a name="line1966"></a>1966                 else
</span><span class="uncovered0"><a name="line1967"></a>1967                   @join_dependency.table_aliases[name] += 1
</span><span class="uncovered1"><a name="line1968"></a>1968                 end
</span><span class="uncovered0"><a name="line1969"></a>1969 
</span><span class="uncovered1"><a name="line1970"></a>1970                 name
</span><span class="uncovered0"><a name="line1971"></a>1971               end
</span><span class="inferred1"><a name="line1972"></a>1972               
</span><span class="marked0"><a name="line1973"></a>1973               def pluralize(table_name)
</span><span class="uncovered1"><a name="line1974"></a>1974                 ActiveRecord::Base.pluralize_table_names ? table_name.to_s.pluralize : table_name
</span><span class="uncovered0"><a name="line1975"></a>1975               end
</span><span class="inferred1"><a name="line1976"></a>1976 
</span><span class="marked0"><a name="line1977"></a>1977               def table_alias_for(table_name, table_alias)
</span><span class="uncovered1"><a name="line1978"></a>1978                  &quot;#{reflection.active_record.connection.quote_table_name(table_name)} #{table_alias if table_name != table_alias}&quot;.strip
</span><span class="uncovered0"><a name="line1979"></a>1979               end
</span><span class="inferred1"><a name="line1980"></a>1980 
</span><span class="marked0"><a name="line1981"></a>1981               def table_name_and_alias
</span><span class="uncovered1"><a name="line1982"></a>1982                 table_alias_for table_name, @aliased_table_name
</span><span class="uncovered0"><a name="line1983"></a>1983               end
</span><span class="inferred1"><a name="line1984"></a>1984 
</span><span class="marked0"><a name="line1985"></a>1985               def interpolate_sql(sql)
</span><span class="uncovered1"><a name="line1986"></a>1986                 instance_eval(&quot;%@#{sql.gsub('@', '\@')}@&quot;)
</span><span class="uncovered0"><a name="line1987"></a>1987               end
</span><span class="inferred1"><a name="line1988"></a>1988 
</span><span class="marked0"><a name="line1989"></a>1989             private
</span><span class="marked1"><a name="line1990"></a>1990               def join_type
</span><span class="uncovered0"><a name="line1991"></a>1991                 &quot;LEFT OUTER JOIN&quot;
</span><span class="uncovered1"><a name="line1992"></a>1992               end
</span><span class="uncovered0"><a name="line1993"></a>1993           end
</span><span class="uncovered1"><a name="line1994"></a>1994         end
</span><span class="inferred0"><a name="line1995"></a>1995 
</span><span class="marked1"><a name="line1996"></a>1996         class InnerJoinDependency &lt; JoinDependency # :nodoc:
</span><span class="marked0"><a name="line1997"></a>1997           protected
</span><span class="marked1"><a name="line1998"></a>1998             def build_join_association(reflection, parent)
</span><span class="uncovered0"><a name="line1999"></a>1999               InnerJoinAssociation.new(reflection, self, parent)
</span><span class="uncovered1"><a name="line2000"></a>2000             end
</span><span class="inferred0"><a name="line2001"></a>2001 
</span><span class="marked1"><a name="line2002"></a>2002           class InnerJoinAssociation &lt; JoinAssociation
</span><span class="marked0"><a name="line2003"></a>2003             private
</span><span class="marked1"><a name="line2004"></a>2004               def join_type
</span><span class="uncovered0"><a name="line2005"></a>2005                 &quot;INNER JOIN&quot;
</span><span class="uncovered1"><a name="line2006"></a>2006               end
</span><span class="uncovered0"><a name="line2007"></a>2007           end
</span><span class="uncovered1"><a name="line2008"></a>2008         end
</span><span class="uncovered0"><a name="line2009"></a>2009 
</span><span class="uncovered1"><a name="line2010"></a>2010     end
</span><span class="uncovered0"><a name="line2011"></a>2011   end
</span><span class="uncovered1"><a name="line2012"></a>2012 end
</span></pre><hr/>
    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a>
   version 0.8.1.2.</p>
<p><a href='http://validator.w3.org/check/referer'><img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88'/>
        </a>
      <a href='http://jigsaw.w3.org/css-validator/check/referer'><img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px'/>
        </a>
      </p>
    </body>
  </html>
