<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'><head><title>/Library/Ruby/Gems/1.8/gems/activerecord-2.1.1/lib/active_record/base.rb - C0 code coverage information</title>
    <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
    <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(175, 200, 200);
 display: block;
}
span.inferred1 {
 background-color: rgb(180, 205, 205);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
    <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;
    
    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }
  
  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
    <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
    </head>
  <body><h3>C0 code coverage information</h3>
    <p>Generated on Tue Nov 11 15:30:12 -0500 2008 with <a href='http://eigenclass.org/hiki/rcov'>rcov 0.8.1.2</a>
      </p>
    <hr/>
    <pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>                       
<table class='report'><thead><tr><td class='heading'>Name</td>
      <td class='heading'>Total lines</td>
      <td class='heading'>Lines of code</td>
      <td class='heading'>Total coverage</td>
      <td class='heading'>Code coverage</td>
      </tr>
    </thead>
  <tbody><tr class='light'><td><a href='-Library-Ruby-Gems-1_8-gems-activerecord-2_1_1-lib-active_record-base_rb.html'>/Library/Ruby/Gems/1.8/gems/activerecord-2.1.1/lib/active_record/base.rb</a>
        </td>
      <td class='lines_total'><tt>2744</tt>
        </td>
      <td class='lines_code'><tt>1350</tt>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_total'>60.2%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='60'/>
                  <td class='uncovered' width='40'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_code'>25.7%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='26'/>
                  <td class='uncovered' width='74'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </tbody>
  </table>
<pre><span class="marked0"><a name="line1"></a>   1 require 'yaml'
</span><span class="marked1"><a name="line2"></a>   2 require 'set'
</span><span class="inferred0"><a name="line3"></a>   3 
</span><span class="marked1"><a name="line4"></a>   4 module ActiveRecord #:nodoc:
</span><span class="inferred0"><a name="line5"></a>   5   # Generic Active Record exception class.
</span><span class="marked1"><a name="line6"></a>   6   class ActiveRecordError &lt; StandardError
</span><span class="inferred0"><a name="line7"></a>   7   end
</span><span class="inferred1"><a name="line8"></a>   8 
</span><span class="inferred0"><a name="line9"></a>   9   # Raised when the single-table inheritance mechanism failes to locate the subclass
</span><span class="inferred1"><a name="line10"></a>  10   # (for example due to improper usage of column that +inheritance_column+ points to).
</span><span class="marked0"><a name="line11"></a>  11   class SubclassNotFound &lt; ActiveRecordError #:nodoc:
</span><span class="inferred1"><a name="line12"></a>  12   end
</span><span class="inferred0"><a name="line13"></a>  13 
</span><span class="inferred1"><a name="line14"></a>  14   # Raised when an object assigned to an association has an incorrect type.
</span><span class="inferred0"><a name="line15"></a>  15   #
</span><span class="inferred1"><a name="line16"></a>  16   #   class Ticket &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line17"></a>  17   #     has_many :patches
</span><span class="inferred1"><a name="line18"></a>  18   #   end
</span><span class="inferred0"><a name="line19"></a>  19   #
</span><span class="inferred1"><a name="line20"></a>  20   #   class Patch &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line21"></a>  21   #     belongs_to :ticket
</span><span class="inferred1"><a name="line22"></a>  22   #   end
</span><span class="inferred0"><a name="line23"></a>  23   #
</span><span class="inferred1"><a name="line24"></a>  24   #   # Comments are not patches, this assignment raises AssociationTypeMismatch.
</span><span class="inferred0"><a name="line25"></a>  25   #   @ticket.patches &lt;&lt; Comment.new(:content =&gt; &quot;Please attach tests to your patch.&quot;)
</span><span class="marked1"><a name="line26"></a>  26   class AssociationTypeMismatch &lt; ActiveRecordError
</span><span class="inferred0"><a name="line27"></a>  27   end
</span><span class="inferred1"><a name="line28"></a>  28 
</span><span class="inferred0"><a name="line29"></a>  29   # Raised when unserialized object's type mismatches one specified for serializable field.
</span><span class="marked1"><a name="line30"></a>  30   class SerializationTypeMismatch &lt; ActiveRecordError
</span><span class="inferred0"><a name="line31"></a>  31   end
</span><span class="inferred1"><a name="line32"></a>  32 
</span><span class="inferred0"><a name="line33"></a>  33   # Raised when adapter not specified on connection (or configuration file &lt;tt&gt;config/database.yml&lt;/tt&gt; misses adapter field).
</span><span class="marked1"><a name="line34"></a>  34   class AdapterNotSpecified &lt; ActiveRecordError
</span><span class="inferred0"><a name="line35"></a>  35   end
</span><span class="inferred1"><a name="line36"></a>  36 
</span><span class="inferred0"><a name="line37"></a>  37   # Raised when Active Record cannot find database adapter specified in &lt;tt&gt;config/database.yml&lt;/tt&gt; or programmatically.
</span><span class="marked1"><a name="line38"></a>  38   class AdapterNotFound &lt; ActiveRecordError
</span><span class="inferred0"><a name="line39"></a>  39   end
</span><span class="inferred1"><a name="line40"></a>  40 
</span><span class="inferred0"><a name="line41"></a>  41   # Raised when connection to the database could not been established (for example when &lt;tt&gt;connection=&lt;/tt&gt; is given a nil object).
</span><span class="marked1"><a name="line42"></a>  42   class ConnectionNotEstablished &lt; ActiveRecordError
</span><span class="inferred0"><a name="line43"></a>  43   end
</span><span class="inferred1"><a name="line44"></a>  44 
</span><span class="inferred0"><a name="line45"></a>  45   # Raised when Active Record cannot find record by given id or set of ids.
</span><span class="marked1"><a name="line46"></a>  46   class RecordNotFound &lt; ActiveRecordError
</span><span class="inferred0"><a name="line47"></a>  47   end
</span><span class="inferred1"><a name="line48"></a>  48 
</span><span class="inferred0"><a name="line49"></a>  49   # Raised by ActiveRecord::Base.save! and ActiveRecord::Base.create! methods when record cannot be
</span><span class="inferred1"><a name="line50"></a>  50   # saved because record is invalid.
</span><span class="marked0"><a name="line51"></a>  51   class RecordNotSaved &lt; ActiveRecordError
</span><span class="inferred1"><a name="line52"></a>  52   end
</span><span class="inferred0"><a name="line53"></a>  53 
</span><span class="inferred1"><a name="line54"></a>  54   # Raised when SQL statement cannot be executed by the database (for example, it's often the case for MySQL when Ruby driver used is too old).
</span><span class="marked0"><a name="line55"></a>  55   class StatementInvalid &lt; ActiveRecordError
</span><span class="inferred1"><a name="line56"></a>  56   end
</span><span class="inferred0"><a name="line57"></a>  57 
</span><span class="inferred1"><a name="line58"></a>  58   # Raised when number of bind variables in statement given to &lt;tt&gt;:condition&lt;/tt&gt; key (for example, when using +find+ method)
</span><span class="inferred0"><a name="line59"></a>  59   # does not match number of expected variables.
</span><span class="inferred1"><a name="line60"></a>  60   #
</span><span class="inferred0"><a name="line61"></a>  61   # For example, in
</span><span class="inferred1"><a name="line62"></a>  62   #
</span><span class="inferred0"><a name="line63"></a>  63   #   Location.find :all, :conditions =&gt; [&quot;lat = ? AND lng = ?&quot;, 53.7362]
</span><span class="inferred1"><a name="line64"></a>  64   #
</span><span class="inferred0"><a name="line65"></a>  65   # two placeholders are given but only one variable to fill them.
</span><span class="marked1"><a name="line66"></a>  66   class PreparedStatementInvalid &lt; ActiveRecordError
</span><span class="inferred0"><a name="line67"></a>  67   end
</span><span class="inferred1"><a name="line68"></a>  68 
</span><span class="inferred0"><a name="line69"></a>  69   # Raised on attempt to save stale record. Record is stale when it's being saved in another query after
</span><span class="inferred1"><a name="line70"></a>  70   # instantiation, for example, when two users edit the same wiki page and one starts editing and saves
</span><span class="inferred0"><a name="line71"></a>  71   # the page before the other.
</span><span class="inferred1"><a name="line72"></a>  72   #
</span><span class="inferred0"><a name="line73"></a>  73   # Read more about optimistic locking in ActiveRecord::Locking module RDoc.
</span><span class="marked1"><a name="line74"></a>  74   class StaleObjectError &lt; ActiveRecordError
</span><span class="inferred0"><a name="line75"></a>  75   end
</span><span class="inferred1"><a name="line76"></a>  76 
</span><span class="inferred0"><a name="line77"></a>  77   # Raised when association is being configured improperly or
</span><span class="inferred1"><a name="line78"></a>  78   # user tries to use offset and limit together with has_many or has_and_belongs_to_many associations.
</span><span class="marked0"><a name="line79"></a>  79   class ConfigurationError &lt; ActiveRecordError
</span><span class="inferred1"><a name="line80"></a>  80   end
</span><span class="inferred0"><a name="line81"></a>  81 
</span><span class="inferred1"><a name="line82"></a>  82   # Raised on attempt to update record that is instantiated as read only.
</span><span class="marked0"><a name="line83"></a>  83   class ReadOnlyRecord &lt; ActiveRecordError
</span><span class="inferred1"><a name="line84"></a>  84   end
</span><span class="inferred0"><a name="line85"></a>  85 
</span><span class="inferred1"><a name="line86"></a>  86   # Used by Active Record transaction mechanism to distinguish rollback from other exceptional situations.
</span><span class="inferred0"><a name="line87"></a>  87   # You can use it to roll your transaction back explicitly in the block passed to +transaction+ method.
</span><span class="marked1"><a name="line88"></a>  88   class Rollback &lt; ActiveRecordError
</span><span class="inferred0"><a name="line89"></a>  89   end
</span><span class="inferred1"><a name="line90"></a>  90 
</span><span class="inferred0"><a name="line91"></a>  91   # Raised when attribute has a name reserved by Active Record (when attribute has name of one of Active Record instance methods).
</span><span class="marked1"><a name="line92"></a>  92   class DangerousAttributeError &lt; ActiveRecordError
</span><span class="inferred0"><a name="line93"></a>  93   end
</span><span class="inferred1"><a name="line94"></a>  94 
</span><span class="inferred0"><a name="line95"></a>  95   # Raised when you've tried to access a column which wasn't loaded by your finder.
</span><span class="inferred1"><a name="line96"></a>  96   # Typically this is because &lt;tt&gt;:select&lt;/tt&gt; has been specified.
</span><span class="marked0"><a name="line97"></a>  97   class MissingAttributeError &lt; NoMethodError
</span><span class="inferred1"><a name="line98"></a>  98   end
</span><span class="inferred0"><a name="line99"></a>  99 
</span><span class="inferred1"><a name="line100"></a> 100   # Raised when an error occured while doing a mass assignment to an attribute through the
</span><span class="inferred0"><a name="line101"></a> 101   # &lt;tt&gt;attributes=&lt;/tt&gt; method. The exception has an +attribute+ property that is the name of the
</span><span class="inferred1"><a name="line102"></a> 102   # offending attribute.
</span><span class="marked0"><a name="line103"></a> 103   class AttributeAssignmentError &lt; ActiveRecordError
</span><span class="marked1"><a name="line104"></a> 104     attr_reader :exception, :attribute
</span><span class="marked0"><a name="line105"></a> 105     def initialize(message, exception, attribute)
</span><span class="uncovered1"><a name="line106"></a> 106       @exception = exception
</span><span class="uncovered0"><a name="line107"></a> 107       @attribute = attribute
</span><span class="uncovered1"><a name="line108"></a> 108       @message = message
</span><span class="uncovered0"><a name="line109"></a> 109     end
</span><span class="uncovered1"><a name="line110"></a> 110   end
</span><span class="inferred0"><a name="line111"></a> 111 
</span><span class="inferred1"><a name="line112"></a> 112   # Raised when there are multiple errors while doing a mass assignment through the +attributes+
</span><span class="inferred0"><a name="line113"></a> 113   # method. The exception has an +errors+ property that contains an array of AttributeAssignmentError
</span><span class="inferred1"><a name="line114"></a> 114   # objects, each corresponding to the error while assigning to an attribute.
</span><span class="marked0"><a name="line115"></a> 115   class MultiparameterAssignmentErrors &lt; ActiveRecordError
</span><span class="marked1"><a name="line116"></a> 116     attr_reader :errors
</span><span class="marked0"><a name="line117"></a> 117     def initialize(errors)
</span><span class="uncovered1"><a name="line118"></a> 118       @errors = errors
</span><span class="uncovered0"><a name="line119"></a> 119     end
</span><span class="uncovered1"><a name="line120"></a> 120   end
</span><span class="inferred0"><a name="line121"></a> 121 
</span><span class="inferred1"><a name="line122"></a> 122   # Active Record objects don't specify their attributes directly, but rather infer them from the table definition with
</span><span class="inferred0"><a name="line123"></a> 123   # which they're linked. Adding, removing, and changing attributes and their type is done directly in the database. Any change
</span><span class="inferred1"><a name="line124"></a> 124   # is instantly reflected in the Active Record objects. The mapping that binds a given Active Record class to a certain
</span><span class="inferred0"><a name="line125"></a> 125   # database table will happen automatically in most common cases, but can be overwritten for the uncommon ones.
</span><span class="inferred1"><a name="line126"></a> 126   #
</span><span class="inferred0"><a name="line127"></a> 127   # See the mapping rules in table_name and the full example in link:files/README.html for more insight.
</span><span class="inferred1"><a name="line128"></a> 128   #
</span><span class="inferred0"><a name="line129"></a> 129   # == Creation
</span><span class="inferred1"><a name="line130"></a> 130   #
</span><span class="inferred0"><a name="line131"></a> 131   # Active Records accept constructor parameters either in a hash or as a block. The hash method is especially useful when
</span><span class="inferred1"><a name="line132"></a> 132   # you're receiving the data from somewhere else, like an HTTP request. It works like this:
</span><span class="inferred0"><a name="line133"></a> 133   #
</span><span class="inferred1"><a name="line134"></a> 134   #   user = User.new(:name =&gt; &quot;David&quot;, :occupation =&gt; &quot;Code Artist&quot;)
</span><span class="inferred0"><a name="line135"></a> 135   #   user.name # =&gt; &quot;David&quot;
</span><span class="inferred1"><a name="line136"></a> 136   #
</span><span class="inferred0"><a name="line137"></a> 137   # You can also use block initialization:
</span><span class="inferred1"><a name="line138"></a> 138   #
</span><span class="inferred0"><a name="line139"></a> 139   #   user = User.new do |u|
</span><span class="inferred1"><a name="line140"></a> 140   #     u.name = &quot;David&quot;
</span><span class="inferred0"><a name="line141"></a> 141   #     u.occupation = &quot;Code Artist&quot;
</span><span class="inferred1"><a name="line142"></a> 142   #   end
</span><span class="inferred0"><a name="line143"></a> 143   #
</span><span class="inferred1"><a name="line144"></a> 144   # And of course you can just create a bare object and specify the attributes after the fact:
</span><span class="inferred0"><a name="line145"></a> 145   #
</span><span class="inferred1"><a name="line146"></a> 146   #   user = User.new
</span><span class="inferred0"><a name="line147"></a> 147   #   user.name = &quot;David&quot;
</span><span class="inferred1"><a name="line148"></a> 148   #   user.occupation = &quot;Code Artist&quot;
</span><span class="inferred0"><a name="line149"></a> 149   #
</span><span class="inferred1"><a name="line150"></a> 150   # == Conditions
</span><span class="inferred0"><a name="line151"></a> 151   #
</span><span class="inferred1"><a name="line152"></a> 152   # Conditions can either be specified as a string, array, or hash representing the WHERE-part of an SQL statement.
</span><span class="inferred0"><a name="line153"></a> 153   # The array form is to be used when the condition input is tainted and requires sanitization. The string form can
</span><span class="inferred1"><a name="line154"></a> 154   # be used for statements that don't involve tainted data. The hash form works much like the array form, except
</span><span class="inferred0"><a name="line155"></a> 155   # only equality and range is possible. Examples:
</span><span class="inferred1"><a name="line156"></a> 156   #
</span><span class="inferred0"><a name="line157"></a> 157   #   class User &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line158"></a> 158   #     def self.authenticate_unsafely(user_name, password)
</span><span class="inferred0"><a name="line159"></a> 159   #       find(:first, :conditions =&gt; &quot;user_name = '#{user_name}' AND password = '#{password}'&quot;)
</span><span class="inferred1"><a name="line160"></a> 160   #     end
</span><span class="inferred0"><a name="line161"></a> 161   #
</span><span class="inferred1"><a name="line162"></a> 162   #     def self.authenticate_safely(user_name, password)
</span><span class="inferred0"><a name="line163"></a> 163   #       find(:first, :conditions =&gt; [ &quot;user_name = ? AND password = ?&quot;, user_name, password ])
</span><span class="inferred1"><a name="line164"></a> 164   #     end
</span><span class="inferred0"><a name="line165"></a> 165   #
</span><span class="inferred1"><a name="line166"></a> 166   #     def self.authenticate_safely_simply(user_name, password)
</span><span class="inferred0"><a name="line167"></a> 167   #       find(:first, :conditions =&gt; { :user_name =&gt; user_name, :password =&gt; password })
</span><span class="inferred1"><a name="line168"></a> 168   #     end
</span><span class="inferred0"><a name="line169"></a> 169   #   end
</span><span class="inferred1"><a name="line170"></a> 170   #
</span><span class="inferred0"><a name="line171"></a> 171   # The &lt;tt&gt;authenticate_unsafely&lt;/tt&gt; method inserts the parameters directly into the query and is thus susceptible to SQL-injection
</span><span class="inferred1"><a name="line172"></a> 172   # attacks if the &lt;tt&gt;user_name&lt;/tt&gt; and +password+ parameters come directly from an HTTP request. The &lt;tt&gt;authenticate_safely&lt;/tt&gt;  and
</span><span class="inferred0"><a name="line173"></a> 173   # &lt;tt&gt;authenticate_safely_simply&lt;/tt&gt; both will sanitize the &lt;tt&gt;user_name&lt;/tt&gt; and +password+ before inserting them in the query,
</span><span class="inferred1"><a name="line174"></a> 174   # which will ensure that an attacker can't escape the query and fake the login (or worse).
</span><span class="inferred0"><a name="line175"></a> 175   #
</span><span class="inferred1"><a name="line176"></a> 176   # When using multiple parameters in the conditions, it can easily become hard to read exactly what the fourth or fifth
</span><span class="inferred0"><a name="line177"></a> 177   # question mark is supposed to represent. In those cases, you can resort to named bind variables instead. That's done by replacing
</span><span class="inferred1"><a name="line178"></a> 178   # the question marks with symbols and supplying a hash with values for the matching symbol keys:
</span><span class="inferred0"><a name="line179"></a> 179   #
</span><span class="inferred1"><a name="line180"></a> 180   #   Company.find(:first, :conditions =&gt; [
</span><span class="inferred0"><a name="line181"></a> 181   #     &quot;id = :id AND name = :name AND division = :division AND created_at &gt; :accounting_date&quot;,
</span><span class="inferred1"><a name="line182"></a> 182   #     { :id =&gt; 3, :name =&gt; &quot;37signals&quot;, :division =&gt; &quot;First&quot;, :accounting_date =&gt; '2005-01-01' }
</span><span class="inferred0"><a name="line183"></a> 183   #   ])
</span><span class="inferred1"><a name="line184"></a> 184   #
</span><span class="inferred0"><a name="line185"></a> 185   # Similarly, a simple hash without a statement will generate conditions based on equality with the SQL AND
</span><span class="inferred1"><a name="line186"></a> 186   # operator. For instance:
</span><span class="inferred0"><a name="line187"></a> 187   #
</span><span class="inferred1"><a name="line188"></a> 188   #   Student.find(:all, :conditions =&gt; { :first_name =&gt; &quot;Harvey&quot;, :status =&gt; 1 })
</span><span class="inferred0"><a name="line189"></a> 189   #   Student.find(:all, :conditions =&gt; params[:student])
</span><span class="inferred1"><a name="line190"></a> 190   #
</span><span class="inferred0"><a name="line191"></a> 191   # A range may be used in the hash to use the SQL BETWEEN operator:
</span><span class="inferred1"><a name="line192"></a> 192   #
</span><span class="inferred0"><a name="line193"></a> 193   #   Student.find(:all, :conditions =&gt; { :grade =&gt; 9..12 })
</span><span class="inferred1"><a name="line194"></a> 194   #
</span><span class="inferred0"><a name="line195"></a> 195   # An array may be used in the hash to use the SQL IN operator:
</span><span class="inferred1"><a name="line196"></a> 196   #
</span><span class="inferred0"><a name="line197"></a> 197   #   Student.find(:all, :conditions =&gt; { :grade =&gt; [9,11,12] })
</span><span class="inferred1"><a name="line198"></a> 198   #
</span><span class="inferred0"><a name="line199"></a> 199   # == Overwriting default accessors
</span><span class="inferred1"><a name="line200"></a> 200   #
</span><span class="inferred0"><a name="line201"></a> 201   # All column values are automatically available through basic accessors on the Active Record object, but sometimes you
</span><span class="inferred1"><a name="line202"></a> 202   # want to specialize this behavior. This can be done by overwriting the default accessors (using the same
</span><span class="inferred0"><a name="line203"></a> 203   # name as the attribute) and calling &lt;tt&gt;read_attribute(attr_name)&lt;/tt&gt; and &lt;tt&gt;write_attribute(attr_name, value)&lt;/tt&gt; to actually change things.
</span><span class="inferred1"><a name="line204"></a> 204   # Example:
</span><span class="inferred0"><a name="line205"></a> 205   #
</span><span class="inferred1"><a name="line206"></a> 206   #   class Song &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line207"></a> 207   #     # Uses an integer of seconds to hold the length of the song
</span><span class="inferred1"><a name="line208"></a> 208   #
</span><span class="inferred0"><a name="line209"></a> 209   #     def length=(minutes)
</span><span class="inferred1"><a name="line210"></a> 210   #       write_attribute(:length, minutes.to_i * 60)
</span><span class="inferred0"><a name="line211"></a> 211   #     end
</span><span class="inferred1"><a name="line212"></a> 212   #
</span><span class="inferred0"><a name="line213"></a> 213   #     def length
</span><span class="inferred1"><a name="line214"></a> 214   #       read_attribute(:length) / 60
</span><span class="inferred0"><a name="line215"></a> 215   #     end
</span><span class="inferred1"><a name="line216"></a> 216   #   end
</span><span class="inferred0"><a name="line217"></a> 217   #
</span><span class="inferred1"><a name="line218"></a> 218   # You can alternatively use &lt;tt&gt;self[:attribute]=(value)&lt;/tt&gt; and &lt;tt&gt;self[:attribute]&lt;/tt&gt; instead of &lt;tt&gt;write_attribute(:attribute, value)&lt;/tt&gt; and
</span><span class="inferred0"><a name="line219"></a> 219   # &lt;tt&gt;read_attribute(:attribute)&lt;/tt&gt; as a shorter form.
</span><span class="inferred1"><a name="line220"></a> 220   #
</span><span class="inferred0"><a name="line221"></a> 221   # == Attribute query methods
</span><span class="inferred1"><a name="line222"></a> 222   #
</span><span class="inferred0"><a name="line223"></a> 223   # In addition to the basic accessors, query methods are also automatically available on the Active Record object.
</span><span class="inferred1"><a name="line224"></a> 224   # Query methods allow you to test whether an attribute value is present.
</span><span class="inferred0"><a name="line225"></a> 225   #
</span><span class="inferred1"><a name="line226"></a> 226   # For example, an Active Record User with the &lt;tt&gt;name&lt;/tt&gt; attribute has a &lt;tt&gt;name?&lt;/tt&gt; method that you can call
</span><span class="inferred0"><a name="line227"></a> 227   # to determine whether the user has a name:
</span><span class="inferred1"><a name="line228"></a> 228   #
</span><span class="inferred0"><a name="line229"></a> 229   #   user = User.new(:name =&gt; &quot;David&quot;)
</span><span class="inferred1"><a name="line230"></a> 230   #   user.name? # =&gt; true
</span><span class="inferred0"><a name="line231"></a> 231   #
</span><span class="inferred1"><a name="line232"></a> 232   #   anonymous = User.new(:name =&gt; &quot;&quot;)
</span><span class="inferred0"><a name="line233"></a> 233   #   anonymous.name? # =&gt; false
</span><span class="inferred1"><a name="line234"></a> 234   #
</span><span class="inferred0"><a name="line235"></a> 235   # == Accessing attributes before they have been typecasted
</span><span class="inferred1"><a name="line236"></a> 236   #
</span><span class="inferred0"><a name="line237"></a> 237   # Sometimes you want to be able to read the raw attribute data without having the column-determined typecast run its course first.
</span><span class="inferred1"><a name="line238"></a> 238   # That can be done by using the &lt;tt&gt;&lt;attribute&gt;_before_type_cast&lt;/tt&gt; accessors that all attributes have. For example, if your Account model
</span><span class="inferred0"><a name="line239"></a> 239   # has a &lt;tt&gt;balance&lt;/tt&gt; attribute, you can call &lt;tt&gt;account.balance_before_type_cast&lt;/tt&gt; or &lt;tt&gt;account.id_before_type_cast&lt;/tt&gt;.
</span><span class="inferred1"><a name="line240"></a> 240   #
</span><span class="inferred0"><a name="line241"></a> 241   # This is especially useful in validation situations where the user might supply a string for an integer field and you want to display
</span><span class="inferred1"><a name="line242"></a> 242   # the original string back in an error message. Accessing the attribute normally would typecast the string to 0, which isn't what you
</span><span class="inferred0"><a name="line243"></a> 243   # want.
</span><span class="inferred1"><a name="line244"></a> 244   #
</span><span class="inferred0"><a name="line245"></a> 245   # == Dynamic attribute-based finders
</span><span class="inferred1"><a name="line246"></a> 246   #
</span><span class="inferred0"><a name="line247"></a> 247   # Dynamic attribute-based finders are a cleaner way of getting (and/or creating) objects by simple queries without turning to SQL. They work by
</span><span class="inferred1"><a name="line248"></a> 248   # appending the name of an attribute to &lt;tt&gt;find_by_&lt;/tt&gt; or &lt;tt&gt;find_all_by_&lt;/tt&gt;, so you get finders like &lt;tt&gt;Person.find_by_user_name&lt;/tt&gt;,
</span><span class="inferred0"><a name="line249"></a> 249   # &lt;tt&gt;Person.find_all_by_last_name&lt;/tt&gt;, and &lt;tt&gt;Payment.find_by_transaction_id&lt;/tt&gt;. So instead of writing
</span><span class="inferred1"><a name="line250"></a> 250   # &lt;tt&gt;Person.find(:first, :conditions =&gt; [&quot;user_name = ?&quot;, user_name])&lt;/tt&gt;, you just do &lt;tt&gt;Person.find_by_user_name(user_name)&lt;/tt&gt;.
</span><span class="inferred0"><a name="line251"></a> 251   # And instead of writing &lt;tt&gt;Person.find(:all, :conditions =&gt; [&quot;last_name = ?&quot;, last_name])&lt;/tt&gt;, you just do &lt;tt&gt;Person.find_all_by_last_name(last_name)&lt;/tt&gt;.
</span><span class="inferred1"><a name="line252"></a> 252   #
</span><span class="inferred0"><a name="line253"></a> 253   # It's also possible to use multiple attributes in the same find by separating them with &quot;_and_&quot;, so you get finders like
</span><span class="inferred1"><a name="line254"></a> 254   # &lt;tt&gt;Person.find_by_user_name_and_password&lt;/tt&gt; or even &lt;tt&gt;Payment.find_by_purchaser_and_state_and_country&lt;/tt&gt;. So instead of writing
</span><span class="inferred0"><a name="line255"></a> 255   # &lt;tt&gt;Person.find(:first, :conditions =&gt; [&quot;user_name = ? AND password = ?&quot;, user_name, password])&lt;/tt&gt;, you just do
</span><span class="inferred1"><a name="line256"></a> 256   # &lt;tt&gt;Person.find_by_user_name_and_password(user_name, password)&lt;/tt&gt;.
</span><span class="inferred0"><a name="line257"></a> 257   #
</span><span class="inferred1"><a name="line258"></a> 258   # It's even possible to use all the additional parameters to find. For example, the full interface for &lt;tt&gt;Payment.find_all_by_amount&lt;/tt&gt;
</span><span class="inferred0"><a name="line259"></a> 259   # is actually &lt;tt&gt;Payment.find_all_by_amount(amount, options)&lt;/tt&gt;. And the full interface to &lt;tt&gt;Person.find_by_user_name&lt;/tt&gt; is
</span><span class="inferred1"><a name="line260"></a> 260   # actually &lt;tt&gt;Person.find_by_user_name(user_name, options)&lt;/tt&gt;. So you could call &lt;tt&gt;Payment.find_all_by_amount(50, :order =&gt; &quot;created_on&quot;)&lt;/tt&gt;.
</span><span class="inferred0"><a name="line261"></a> 261   #
</span><span class="inferred1"><a name="line262"></a> 262   # The same dynamic finder style can be used to create the object if it doesn't already exist. This dynamic finder is called with
</span><span class="inferred0"><a name="line263"></a> 263   # &lt;tt&gt;find_or_create_by_&lt;/tt&gt; and will return the object if it already exists and otherwise creates it, then returns it. Protected attributes won't be set unless they are given in a block. For example:
</span><span class="inferred1"><a name="line264"></a> 264   #
</span><span class="inferred0"><a name="line265"></a> 265   #   # No 'Summer' tag exists
</span><span class="inferred1"><a name="line266"></a> 266   #   Tag.find_or_create_by_name(&quot;Summer&quot;) # equal to Tag.create(:name =&gt; &quot;Summer&quot;)
</span><span class="inferred0"><a name="line267"></a> 267   #
</span><span class="inferred1"><a name="line268"></a> 268   #   # Now the 'Summer' tag does exist
</span><span class="inferred0"><a name="line269"></a> 269   #   Tag.find_or_create_by_name(&quot;Summer&quot;) # equal to Tag.find_by_name(&quot;Summer&quot;)
</span><span class="inferred1"><a name="line270"></a> 270   #
</span><span class="inferred0"><a name="line271"></a> 271   #   # Now 'Bob' exist and is an 'admin'
</span><span class="inferred1"><a name="line272"></a> 272   #   User.find_or_create_by_name('Bob', :age =&gt; 40) { |u| u.admin = true }
</span><span class="inferred0"><a name="line273"></a> 273   #
</span><span class="inferred1"><a name="line274"></a> 274   # Use the &lt;tt&gt;find_or_initialize_by_&lt;/tt&gt; finder if you want to return a new record without saving it first. Protected attributes won't be setted unless they are given in a block. For example:
</span><span class="inferred0"><a name="line275"></a> 275   #
</span><span class="inferred1"><a name="line276"></a> 276   #   # No 'Winter' tag exists
</span><span class="inferred0"><a name="line277"></a> 277   #   winter = Tag.find_or_initialize_by_name(&quot;Winter&quot;)
</span><span class="inferred1"><a name="line278"></a> 278   #   winter.new_record? # true
</span><span class="inferred0"><a name="line279"></a> 279   #
</span><span class="inferred1"><a name="line280"></a> 280   # To find by a subset of the attributes to be used for instantiating a new object, pass a hash instead of
</span><span class="inferred0"><a name="line281"></a> 281   # a list of parameters. For example:
</span><span class="inferred1"><a name="line282"></a> 282   #
</span><span class="inferred0"><a name="line283"></a> 283   #   Tag.find_or_create_by_name(:name =&gt; &quot;rails&quot;, :creator =&gt; current_user)
</span><span class="inferred1"><a name="line284"></a> 284   #
</span><span class="inferred0"><a name="line285"></a> 285   # That will either find an existing tag named &quot;rails&quot;, or create a new one while setting the user that created it.
</span><span class="inferred1"><a name="line286"></a> 286   #
</span><span class="inferred0"><a name="line287"></a> 287   # == Saving arrays, hashes, and other non-mappable objects in text columns
</span><span class="inferred1"><a name="line288"></a> 288   #
</span><span class="inferred0"><a name="line289"></a> 289   # Active Record can serialize any object in text columns using YAML. To do so, you must specify this with a call to the class method +serialize+.
</span><span class="inferred1"><a name="line290"></a> 290   # This makes it possible to store arrays, hashes, and other non-mappable objects without doing any additional work. Example:
</span><span class="inferred0"><a name="line291"></a> 291   #
</span><span class="inferred1"><a name="line292"></a> 292   #   class User &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line293"></a> 293   #     serialize :preferences
</span><span class="inferred1"><a name="line294"></a> 294   #   end
</span><span class="inferred0"><a name="line295"></a> 295   #
</span><span class="inferred1"><a name="line296"></a> 296   #   user = User.create(:preferences =&gt; { &quot;background&quot; =&gt; &quot;black&quot;, &quot;display&quot; =&gt; large })
</span><span class="inferred0"><a name="line297"></a> 297   #   User.find(user.id).preferences # =&gt; { &quot;background&quot; =&gt; &quot;black&quot;, &quot;display&quot; =&gt; large }
</span><span class="inferred1"><a name="line298"></a> 298   #
</span><span class="inferred0"><a name="line299"></a> 299   # You can also specify a class option as the second parameter that'll raise an exception if a serialized object is retrieved as a
</span><span class="inferred1"><a name="line300"></a> 300   # descendent of a class not in the hierarchy. Example:
</span><span class="inferred0"><a name="line301"></a> 301   #
</span><span class="inferred1"><a name="line302"></a> 302   #   class User &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line303"></a> 303   #     serialize :preferences, Hash
</span><span class="inferred1"><a name="line304"></a> 304   #   end
</span><span class="inferred0"><a name="line305"></a> 305   #
</span><span class="inferred1"><a name="line306"></a> 306   #   user = User.create(:preferences =&gt; %w( one two three ))
</span><span class="inferred0"><a name="line307"></a> 307   #   User.find(user.id).preferences    # raises SerializationTypeMismatch
</span><span class="inferred1"><a name="line308"></a> 308   #
</span><span class="inferred0"><a name="line309"></a> 309   # == Single table inheritance
</span><span class="inferred1"><a name="line310"></a> 310   #
</span><span class="inferred0"><a name="line311"></a> 311   # Active Record allows inheritance by storing the name of the class in a column that by default is named &quot;type&quot; (can be changed
</span><span class="inferred1"><a name="line312"></a> 312   # by overwriting &lt;tt&gt;Base.inheritance_column&lt;/tt&gt;). This means that an inheritance looking like this:
</span><span class="inferred0"><a name="line313"></a> 313   #
</span><span class="inferred1"><a name="line314"></a> 314   #   class Company &lt; ActiveRecord::Base; end
</span><span class="inferred0"><a name="line315"></a> 315   #   class Firm &lt; Company; end
</span><span class="inferred1"><a name="line316"></a> 316   #   class Client &lt; Company; end
</span><span class="inferred0"><a name="line317"></a> 317   #   class PriorityClient &lt; Client; end
</span><span class="inferred1"><a name="line318"></a> 318   #
</span><span class="inferred0"><a name="line319"></a> 319   # When you do &lt;tt&gt;Firm.create(:name =&gt; &quot;37signals&quot;)&lt;/tt&gt;, this record will be saved in the companies table with type = &quot;Firm&quot;. You can then
</span><span class="inferred1"><a name="line320"></a> 320   # fetch this row again using &lt;tt&gt;Company.find(:first, &quot;name = '37signals'&quot;)&lt;/tt&gt; and it will return a Firm object.
</span><span class="inferred0"><a name="line321"></a> 321   #
</span><span class="inferred1"><a name="line322"></a> 322   # If you don't have a type column defined in your table, single-table inheritance won't be triggered. In that case, it'll work just
</span><span class="inferred0"><a name="line323"></a> 323   # like normal subclasses with no special magic for differentiating between them or reloading the right type with find.
</span><span class="inferred1"><a name="line324"></a> 324   #
</span><span class="inferred0"><a name="line325"></a> 325   # Note, all the attributes for all the cases are kept in the same table. Read more:
</span><span class="inferred1"><a name="line326"></a> 326   # http://www.martinfowler.com/eaaCatalog/singleTableInheritance.html
</span><span class="inferred0"><a name="line327"></a> 327   #
</span><span class="inferred1"><a name="line328"></a> 328   # == Connection to multiple databases in different models
</span><span class="inferred0"><a name="line329"></a> 329   #
</span><span class="inferred1"><a name="line330"></a> 330   # Connections are usually created through ActiveRecord::Base.establish_connection and retrieved by ActiveRecord::Base.connection.
</span><span class="inferred0"><a name="line331"></a> 331   # All classes inheriting from ActiveRecord::Base will use this connection. But you can also set a class-specific connection.
</span><span class="inferred1"><a name="line332"></a> 332   # For example, if Course is an ActiveRecord::Base, but resides in a different database, you can just say &lt;tt&gt;Course.establish_connection&lt;/tt&gt;
</span><span class="inferred0"><a name="line333"></a> 333   # and Course and all of its subclasses will use this connection instead.
</span><span class="inferred1"><a name="line334"></a> 334   #
</span><span class="inferred0"><a name="line335"></a> 335   # This feature is implemented by keeping a connection pool in ActiveRecord::Base that is a Hash indexed by the class. If a connection is
</span><span class="inferred1"><a name="line336"></a> 336   # requested, the retrieve_connection method will go up the class-hierarchy until a connection is found in the connection pool.
</span><span class="inferred0"><a name="line337"></a> 337   #
</span><span class="inferred1"><a name="line338"></a> 338   # == Exceptions
</span><span class="inferred0"><a name="line339"></a> 339   #
</span><span class="inferred1"><a name="line340"></a> 340   # * ActiveRecordError - Generic error class and superclass of all other errors raised by Active Record.
</span><span class="inferred0"><a name="line341"></a> 341   # * AdapterNotSpecified - The configuration hash used in &lt;tt&gt;establish_connection&lt;/tt&gt; didn't include an
</span><span class="inferred1"><a name="line342"></a> 342   #   &lt;tt&gt;:adapter&lt;/tt&gt; key.
</span><span class="inferred0"><a name="line343"></a> 343   # * AdapterNotFound - The &lt;tt&gt;:adapter&lt;/tt&gt; key used in &lt;tt&gt;establish_connection&lt;/tt&gt; specified a non-existent adapter
</span><span class="inferred1"><a name="line344"></a> 344   #   (or a bad spelling of an existing one).
</span><span class="inferred0"><a name="line345"></a> 345   # * AssociationTypeMismatch - The object assigned to the association wasn't of the type specified in the association definition.
</span><span class="inferred1"><a name="line346"></a> 346   # * SerializationTypeMismatch - The serialized object wasn't of the class specified as the second parameter.
</span><span class="inferred0"><a name="line347"></a> 347   # * ConnectionNotEstablished+ - No connection has been established. Use &lt;tt&gt;establish_connection&lt;/tt&gt; before querying.
</span><span class="inferred1"><a name="line348"></a> 348   # * RecordNotFound - No record responded to the +find+ method. Either the row with the given ID doesn't exist
</span><span class="inferred0"><a name="line349"></a> 349   #   or the row didn't meet the additional restrictions. Some +find+ calls do not raise this exception to signal
</span><span class="inferred1"><a name="line350"></a> 350   #   nothing was found, please check its documentation for further details.
</span><span class="inferred0"><a name="line351"></a> 351   # * StatementInvalid - The database server rejected the SQL statement. The precise error is added in the message.
</span><span class="inferred1"><a name="line352"></a> 352   # * MultiparameterAssignmentErrors - Collection of errors that occurred during a mass assignment using the
</span><span class="inferred0"><a name="line353"></a> 353   #   &lt;tt&gt;attributes=&lt;/tt&gt; method. The +errors+ property of this exception contains an array of AttributeAssignmentError
</span><span class="inferred1"><a name="line354"></a> 354   #   objects that should be inspected to determine which attributes triggered the errors.
</span><span class="inferred0"><a name="line355"></a> 355   # * AttributeAssignmentError - An error occurred while doing a mass assignment through the &lt;tt&gt;attributes=&lt;/tt&gt; method.
</span><span class="inferred1"><a name="line356"></a> 356   #   You can inspect the +attribute+ property of the exception object to determine which attribute triggered the error.
</span><span class="inferred0"><a name="line357"></a> 357   #
</span><span class="inferred1"><a name="line358"></a> 358   # *Note*: The attributes listed are class-level attributes (accessible from both the class and instance level).
</span><span class="inferred0"><a name="line359"></a> 359   # So it's possible to assign a logger to the class through &lt;tt&gt;Base.logger=&lt;/tt&gt; which will then be used by all
</span><span class="inferred1"><a name="line360"></a> 360   # instances in the current object space.
</span><span class="marked0"><a name="line361"></a> 361   class Base
</span><span class="inferred1"><a name="line362"></a> 362     # Accepts a logger conforming to the interface of Log4r or the default Ruby 1.8+ Logger class, which is then passed
</span><span class="inferred0"><a name="line363"></a> 363     # on to any new database connections made and which can be retrieved on both a class and instance level by calling +logger+.
</span><span class="marked1"><a name="line364"></a> 364     cattr_accessor :logger, :instance_writer =&gt; false
</span><span class="inferred0"><a name="line365"></a> 365 
</span><span class="marked1"><a name="line366"></a> 366     def self.inherited(child) #:nodoc:
</span><span class="marked0"><a name="line367"></a> 367       @@subclasses[self] ||= []
</span><span class="marked1"><a name="line368"></a> 368       @@subclasses[self] &lt;&lt; child
</span><span class="marked0"><a name="line369"></a> 369       super
</span><span class="inferred1"><a name="line370"></a> 370     end
</span><span class="inferred0"><a name="line371"></a> 371 
</span><span class="marked1"><a name="line372"></a> 372     def self.reset_subclasses #:nodoc:
</span><span class="uncovered0"><a name="line373"></a> 373       nonreloadables = []
</span><span class="uncovered1"><a name="line374"></a> 374       subclasses.each do |klass|
</span><span class="uncovered0"><a name="line375"></a> 375         unless ActiveSupport::Dependencies.autoloaded? klass
</span><span class="uncovered1"><a name="line376"></a> 376           nonreloadables &lt;&lt; klass
</span><span class="uncovered0"><a name="line377"></a> 377           next
</span><span class="uncovered1"><a name="line378"></a> 378         end
</span><span class="uncovered0"><a name="line379"></a> 379         klass.instance_variables.each { |var| klass.send(:remove_instance_variable, var) }
</span><span class="uncovered1"><a name="line380"></a> 380         klass.instance_methods(false).each { |m| klass.send :undef_method, m }
</span><span class="uncovered0"><a name="line381"></a> 381       end
</span><span class="uncovered1"><a name="line382"></a> 382       @@subclasses = {}
</span><span class="uncovered0"><a name="line383"></a> 383       nonreloadables.each { |klass| (@@subclasses[klass.superclass] ||= []) &lt;&lt; klass }
</span><span class="uncovered1"><a name="line384"></a> 384     end
</span><span class="inferred0"><a name="line385"></a> 385 
</span><span class="marked1"><a name="line386"></a> 386     @@subclasses = {}
</span><span class="inferred0"><a name="line387"></a> 387 
</span><span class="marked1"><a name="line388"></a> 388     cattr_accessor :configurations, :instance_writer =&gt; false
</span><span class="marked0"><a name="line389"></a> 389     @@configurations = {}
</span><span class="inferred1"><a name="line390"></a> 390 
</span><span class="inferred0"><a name="line391"></a> 391     # Accessor for the prefix type that will be prepended to every primary key column name. The options are :table_name and
</span><span class="inferred1"><a name="line392"></a> 392     # :table_name_with_underscore. If the first is specified, the Product class will look for &quot;productid&quot; instead of &quot;id&quot; as
</span><span class="inferred0"><a name="line393"></a> 393     # the primary column. If the latter is specified, the Product class will look for &quot;product_id&quot; instead of &quot;id&quot;. Remember
</span><span class="inferred1"><a name="line394"></a> 394     # that this is a global setting for all Active Records.
</span><span class="marked0"><a name="line395"></a> 395     cattr_accessor :primary_key_prefix_type, :instance_writer =&gt; false
</span><span class="marked1"><a name="line396"></a> 396     @@primary_key_prefix_type = nil
</span><span class="inferred0"><a name="line397"></a> 397 
</span><span class="inferred1"><a name="line398"></a> 398     # Accessor for the name of the prefix string to prepend to every table name. So if set to &quot;basecamp_&quot;, all
</span><span class="inferred0"><a name="line399"></a> 399     # table names will be named like &quot;basecamp_projects&quot;, &quot;basecamp_people&quot;, etc. This is a convenient way of creating a namespace
</span><span class="inferred1"><a name="line400"></a> 400     # for tables in a shared database. By default, the prefix is the empty string.
</span><span class="marked0"><a name="line401"></a> 401     cattr_accessor :table_name_prefix, :instance_writer =&gt; false
</span><span class="marked1"><a name="line402"></a> 402     @@table_name_prefix = &quot;&quot;
</span><span class="inferred0"><a name="line403"></a> 403 
</span><span class="inferred1"><a name="line404"></a> 404     # Works like +table_name_prefix+, but appends instead of prepends (set to &quot;_basecamp&quot; gives &quot;projects_basecamp&quot;,
</span><span class="inferred0"><a name="line405"></a> 405     # &quot;people_basecamp&quot;). By default, the suffix is the empty string.
</span><span class="marked1"><a name="line406"></a> 406     cattr_accessor :table_name_suffix, :instance_writer =&gt; false
</span><span class="marked0"><a name="line407"></a> 407     @@table_name_suffix = &quot;&quot;
</span><span class="inferred1"><a name="line408"></a> 408 
</span><span class="inferred0"><a name="line409"></a> 409     # Indicates whether table names should be the pluralized versions of the corresponding class names.
</span><span class="inferred1"><a name="line410"></a> 410     # If true, the default table name for a Product class will be +products+. If false, it would just be +product+.
</span><span class="inferred0"><a name="line411"></a> 411     # See table_name for the full rules on table/class naming. This is true, by default.
</span><span class="marked1"><a name="line412"></a> 412     cattr_accessor :pluralize_table_names, :instance_writer =&gt; false
</span><span class="marked0"><a name="line413"></a> 413     @@pluralize_table_names = true
</span><span class="inferred1"><a name="line414"></a> 414 
</span><span class="inferred0"><a name="line415"></a> 415     # Determines whether to use ANSI codes to colorize the logging statements committed by the connection adapter. These colors
</span><span class="inferred1"><a name="line416"></a> 416     # make it much easier to overview things during debugging (when used through a reader like +tail+ and on a black background), but
</span><span class="inferred0"><a name="line417"></a> 417     # may complicate matters if you use software like syslog. This is true, by default.
</span><span class="marked1"><a name="line418"></a> 418     cattr_accessor :colorize_logging, :instance_writer =&gt; false
</span><span class="marked0"><a name="line419"></a> 419     @@colorize_logging = true
</span><span class="inferred1"><a name="line420"></a> 420 
</span><span class="inferred0"><a name="line421"></a> 421     # Determines whether to use Time.local (using :local) or Time.utc (using :utc) when pulling dates and times from the database.
</span><span class="inferred1"><a name="line422"></a> 422     # This is set to :local by default.
</span><span class="marked0"><a name="line423"></a> 423     cattr_accessor :default_timezone, :instance_writer =&gt; false
</span><span class="marked1"><a name="line424"></a> 424     @@default_timezone = :local
</span><span class="inferred0"><a name="line425"></a> 425 
</span><span class="inferred1"><a name="line426"></a> 426     # Determines whether to use a connection for each thread, or a single shared connection for all threads.
</span><span class="inferred0"><a name="line427"></a> 427     # Defaults to false. If you're writing a threaded application, set to true
</span><span class="inferred1"><a name="line428"></a> 428     # and periodically call verify_active_connections! to clear out connections
</span><span class="inferred0"><a name="line429"></a> 429     # assigned to stale threads.
</span><span class="marked1"><a name="line430"></a> 430     cattr_accessor :allow_concurrency, :instance_writer =&gt; false
</span><span class="marked0"><a name="line431"></a> 431     @@allow_concurrency = false
</span><span class="inferred1"><a name="line432"></a> 432 
</span><span class="inferred0"><a name="line433"></a> 433     # Specifies the format to use when dumping the database schema with Rails'
</span><span class="inferred1"><a name="line434"></a> 434     # Rakefile.  If :sql, the schema is dumped as (potentially database-
</span><span class="inferred0"><a name="line435"></a> 435     # specific) SQL statements.  If :ruby, the schema is dumped as an
</span><span class="inferred1"><a name="line436"></a> 436     # ActiveRecord::Schema file which can be loaded into any database that
</span><span class="inferred0"><a name="line437"></a> 437     # supports migrations.  Use :ruby if you want to have different database
</span><span class="inferred1"><a name="line438"></a> 438     # adapters for, e.g., your development and test environments.
</span><span class="marked0"><a name="line439"></a> 439     cattr_accessor :schema_format , :instance_writer =&gt; false
</span><span class="marked1"><a name="line440"></a> 440     @@schema_format = :ruby
</span><span class="inferred0"><a name="line441"></a> 441 
</span><span class="inferred1"><a name="line442"></a> 442     # Specify whether or not to use timestamps for migration numbers
</span><span class="marked0"><a name="line443"></a> 443     cattr_accessor :timestamped_migrations , :instance_writer =&gt; false
</span><span class="marked1"><a name="line444"></a> 444     @@timestamped_migrations = true
</span><span class="inferred0"><a name="line445"></a> 445 
</span><span class="inferred1"><a name="line446"></a> 446     # Determine whether to store the full constant name including namespace when using STI
</span><span class="marked0"><a name="line447"></a> 447     superclass_delegating_accessor :store_full_sti_class
</span><span class="marked1"><a name="line448"></a> 448     self.store_full_sti_class = false
</span><span class="inferred0"><a name="line449"></a> 449 
</span><span class="marked1"><a name="line450"></a> 450     class &lt;&lt; self # Class methods
</span><span class="inferred0"><a name="line451"></a> 451       # Find operates with four different retrieval approaches:
</span><span class="inferred1"><a name="line452"></a> 452       #
</span><span class="inferred0"><a name="line453"></a> 453       # * Find by id - This can either be a specific id (1), a list of ids (1, 5, 6), or an array of ids ([5, 6, 10]).
</span><span class="inferred1"><a name="line454"></a> 454       #   If no record can be found for all of the listed ids, then RecordNotFound will be raised.
</span><span class="inferred0"><a name="line455"></a> 455       # * Find first - This will return the first record matched by the options used. These options can either be specific
</span><span class="inferred1"><a name="line456"></a> 456       #   conditions or merely an order. If no record can be matched, +nil+ is returned. Use
</span><span class="inferred0"><a name="line457"></a> 457       #   &lt;tt&gt;Model.find(:first, *args)&lt;/tt&gt; or its shortcut &lt;tt&gt;Model.first(*args)&lt;/tt&gt;.
</span><span class="inferred1"><a name="line458"></a> 458       # * Find last - This will return the last record matched by the options used. These options can either be specific
</span><span class="inferred0"><a name="line459"></a> 459       #   conditions or merely an order. If no record can be matched, +nil+ is returned. Use
</span><span class="inferred1"><a name="line460"></a> 460       #   &lt;tt&gt;Model.find(:last, *args)&lt;/tt&gt; or its shortcut &lt;tt&gt;Model.last(*args)&lt;/tt&gt;.
</span><span class="inferred0"><a name="line461"></a> 461       # * Find all - This will return all the records matched by the options used.
</span><span class="inferred1"><a name="line462"></a> 462       #   If no records are found, an empty array is returned. Use
</span><span class="inferred0"><a name="line463"></a> 463       #   &lt;tt&gt;Model.find(:all, *args)&lt;/tt&gt; or its shortcut &lt;tt&gt;Model.all(*args)&lt;/tt&gt;.
</span><span class="inferred1"><a name="line464"></a> 464       #
</span><span class="inferred0"><a name="line465"></a> 465       # All approaches accept an options hash as their last parameter.
</span><span class="inferred1"><a name="line466"></a> 466       #
</span><span class="inferred0"><a name="line467"></a> 467       # ==== Attributes
</span><span class="inferred1"><a name="line468"></a> 468       #
</span><span class="inferred0"><a name="line469"></a> 469       # * &lt;tt&gt;:conditions&lt;/tt&gt; - An SQL fragment like &quot;administrator = 1&quot; or &lt;tt&gt;[ &quot;user_name = ?&quot;, username ]&lt;/tt&gt;. See conditions in the intro.
</span><span class="inferred1"><a name="line470"></a> 470       # * &lt;tt&gt;:order&lt;/tt&gt; - An SQL fragment like &quot;created_at DESC, name&quot;.
</span><span class="inferred0"><a name="line471"></a> 471       # * &lt;tt&gt;:group&lt;/tt&gt; - An attribute name by which the result should be grouped. Uses the &lt;tt&gt;GROUP BY&lt;/tt&gt; SQL-clause.
</span><span class="inferred1"><a name="line472"></a> 472       # * &lt;tt&gt;:limit&lt;/tt&gt; - An integer determining the limit on the number of rows that should be returned.
</span><span class="inferred0"><a name="line473"></a> 473       # * &lt;tt&gt;:offset&lt;/tt&gt; - An integer determining the offset from where the rows should be fetched. So at 5, it would skip rows 0 through 4.
</span><span class="inferred1"><a name="line474"></a> 474       # * &lt;tt&gt;:joins&lt;/tt&gt; - Either an SQL fragment for additional joins like &quot;LEFT JOIN comments ON comments.post_id = id&quot; (rarely needed)
</span><span class="inferred0"><a name="line475"></a> 475       #   or named associations in the same form used for the &lt;tt&gt;:include&lt;/tt&gt; option, which will perform an &lt;tt&gt;INNER JOIN&lt;/tt&gt; on the associated table(s).
</span><span class="inferred1"><a name="line476"></a> 476       #   If the value is a string, then the records will be returned read-only since they will have attributes that do not correspond to the table's columns.
</span><span class="inferred0"><a name="line477"></a> 477       #   Pass &lt;tt&gt;:readonly =&gt; false&lt;/tt&gt; to override.
</span><span class="inferred1"><a name="line478"></a> 478       # * &lt;tt&gt;:include&lt;/tt&gt; - Names associations that should be loaded alongside. The symbols named refer
</span><span class="inferred0"><a name="line479"></a> 479       #   to already defined associations. See eager loading under Associations.
</span><span class="inferred1"><a name="line480"></a> 480       # * &lt;tt&gt;:select&lt;/tt&gt; - By default, this is &quot;*&quot; as in &quot;SELECT * FROM&quot;, but can be changed if you, for example, want to do a join but not
</span><span class="inferred0"><a name="line481"></a> 481       #   include the joined columns.
</span><span class="inferred1"><a name="line482"></a> 482       # * &lt;tt&gt;:from&lt;/tt&gt; - By default, this is the table name of the class, but can be changed to an alternate table name (or even the name
</span><span class="inferred0"><a name="line483"></a> 483       #   of a database view).
</span><span class="inferred1"><a name="line484"></a> 484       # * &lt;tt&gt;:readonly&lt;/tt&gt; - Mark the returned records read-only so they cannot be saved or updated.
</span><span class="inferred0"><a name="line485"></a> 485       # * &lt;tt&gt;:lock&lt;/tt&gt; - An SQL fragment like &quot;FOR UPDATE&quot; or &quot;LOCK IN SHARE MODE&quot;.
</span><span class="inferred1"><a name="line486"></a> 486       #   &lt;tt&gt;:lock =&gt; true&lt;/tt&gt; gives connection's default exclusive lock, usually &quot;FOR UPDATE&quot;.
</span><span class="inferred0"><a name="line487"></a> 487       #
</span><span class="inferred1"><a name="line488"></a> 488       # ==== Examples
</span><span class="inferred0"><a name="line489"></a> 489       #
</span><span class="inferred1"><a name="line490"></a> 490       #   # find by id
</span><span class="inferred0"><a name="line491"></a> 491       #   Person.find(1)       # returns the object for ID = 1
</span><span class="inferred1"><a name="line492"></a> 492       #   Person.find(1, 2, 6) # returns an array for objects with IDs in (1, 2, 6)
</span><span class="inferred0"><a name="line493"></a> 493       #   Person.find([7, 17]) # returns an array for objects with IDs in (7, 17)
</span><span class="inferred1"><a name="line494"></a> 494       #   Person.find([1])     # returns an array for the object with ID = 1
</span><span class="inferred0"><a name="line495"></a> 495       #   Person.find(1, :conditions =&gt; &quot;administrator = 1&quot;, :order =&gt; &quot;created_on DESC&quot;)
</span><span class="inferred1"><a name="line496"></a> 496       #
</span><span class="inferred0"><a name="line497"></a> 497       # Note that returned records may not be in the same order as the ids you
</span><span class="inferred1"><a name="line498"></a> 498       # provide since database rows are unordered. Give an explicit &lt;tt&gt;:order&lt;/tt&gt;
</span><span class="inferred0"><a name="line499"></a> 499       # to ensure the results are sorted.
</span><span class="inferred1"><a name="line500"></a> 500       #
</span><span class="inferred0"><a name="line501"></a> 501       # ==== Examples
</span><span class="inferred1"><a name="line502"></a> 502       #
</span><span class="inferred0"><a name="line503"></a> 503       #   # find first
</span><span class="inferred1"><a name="line504"></a> 504       #   Person.find(:first) # returns the first object fetched by SELECT * FROM people
</span><span class="inferred0"><a name="line505"></a> 505       #   Person.find(:first, :conditions =&gt; [ &quot;user_name = ?&quot;, user_name])
</span><span class="inferred1"><a name="line506"></a> 506       #   Person.find(:first, :order =&gt; &quot;created_on DESC&quot;, :offset =&gt; 5)
</span><span class="inferred0"><a name="line507"></a> 507       #
</span><span class="inferred1"><a name="line508"></a> 508       #   # find last
</span><span class="inferred0"><a name="line509"></a> 509       #   Person.find(:last) # returns the last object fetched by SELECT * FROM people
</span><span class="inferred1"><a name="line510"></a> 510       #   Person.find(:last, :conditions =&gt; [ &quot;user_name = ?&quot;, user_name])
</span><span class="inferred0"><a name="line511"></a> 511       #   Person.find(:last, :order =&gt; &quot;created_on DESC&quot;, :offset =&gt; 5)
</span><span class="inferred1"><a name="line512"></a> 512       #
</span><span class="inferred0"><a name="line513"></a> 513       #   # find all
</span><span class="inferred1"><a name="line514"></a> 514       #   Person.find(:all) # returns an array of objects for all the rows fetched by SELECT * FROM people
</span><span class="inferred0"><a name="line515"></a> 515       #   Person.find(:all, :conditions =&gt; [ &quot;category IN (?)&quot;, categories], :limit =&gt; 50)
</span><span class="inferred1"><a name="line516"></a> 516       #   Person.find(:all, :conditions =&gt; { :friends =&gt; [&quot;Bob&quot;, &quot;Steve&quot;, &quot;Fred&quot;] }
</span><span class="inferred0"><a name="line517"></a> 517       #   Person.find(:all, :offset =&gt; 10, :limit =&gt; 10)
</span><span class="inferred1"><a name="line518"></a> 518       #   Person.find(:all, :include =&gt; [ :account, :friends ])
</span><span class="inferred0"><a name="line519"></a> 519       #   Person.find(:all, :group =&gt; &quot;category&quot;)
</span><span class="inferred1"><a name="line520"></a> 520       #
</span><span class="inferred0"><a name="line521"></a> 521       # Example for find with a lock: Imagine two concurrent transactions:
</span><span class="inferred1"><a name="line522"></a> 522       # each will read &lt;tt&gt;person.visits == 2&lt;/tt&gt;, add 1 to it, and save, resulting
</span><span class="inferred0"><a name="line523"></a> 523       # in two saves of &lt;tt&gt;person.visits = 3&lt;/tt&gt;.  By locking the row, the second
</span><span class="inferred1"><a name="line524"></a> 524       # transaction has to wait until the first is finished; we get the
</span><span class="inferred0"><a name="line525"></a> 525       # expected &lt;tt&gt;person.visits == 4&lt;/tt&gt;.
</span><span class="inferred1"><a name="line526"></a> 526       #
</span><span class="inferred0"><a name="line527"></a> 527       #   Person.transaction do
</span><span class="inferred1"><a name="line528"></a> 528       #     person = Person.find(1, :lock =&gt; true)
</span><span class="inferred0"><a name="line529"></a> 529       #     person.visits += 1
</span><span class="inferred1"><a name="line530"></a> 530       #     person.save!
</span><span class="inferred0"><a name="line531"></a> 531       #   end
</span><span class="marked1"><a name="line532"></a> 532       def find(*args)
</span><span class="uncovered0"><a name="line533"></a> 533         options = args.extract_options!
</span><span class="uncovered1"><a name="line534"></a> 534         validate_find_options(options)
</span><span class="uncovered0"><a name="line535"></a> 535         set_readonly_option!(options)
</span><span class="uncovered1"><a name="line536"></a> 536 
</span><span class="uncovered0"><a name="line537"></a> 537         case args.first
</span><span class="uncovered1"><a name="line538"></a> 538           when :first then find_initial(options)
</span><span class="uncovered0"><a name="line539"></a> 539           when :last  then find_last(options)
</span><span class="uncovered1"><a name="line540"></a> 540           when :all   then find_every(options)
</span><span class="uncovered0"><a name="line541"></a> 541           else             find_from_ids(args, options)
</span><span class="uncovered1"><a name="line542"></a> 542         end
</span><span class="uncovered0"><a name="line543"></a> 543       end
</span><span class="inferred1"><a name="line544"></a> 544 
</span><span class="inferred0"><a name="line545"></a> 545       # A convenience wrapper for &lt;tt&gt;find(:first, *args)&lt;/tt&gt;. You can pass in all the
</span><span class="inferred1"><a name="line546"></a> 546       # same arguments to this method as you can to &lt;tt&gt;find(:first)&lt;/tt&gt;.
</span><span class="marked0"><a name="line547"></a> 547       def first(*args)
</span><span class="uncovered1"><a name="line548"></a> 548         find(:first, *args)
</span><span class="uncovered0"><a name="line549"></a> 549       end
</span><span class="inferred1"><a name="line550"></a> 550 
</span><span class="inferred0"><a name="line551"></a> 551       # A convenience wrapper for &lt;tt&gt;find(:last, *args)&lt;/tt&gt;. You can pass in all the
</span><span class="inferred1"><a name="line552"></a> 552       # same arguments to this method as you can to &lt;tt&gt;find(:last)&lt;/tt&gt;.
</span><span class="marked0"><a name="line553"></a> 553       def last(*args)
</span><span class="uncovered1"><a name="line554"></a> 554         find(:last, *args)
</span><span class="uncovered0"><a name="line555"></a> 555       end
</span><span class="inferred1"><a name="line556"></a> 556 
</span><span class="inferred0"><a name="line557"></a> 557       # This is an alias for find(:all).  You can pass in all the same arguments to this method as you can
</span><span class="inferred1"><a name="line558"></a> 558       # to find(:all)
</span><span class="marked0"><a name="line559"></a> 559       def all(*args)
</span><span class="uncovered1"><a name="line560"></a> 560         find(:all, *args)
</span><span class="uncovered0"><a name="line561"></a> 561       end
</span><span class="inferred1"><a name="line562"></a> 562 
</span><span class="inferred0"><a name="line563"></a> 563       # Executes a custom SQL query against your database and returns all the results.  The results will
</span><span class="inferred1"><a name="line564"></a> 564       # be returned as an array with columns requested encapsulated as attributes of the model you call
</span><span class="inferred0"><a name="line565"></a> 565       # this method from.  If you call +Product.find_by_sql+ then the results will be returned in a Product
</span><span class="inferred1"><a name="line566"></a> 566       # object with the attributes you specified in the SQL query.
</span><span class="inferred0"><a name="line567"></a> 567       #
</span><span class="inferred1"><a name="line568"></a> 568       # If you call a complicated SQL query which spans multiple tables the columns specified by the
</span><span class="inferred0"><a name="line569"></a> 569       # SELECT will be attributes of the model, whether or not they are columns of the corresponding
</span><span class="inferred1"><a name="line570"></a> 570       # table.
</span><span class="inferred0"><a name="line571"></a> 571       #
</span><span class="inferred1"><a name="line572"></a> 572       # The +sql+ parameter is a full SQL query as a string.  It will be called as is, there will be
</span><span class="inferred0"><a name="line573"></a> 573       # no database agnostic conversions performed.  This should be a last resort because using, for example,
</span><span class="inferred1"><a name="line574"></a> 574       # MySQL specific terms will lock you to using that particular database engine or require you to
</span><span class="inferred0"><a name="line575"></a> 575       # change your call if you switch engines
</span><span class="inferred1"><a name="line576"></a> 576       #
</span><span class="inferred0"><a name="line577"></a> 577       # ==== Examples
</span><span class="inferred1"><a name="line578"></a> 578       #   # A simple SQL query spanning multiple tables
</span><span class="inferred0"><a name="line579"></a> 579       #   Post.find_by_sql &quot;SELECT p.title, c.author FROM posts p, comments c WHERE p.id = c.post_id&quot;
</span><span class="inferred1"><a name="line580"></a> 580       #   &gt; [#&lt;Post:0x36bff9c @attributes={&quot;title&quot;=&gt;&quot;Ruby Meetup&quot;, &quot;first_name&quot;=&gt;&quot;Quentin&quot;}&gt;, ...]
</span><span class="inferred0"><a name="line581"></a> 581       #
</span><span class="inferred1"><a name="line582"></a> 582       #   # You can use the same string replacement techniques as you can with ActiveRecord#find
</span><span class="inferred0"><a name="line583"></a> 583       #   Post.find_by_sql [&quot;SELECT title FROM posts WHERE author = ? AND created &gt; ?&quot;, author_id, start_date]
</span><span class="inferred1"><a name="line584"></a> 584       #   &gt; [#&lt;Post:0x36bff9c @attributes={&quot;first_name&quot;=&gt;&quot;The Cheap Man Buys Twice&quot;}&gt;, ...]
</span><span class="marked0"><a name="line585"></a> 585       def find_by_sql(sql)
</span><span class="uncovered1"><a name="line586"></a> 586         connection.select_all(sanitize_sql(sql), &quot;#{name} Load&quot;).collect! { |record| instantiate(record) }
</span><span class="uncovered0"><a name="line587"></a> 587       end
</span><span class="inferred1"><a name="line588"></a> 588 
</span><span class="inferred0"><a name="line589"></a> 589       # Checks whether a record exists in the database that matches conditions given.  These conditions
</span><span class="inferred1"><a name="line590"></a> 590       # can either be a single integer representing a primary key id to be found, or a condition to be
</span><span class="inferred0"><a name="line591"></a> 591       # matched like using ActiveRecord#find.
</span><span class="inferred1"><a name="line592"></a> 592       #
</span><span class="inferred0"><a name="line593"></a> 593       # The +id_or_conditions+ parameter can be an Integer or a String if you want to search the primary key
</span><span class="inferred1"><a name="line594"></a> 594       # column of the table for a matching id, or if you're looking to match against a condition you can use
</span><span class="inferred0"><a name="line595"></a> 595       # an Array or a Hash.
</span><span class="inferred1"><a name="line596"></a> 596       #
</span><span class="inferred0"><a name="line597"></a> 597       # Possible gotcha: You can't pass in a condition as a string e.g. &quot;name = 'Jamie'&quot;, this would be
</span><span class="inferred1"><a name="line598"></a> 598       # sanitized and then queried against the primary key column as &quot;id = 'name = \'Jamie&quot;
</span><span class="inferred0"><a name="line599"></a> 599       #
</span><span class="inferred1"><a name="line600"></a> 600       # ==== Examples
</span><span class="inferred0"><a name="line601"></a> 601       #   Person.exists?(5)
</span><span class="inferred1"><a name="line602"></a> 602       #   Person.exists?('5')
</span><span class="inferred0"><a name="line603"></a> 603       #   Person.exists?(:name =&gt; &quot;David&quot;)
</span><span class="inferred1"><a name="line604"></a> 604       #   Person.exists?(['name LIKE ?', &quot;%#{query}%&quot;])
</span><span class="marked0"><a name="line605"></a> 605       def exists?(id_or_conditions)
</span><span class="uncovered1"><a name="line606"></a> 606         connection.select_all(
</span><span class="uncovered0"><a name="line607"></a> 607           construct_finder_sql(
</span><span class="uncovered1"><a name="line608"></a> 608             :select     =&gt; &quot;#{quoted_table_name}.#{primary_key}&quot;,
</span><span class="uncovered0"><a name="line609"></a> 609             :conditions =&gt; expand_id_conditions(id_or_conditions),
</span><span class="uncovered1"><a name="line610"></a> 610             :limit      =&gt; 1
</span><span class="uncovered0"><a name="line611"></a> 611           ),
</span><span class="uncovered1"><a name="line612"></a> 612           &quot;#{name} Exists&quot;
</span><span class="uncovered0"><a name="line613"></a> 613         ).size &gt; 0
</span><span class="uncovered1"><a name="line614"></a> 614       end
</span><span class="inferred0"><a name="line615"></a> 615 
</span><span class="inferred1"><a name="line616"></a> 616       # Creates an object (or multiple objects) and saves it to the database, if validations pass.
</span><span class="inferred0"><a name="line617"></a> 617       # The resulting object is returned whether the object was saved successfully to the database or not.
</span><span class="inferred1"><a name="line618"></a> 618       #
</span><span class="inferred0"><a name="line619"></a> 619       # The +attributes+ parameter can be either be a Hash or an Array of Hashes.  These Hashes describe the
</span><span class="inferred1"><a name="line620"></a> 620       # attributes on the objects that are to be created.
</span><span class="inferred0"><a name="line621"></a> 621       #
</span><span class="inferred1"><a name="line622"></a> 622       # ==== Examples
</span><span class="inferred0"><a name="line623"></a> 623       #   # Create a single new object
</span><span class="inferred1"><a name="line624"></a> 624       #   User.create(:first_name =&gt; 'Jamie')
</span><span class="inferred0"><a name="line625"></a> 625       #
</span><span class="inferred1"><a name="line626"></a> 626       #   # Create an Array of new objects
</span><span class="inferred0"><a name="line627"></a> 627       #   User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }])
</span><span class="inferred1"><a name="line628"></a> 628       #
</span><span class="inferred0"><a name="line629"></a> 629       #   # Create a single object and pass it into a block to set other attributes.
</span><span class="inferred1"><a name="line630"></a> 630       #   User.create(:first_name =&gt; 'Jamie') do |u|
</span><span class="inferred0"><a name="line631"></a> 631       #     u.is_admin = false
</span><span class="inferred1"><a name="line632"></a> 632       #   end
</span><span class="inferred0"><a name="line633"></a> 633       #
</span><span class="inferred1"><a name="line634"></a> 634       #   # Creating an Array of new objects using a block, where the block is executed for each object:
</span><span class="inferred0"><a name="line635"></a> 635       #   User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }]) do |u|
</span><span class="inferred1"><a name="line636"></a> 636       #     u.is_admin = false
</span><span class="inferred0"><a name="line637"></a> 637       #   end
</span><span class="marked1"><a name="line638"></a> 638       def create(attributes = nil, &amp;block)
</span><span class="uncovered0"><a name="line639"></a> 639         if attributes.is_a?(Array)
</span><span class="uncovered1"><a name="line640"></a> 640           attributes.collect { |attr| create(attr, &amp;block) }
</span><span class="uncovered0"><a name="line641"></a> 641         else
</span><span class="uncovered1"><a name="line642"></a> 642           object = new(attributes)
</span><span class="uncovered0"><a name="line643"></a> 643           yield(object) if block_given?
</span><span class="uncovered1"><a name="line644"></a> 644           object.save
</span><span class="uncovered0"><a name="line645"></a> 645           object
</span><span class="uncovered1"><a name="line646"></a> 646         end
</span><span class="uncovered0"><a name="line647"></a> 647       end
</span><span class="inferred1"><a name="line648"></a> 648 
</span><span class="inferred0"><a name="line649"></a> 649       # Updates an object (or multiple objects) and saves it to the database, if validations pass.
</span><span class="inferred1"><a name="line650"></a> 650       # The resulting object is returned whether the object was saved successfully to the database or not.
</span><span class="inferred0"><a name="line651"></a> 651       #
</span><span class="inferred1"><a name="line652"></a> 652       # ==== Attributes
</span><span class="inferred0"><a name="line653"></a> 653       #
</span><span class="inferred1"><a name="line654"></a> 654       # * +id+ - This should be the id or an array of ids to be updated.
</span><span class="inferred0"><a name="line655"></a> 655       # * +attributes+ - This should be a Hash of attributes to be set on the object, or an array of Hashes.
</span><span class="inferred1"><a name="line656"></a> 656       #
</span><span class="inferred0"><a name="line657"></a> 657       # ==== Examples
</span><span class="inferred1"><a name="line658"></a> 658       #
</span><span class="inferred0"><a name="line659"></a> 659       #   # Updating one record:
</span><span class="inferred1"><a name="line660"></a> 660       #   Person.update(15, { :user_name =&gt; 'Samuel', :group =&gt; 'expert' })
</span><span class="inferred0"><a name="line661"></a> 661       #
</span><span class="inferred1"><a name="line662"></a> 662       #   # Updating multiple records:
</span><span class="inferred0"><a name="line663"></a> 663       #   people = { 1 =&gt; { &quot;first_name&quot; =&gt; &quot;David&quot; }, 2 =&gt; { &quot;first_name&quot; =&gt; &quot;Jeremy&quot; } }
</span><span class="inferred1"><a name="line664"></a> 664       #   Person.update(people.keys, people.values)
</span><span class="marked0"><a name="line665"></a> 665       def update(id, attributes)
</span><span class="uncovered1"><a name="line666"></a> 666         if id.is_a?(Array)
</span><span class="uncovered0"><a name="line667"></a> 667           idx = -1
</span><span class="uncovered1"><a name="line668"></a> 668           id.collect { |one_id| idx += 1; update(one_id, attributes[idx]) }
</span><span class="uncovered0"><a name="line669"></a> 669         else
</span><span class="uncovered1"><a name="line670"></a> 670           object = find(id)
</span><span class="uncovered0"><a name="line671"></a> 671           object.update_attributes(attributes)
</span><span class="uncovered1"><a name="line672"></a> 672           object
</span><span class="uncovered0"><a name="line673"></a> 673         end
</span><span class="uncovered1"><a name="line674"></a> 674       end
</span><span class="inferred0"><a name="line675"></a> 675 
</span><span class="inferred1"><a name="line676"></a> 676       # Delete an object (or multiple objects) where the +id+ given matches the primary_key.  A SQL +DELETE+ command
</span><span class="inferred0"><a name="line677"></a> 677       # is executed on the database which means that no callbacks are fired off running this.  This is an efficient method
</span><span class="inferred1"><a name="line678"></a> 678       # of deleting records that don't need cleaning up after or other actions to be taken.
</span><span class="inferred0"><a name="line679"></a> 679       #
</span><span class="inferred1"><a name="line680"></a> 680       # Objects are _not_ instantiated with this method.
</span><span class="inferred0"><a name="line681"></a> 681       #
</span><span class="inferred1"><a name="line682"></a> 682       # ==== Attributes
</span><span class="inferred0"><a name="line683"></a> 683       #
</span><span class="inferred1"><a name="line684"></a> 684       # * +id+ - Can be either an Integer or an Array of Integers.
</span><span class="inferred0"><a name="line685"></a> 685       #
</span><span class="inferred1"><a name="line686"></a> 686       # ==== Examples
</span><span class="inferred0"><a name="line687"></a> 687       #
</span><span class="inferred1"><a name="line688"></a> 688       #   # Delete a single object
</span><span class="inferred0"><a name="line689"></a> 689       #   Todo.delete(1)
</span><span class="inferred1"><a name="line690"></a> 690       #
</span><span class="inferred0"><a name="line691"></a> 691       #   # Delete multiple objects
</span><span class="inferred1"><a name="line692"></a> 692       #   todos = [1,2,3]
</span><span class="inferred0"><a name="line693"></a> 693       #   Todo.delete(todos)
</span><span class="marked1"><a name="line694"></a> 694       def delete(id)
</span><span class="uncovered0"><a name="line695"></a> 695         delete_all([ &quot;#{connection.quote_column_name(primary_key)} IN (?)&quot;, id ])
</span><span class="uncovered1"><a name="line696"></a> 696       end
</span><span class="inferred0"><a name="line697"></a> 697 
</span><span class="inferred1"><a name="line698"></a> 698       # Destroy an object (or multiple objects) that has the given id, the object is instantiated first,
</span><span class="inferred0"><a name="line699"></a> 699       # therefore all callbacks and filters are fired off before the object is deleted.  This method is
</span><span class="inferred1"><a name="line700"></a> 700       # less efficient than ActiveRecord#delete but allows cleanup methods and other actions to be run.
</span><span class="inferred0"><a name="line701"></a> 701       #
</span><span class="inferred1"><a name="line702"></a> 702       # This essentially finds the object (or multiple objects) with the given id, creates a new object
</span><span class="inferred0"><a name="line703"></a> 703       # from the attributes, and then calls destroy on it.
</span><span class="inferred1"><a name="line704"></a> 704       #
</span><span class="inferred0"><a name="line705"></a> 705       # ==== Attributes
</span><span class="inferred1"><a name="line706"></a> 706       #
</span><span class="inferred0"><a name="line707"></a> 707       # * +id+ - Can be either an Integer or an Array of Integers.
</span><span class="inferred1"><a name="line708"></a> 708       #
</span><span class="inferred0"><a name="line709"></a> 709       # ==== Examples
</span><span class="inferred1"><a name="line710"></a> 710       #
</span><span class="inferred0"><a name="line711"></a> 711       #   # Destroy a single object
</span><span class="inferred1"><a name="line712"></a> 712       #   Todo.destroy(1)
</span><span class="inferred0"><a name="line713"></a> 713       #
</span><span class="inferred1"><a name="line714"></a> 714       #   # Destroy multiple objects
</span><span class="inferred0"><a name="line715"></a> 715       #   todos = [1,2,3]
</span><span class="inferred1"><a name="line716"></a> 716       #   Todo.destroy(todos)
</span><span class="marked0"><a name="line717"></a> 717       def destroy(id)
</span><span class="uncovered1"><a name="line718"></a> 718         if id.is_a?(Array)
</span><span class="uncovered0"><a name="line719"></a> 719           id.map { |one_id| destroy(one_id) }
</span><span class="uncovered1"><a name="line720"></a> 720         else
</span><span class="uncovered0"><a name="line721"></a> 721           find(id).destroy
</span><span class="uncovered1"><a name="line722"></a> 722         end
</span><span class="uncovered0"><a name="line723"></a> 723       end
</span><span class="inferred1"><a name="line724"></a> 724 
</span><span class="inferred0"><a name="line725"></a> 725       # Updates all records with details given if they match a set of conditions supplied, limits and order can
</span><span class="inferred1"><a name="line726"></a> 726       # also be supplied.
</span><span class="inferred0"><a name="line727"></a> 727       #
</span><span class="inferred1"><a name="line728"></a> 728       # ==== Attributes
</span><span class="inferred0"><a name="line729"></a> 729       #
</span><span class="inferred1"><a name="line730"></a> 730       # * +updates+ - A String of column and value pairs that will be set on any records that match conditions.
</span><span class="inferred0"><a name="line731"></a> 731       # * +conditions+ - An SQL fragment like &quot;administrator = 1&quot; or [ &quot;user_name = ?&quot;, username ].
</span><span class="inferred1"><a name="line732"></a> 732       #   See conditions in the intro for more info.
</span><span class="inferred0"><a name="line733"></a> 733       # * +options+ - Additional options are &lt;tt&gt;:limit&lt;/tt&gt; and/or &lt;tt&gt;:order&lt;/tt&gt;, see the examples for usage.
</span><span class="inferred1"><a name="line734"></a> 734       #
</span><span class="inferred0"><a name="line735"></a> 735       # ==== Examples
</span><span class="inferred1"><a name="line736"></a> 736       #
</span><span class="inferred0"><a name="line737"></a> 737       #   # Update all billing objects with the 3 different attributes given
</span><span class="inferred1"><a name="line738"></a> 738       #   Billing.update_all( &quot;category = 'authorized', approved = 1, author = 'David'&quot; )
</span><span class="inferred0"><a name="line739"></a> 739       #
</span><span class="inferred1"><a name="line740"></a> 740       #   # Update records that match our conditions
</span><span class="inferred0"><a name="line741"></a> 741       #   Billing.update_all( &quot;author = 'David'&quot;, &quot;title LIKE '%Rails%'&quot; )
</span><span class="inferred1"><a name="line742"></a> 742       #
</span><span class="inferred0"><a name="line743"></a> 743       #   # Update records that match our conditions but limit it to 5 ordered by date
</span><span class="inferred1"><a name="line744"></a> 744       #   Billing.update_all( &quot;author = 'David'&quot;, &quot;title LIKE '%Rails%'&quot;,
</span><span class="inferred0"><a name="line745"></a> 745       #                         :order =&gt; 'created_at', :limit =&gt; 5 )
</span><span class="marked1"><a name="line746"></a> 746       def update_all(updates, conditions = nil, options = {})
</span><span class="uncovered0"><a name="line747"></a> 747         sql  = &quot;UPDATE #{quoted_table_name} SET #{sanitize_sql_for_assignment(updates)} &quot;
</span><span class="uncovered1"><a name="line748"></a> 748         scope = scope(:find)
</span><span class="uncovered0"><a name="line749"></a> 749         add_conditions!(sql, conditions, scope)
</span><span class="uncovered1"><a name="line750"></a> 750         add_order!(sql, options[:order], nil)
</span><span class="uncovered0"><a name="line751"></a> 751         add_limit!(sql, options, nil)
</span><span class="uncovered1"><a name="line752"></a> 752         connection.update(sql, &quot;#{name} Update&quot;)
</span><span class="uncovered0"><a name="line753"></a> 753       end
</span><span class="inferred1"><a name="line754"></a> 754 
</span><span class="inferred0"><a name="line755"></a> 755       # Destroys the records matching +conditions+ by instantiating each record and calling the destroy method.
</span><span class="inferred1"><a name="line756"></a> 756       # This means at least 2*N database queries to destroy N records, so avoid destroy_all if you are deleting
</span><span class="inferred0"><a name="line757"></a> 757       # many records. If you want to simply delete records without worrying about dependent associations or
</span><span class="inferred1"><a name="line758"></a> 758       # callbacks, use the much faster +delete_all+ method instead.
</span><span class="inferred0"><a name="line759"></a> 759       #
</span><span class="inferred1"><a name="line760"></a> 760       # ==== Attributes
</span><span class="inferred0"><a name="line761"></a> 761       #
</span><span class="inferred1"><a name="line762"></a> 762       # * +conditions+ - Conditions are specified the same way as with +find+ method.
</span><span class="inferred0"><a name="line763"></a> 763       #
</span><span class="inferred1"><a name="line764"></a> 764       # ==== Example
</span><span class="inferred0"><a name="line765"></a> 765       #
</span><span class="inferred1"><a name="line766"></a> 766       #   Person.destroy_all &quot;last_login &lt; '2004-04-04'&quot;
</span><span class="inferred0"><a name="line767"></a> 767       #
</span><span class="inferred1"><a name="line768"></a> 768       # This loads and destroys each person one by one, including its dependent associations and before_ and
</span><span class="inferred0"><a name="line769"></a> 769       # after_destroy callbacks.
</span><span class="marked1"><a name="line770"></a> 770       def destroy_all(conditions = nil)
</span><span class="uncovered0"><a name="line771"></a> 771         find(:all, :conditions =&gt; conditions).each { |object| object.destroy }
</span><span class="uncovered1"><a name="line772"></a> 772       end
</span><span class="inferred0"><a name="line773"></a> 773 
</span><span class="inferred1"><a name="line774"></a> 774       # Deletes the records matching +conditions+ without instantiating the records first, and hence not
</span><span class="inferred0"><a name="line775"></a> 775       # calling the destroy method and invoking callbacks. This is a single SQL query, much more efficient
</span><span class="inferred1"><a name="line776"></a> 776       # than destroy_all.
</span><span class="inferred0"><a name="line777"></a> 777       #
</span><span class="inferred1"><a name="line778"></a> 778       # ==== Attributes
</span><span class="inferred0"><a name="line779"></a> 779       #
</span><span class="inferred1"><a name="line780"></a> 780       # * +conditions+ - Conditions are specified the same way as with +find+ method.
</span><span class="inferred0"><a name="line781"></a> 781       #
</span><span class="inferred1"><a name="line782"></a> 782       # ==== Example
</span><span class="inferred0"><a name="line783"></a> 783       #
</span><span class="inferred1"><a name="line784"></a> 784       #   Post.delete_all &quot;person_id = 5 AND (category = 'Something' OR category = 'Else')&quot;
</span><span class="inferred0"><a name="line785"></a> 785       #
</span><span class="inferred1"><a name="line786"></a> 786       # This deletes the affected posts all at once with a single DELETE query. If you need to destroy dependent
</span><span class="inferred0"><a name="line787"></a> 787       # associations or call your before_ or after_destroy callbacks, use the +destroy_all+ method instead.
</span><span class="marked1"><a name="line788"></a> 788       def delete_all(conditions = nil)
</span><span class="uncovered0"><a name="line789"></a> 789         sql = &quot;DELETE FROM #{quoted_table_name} &quot;
</span><span class="uncovered1"><a name="line790"></a> 790         add_conditions!(sql, conditions, scope(:find))
</span><span class="uncovered0"><a name="line791"></a> 791         connection.delete(sql, &quot;#{name} Delete all&quot;)
</span><span class="uncovered1"><a name="line792"></a> 792       end
</span><span class="inferred0"><a name="line793"></a> 793 
</span><span class="inferred1"><a name="line794"></a> 794       # Returns the result of an SQL statement that should only include a COUNT(*) in the SELECT part.
</span><span class="inferred0"><a name="line795"></a> 795       # The use of this method should be restricted to complicated SQL queries that can't be executed
</span><span class="inferred1"><a name="line796"></a> 796       # using the ActiveRecord::Calculations class methods.  Look into those before using this.
</span><span class="inferred0"><a name="line797"></a> 797       #
</span><span class="inferred1"><a name="line798"></a> 798       # ==== Attributes
</span><span class="inferred0"><a name="line799"></a> 799       #
</span><span class="inferred1"><a name="line800"></a> 800       # * +sql+ - An SQL statement which should return a count query from the database, see the example below.
</span><span class="inferred0"><a name="line801"></a> 801       #
</span><span class="inferred1"><a name="line802"></a> 802       # ==== Examples
</span><span class="inferred0"><a name="line803"></a> 803       #
</span><span class="inferred1"><a name="line804"></a> 804       #   Product.count_by_sql &quot;SELECT COUNT(*) FROM sales s, customers c WHERE s.customer_id = c.id&quot;
</span><span class="marked0"><a name="line805"></a> 805       def count_by_sql(sql)
</span><span class="uncovered1"><a name="line806"></a> 806         sql = sanitize_conditions(sql)
</span><span class="uncovered0"><a name="line807"></a> 807         connection.select_value(sql, &quot;#{name} Count&quot;).to_i
</span><span class="uncovered1"><a name="line808"></a> 808       end
</span><span class="inferred0"><a name="line809"></a> 809 
</span><span class="inferred1"><a name="line810"></a> 810       # A generic &quot;counter updater&quot; implementation, intended primarily to be
</span><span class="inferred0"><a name="line811"></a> 811       # used by increment_counter and decrement_counter, but which may also
</span><span class="inferred1"><a name="line812"></a> 812       # be useful on its own. It simply does a direct SQL update for the record
</span><span class="inferred0"><a name="line813"></a> 813       # with the given ID, altering the given hash of counters by the amount
</span><span class="inferred1"><a name="line814"></a> 814       # given by the corresponding value:
</span><span class="inferred0"><a name="line815"></a> 815       #
</span><span class="inferred1"><a name="line816"></a> 816       # ==== Attributes
</span><span class="inferred0"><a name="line817"></a> 817       #
</span><span class="inferred1"><a name="line818"></a> 818       # * +id+ - The id of the object you wish to update a counter on.
</span><span class="inferred0"><a name="line819"></a> 819       # * +counters+ - An Array of Hashes containing the names of the fields
</span><span class="inferred1"><a name="line820"></a> 820       #   to update as keys and the amount to update the field by as values.
</span><span class="inferred0"><a name="line821"></a> 821       #
</span><span class="inferred1"><a name="line822"></a> 822       # ==== Examples
</span><span class="inferred0"><a name="line823"></a> 823       #
</span><span class="inferred1"><a name="line824"></a> 824       #   # For the Post with id of 5, decrement the comment_count by 1, and
</span><span class="inferred0"><a name="line825"></a> 825       #   # increment the action_count by 1
</span><span class="inferred1"><a name="line826"></a> 826       #   Post.update_counters 5, :comment_count =&gt; -1, :action_count =&gt; 1
</span><span class="inferred0"><a name="line827"></a> 827       #   # Executes the following SQL:
</span><span class="inferred1"><a name="line828"></a> 828       #   # UPDATE posts
</span><span class="inferred0"><a name="line829"></a> 829       #   #    SET comment_count = comment_count - 1,
</span><span class="inferred1"><a name="line830"></a> 830       #   #        action_count = action_count + 1
</span><span class="inferred0"><a name="line831"></a> 831       #   #  WHERE id = 5
</span><span class="marked1"><a name="line832"></a> 832       def update_counters(id, counters)
</span><span class="uncovered0"><a name="line833"></a> 833         updates = counters.inject([]) { |list, (counter_name, increment)|
</span><span class="uncovered1"><a name="line834"></a> 834           sign = increment &lt; 0 ? &quot;-&quot; : &quot;+&quot;
</span><span class="uncovered0"><a name="line835"></a> 835           list &lt;&lt; &quot;#{connection.quote_column_name(counter_name)} = COALESCE(#{connection.quote_column_name(counter_name)}, 0) #{sign} #{increment.abs}&quot;
</span><span class="uncovered1"><a name="line836"></a> 836         }.join(&quot;, &quot;)
</span><span class="uncovered0"><a name="line837"></a> 837         update_all(updates, &quot;#{connection.quote_column_name(primary_key)} = #{quote_value(id)}&quot;)
</span><span class="uncovered1"><a name="line838"></a> 838       end
</span><span class="inferred0"><a name="line839"></a> 839 
</span><span class="inferred1"><a name="line840"></a> 840       # Increment a number field by one, usually representing a count.
</span><span class="inferred0"><a name="line841"></a> 841       #
</span><span class="inferred1"><a name="line842"></a> 842       # This is used for caching aggregate values, so that they don't need to be computed every time.
</span><span class="inferred0"><a name="line843"></a> 843       # For example, a DiscussionBoard may cache post_count and comment_count otherwise every time the board is
</span><span class="inferred1"><a name="line844"></a> 844       # shown it would have to run an SQL query to find how many posts and comments there are.
</span><span class="inferred0"><a name="line845"></a> 845       #
</span><span class="inferred1"><a name="line846"></a> 846       # ==== Attributes
</span><span class="inferred0"><a name="line847"></a> 847       #
</span><span class="inferred1"><a name="line848"></a> 848       # * +counter_name+ - The name of the field that should be incremented.
</span><span class="inferred0"><a name="line849"></a> 849       # * +id+ - The id of the object that should be incremented.
</span><span class="inferred1"><a name="line850"></a> 850       #
</span><span class="inferred0"><a name="line851"></a> 851       # ==== Examples
</span><span class="inferred1"><a name="line852"></a> 852       #
</span><span class="inferred0"><a name="line853"></a> 853       #   # Increment the post_count column for the record with an id of 5
</span><span class="inferred1"><a name="line854"></a> 854       #   DiscussionBoard.increment_counter(:post_count, 5)
</span><span class="marked0"><a name="line855"></a> 855       def increment_counter(counter_name, id)
</span><span class="uncovered1"><a name="line856"></a> 856         update_counters(id, counter_name =&gt; 1)
</span><span class="uncovered0"><a name="line857"></a> 857       end
</span><span class="inferred1"><a name="line858"></a> 858 
</span><span class="inferred0"><a name="line859"></a> 859       # Decrement a number field by one, usually representing a count.
</span><span class="inferred1"><a name="line860"></a> 860       #
</span><span class="inferred0"><a name="line861"></a> 861       # This works the same as increment_counter but reduces the column value by 1 instead of increasing it.
</span><span class="inferred1"><a name="line862"></a> 862       #
</span><span class="inferred0"><a name="line863"></a> 863       # ==== Attributes
</span><span class="inferred1"><a name="line864"></a> 864       #
</span><span class="inferred0"><a name="line865"></a> 865       # * +counter_name+ - The name of the field that should be decremented.
</span><span class="inferred1"><a name="line866"></a> 866       # * +id+ - The id of the object that should be decremented.
</span><span class="inferred0"><a name="line867"></a> 867       #
</span><span class="inferred1"><a name="line868"></a> 868       # ==== Examples
</span><span class="inferred0"><a name="line869"></a> 869       #
</span><span class="inferred1"><a name="line870"></a> 870       #   # Decrement the post_count column for the record with an id of 5
</span><span class="inferred0"><a name="line871"></a> 871       #   DiscussionBoard.decrement_counter(:post_count, 5)
</span><span class="marked1"><a name="line872"></a> 872       def decrement_counter(counter_name, id)
</span><span class="uncovered0"><a name="line873"></a> 873         update_counters(id, counter_name =&gt; -1)
</span><span class="uncovered1"><a name="line874"></a> 874       end
</span><span class="inferred0"><a name="line875"></a> 875 
</span><span class="inferred1"><a name="line876"></a> 876 
</span><span class="inferred0"><a name="line877"></a> 877       # Attributes named in this macro are protected from mass-assignment,
</span><span class="inferred1"><a name="line878"></a> 878       # such as &lt;tt&gt;new(attributes)&lt;/tt&gt;,
</span><span class="inferred0"><a name="line879"></a> 879       # &lt;tt&gt;update_attributes(attributes)&lt;/tt&gt;, or
</span><span class="inferred1"><a name="line880"></a> 880       # &lt;tt&gt;attributes=(attributes)&lt;/tt&gt;.
</span><span class="inferred0"><a name="line881"></a> 881       #
</span><span class="inferred1"><a name="line882"></a> 882       # Mass-assignment to these attributes will simply be ignored, to assign
</span><span class="inferred0"><a name="line883"></a> 883       # to them you can use direct writer methods. This is meant to protect
</span><span class="inferred1"><a name="line884"></a> 884       # sensitive attributes from being overwritten by malicious users
</span><span class="inferred0"><a name="line885"></a> 885       # tampering with URLs or forms.
</span><span class="inferred1"><a name="line886"></a> 886       #
</span><span class="inferred0"><a name="line887"></a> 887       #   class Customer &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line888"></a> 888       #     attr_protected :credit_rating
</span><span class="inferred0"><a name="line889"></a> 889       #   end
</span><span class="inferred1"><a name="line890"></a> 890       #
</span><span class="inferred0"><a name="line891"></a> 891       #   customer = Customer.new(&quot;name&quot; =&gt; David, &quot;credit_rating&quot; =&gt; &quot;Excellent&quot;)
</span><span class="inferred1"><a name="line892"></a> 892       #   customer.credit_rating # =&gt; nil
</span><span class="inferred0"><a name="line893"></a> 893       #   customer.attributes = { &quot;description&quot; =&gt; &quot;Jolly fellow&quot;, &quot;credit_rating&quot; =&gt; &quot;Superb&quot; }
</span><span class="inferred1"><a name="line894"></a> 894       #   customer.credit_rating # =&gt; nil
</span><span class="inferred0"><a name="line895"></a> 895       #
</span><span class="inferred1"><a name="line896"></a> 896       #   customer.credit_rating = &quot;Average&quot;
</span><span class="inferred0"><a name="line897"></a> 897       #   customer.credit_rating # =&gt; &quot;Average&quot;
</span><span class="inferred1"><a name="line898"></a> 898       #
</span><span class="inferred0"><a name="line899"></a> 899       # To start from an all-closed default and enable attributes as needed,
</span><span class="inferred1"><a name="line900"></a> 900       # have a look at +attr_accessible+.
</span><span class="marked0"><a name="line901"></a> 901       def attr_protected(*attributes)
</span><span class="uncovered1"><a name="line902"></a> 902         write_inheritable_attribute(&quot;attr_protected&quot;, Set.new(attributes.map(&amp;:to_s)) + (protected_attributes || []))
</span><span class="uncovered0"><a name="line903"></a> 903       end
</span><span class="inferred1"><a name="line904"></a> 904 
</span><span class="inferred0"><a name="line905"></a> 905       # Returns an array of all the attributes that have been protected from mass-assignment.
</span><span class="marked1"><a name="line906"></a> 906       def protected_attributes # :nodoc:
</span><span class="uncovered0"><a name="line907"></a> 907         read_inheritable_attribute(&quot;attr_protected&quot;)
</span><span class="uncovered1"><a name="line908"></a> 908       end
</span><span class="inferred0"><a name="line909"></a> 909 
</span><span class="inferred1"><a name="line910"></a> 910       # Specifies a white list of model attributes that can be set via
</span><span class="inferred0"><a name="line911"></a> 911       # mass-assignment, such as &lt;tt&gt;new(attributes)&lt;/tt&gt;,
</span><span class="inferred1"><a name="line912"></a> 912       # &lt;tt&gt;update_attributes(attributes)&lt;/tt&gt;, or
</span><span class="inferred0"><a name="line913"></a> 913       # &lt;tt&gt;attributes=(attributes)&lt;/tt&gt;
</span><span class="inferred1"><a name="line914"></a> 914       #
</span><span class="inferred0"><a name="line915"></a> 915       # This is the opposite of the +attr_protected+ macro: Mass-assignment
</span><span class="inferred1"><a name="line916"></a> 916       # will only set attributes in this list, to assign to the rest of
</span><span class="inferred0"><a name="line917"></a> 917       # attributes you can use direct writer methods. This is meant to protect
</span><span class="inferred1"><a name="line918"></a> 918       # sensitive attributes from being overwritten by malicious users
</span><span class="inferred0"><a name="line919"></a> 919       # tampering with URLs or forms. If you'd rather start from an all-open
</span><span class="inferred1"><a name="line920"></a> 920       # default and restrict attributes as needed, have a look at
</span><span class="inferred0"><a name="line921"></a> 921       # +attr_protected+.
</span><span class="inferred1"><a name="line922"></a> 922       #
</span><span class="inferred0"><a name="line923"></a> 923       #   class Customer &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line924"></a> 924       #     attr_accessible :name, :nickname
</span><span class="inferred0"><a name="line925"></a> 925       #   end
</span><span class="inferred1"><a name="line926"></a> 926       #
</span><span class="inferred0"><a name="line927"></a> 927       #   customer = Customer.new(:name =&gt; &quot;David&quot;, :nickname =&gt; &quot;Dave&quot;, :credit_rating =&gt; &quot;Excellent&quot;)
</span><span class="inferred1"><a name="line928"></a> 928       #   customer.credit_rating # =&gt; nil
</span><span class="inferred0"><a name="line929"></a> 929       #   customer.attributes = { :name =&gt; &quot;Jolly fellow&quot;, :credit_rating =&gt; &quot;Superb&quot; }
</span><span class="inferred1"><a name="line930"></a> 930       #   customer.credit_rating # =&gt; nil
</span><span class="inferred0"><a name="line931"></a> 931       #
</span><span class="inferred1"><a name="line932"></a> 932       #   customer.credit_rating = &quot;Average&quot;
</span><span class="inferred0"><a name="line933"></a> 933       #   customer.credit_rating # =&gt; &quot;Average&quot;
</span><span class="marked1"><a name="line934"></a> 934       def attr_accessible(*attributes)
</span><span class="uncovered0"><a name="line935"></a> 935         write_inheritable_attribute(&quot;attr_accessible&quot;, Set.new(attributes.map(&amp;:to_s)) + (accessible_attributes || []))
</span><span class="uncovered1"><a name="line936"></a> 936       end
</span><span class="inferred0"><a name="line937"></a> 937 
</span><span class="inferred1"><a name="line938"></a> 938       # Returns an array of all the attributes that have been made accessible to mass-assignment.
</span><span class="marked0"><a name="line939"></a> 939       def accessible_attributes # :nodoc:
</span><span class="uncovered1"><a name="line940"></a> 940         read_inheritable_attribute(&quot;attr_accessible&quot;)
</span><span class="uncovered0"><a name="line941"></a> 941       end
</span><span class="inferred1"><a name="line942"></a> 942 
</span><span class="inferred0"><a name="line943"></a> 943        # Attributes listed as readonly can be set for a new record, but will be ignored in database updates afterwards.
</span><span class="marked1"><a name="line944"></a> 944        def attr_readonly(*attributes)
</span><span class="uncovered0"><a name="line945"></a> 945          write_inheritable_attribute(&quot;attr_readonly&quot;, Set.new(attributes.map(&amp;:to_s)) + (readonly_attributes || []))
</span><span class="uncovered1"><a name="line946"></a> 946        end
</span><span class="inferred0"><a name="line947"></a> 947 
</span><span class="inferred1"><a name="line948"></a> 948        # Returns an array of all the attributes that have been specified as readonly.
</span><span class="marked0"><a name="line949"></a> 949        def readonly_attributes
</span><span class="uncovered1"><a name="line950"></a> 950          read_inheritable_attribute(&quot;attr_readonly&quot;)
</span><span class="uncovered0"><a name="line951"></a> 951        end
</span><span class="inferred1"><a name="line952"></a> 952 
</span><span class="inferred0"><a name="line953"></a> 953       # If you have an attribute that needs to be saved to the database as an object, and retrieved as the same object,
</span><span class="inferred1"><a name="line954"></a> 954       # then specify the name of that attribute using this method and it will be handled automatically.
</span><span class="inferred0"><a name="line955"></a> 955       # The serialization is done through YAML. If +class_name+ is specified, the serialized object must be of that
</span><span class="inferred1"><a name="line956"></a> 956       # class on retrieval or SerializationTypeMismatch will be raised.
</span><span class="inferred0"><a name="line957"></a> 957       #
</span><span class="inferred1"><a name="line958"></a> 958       # ==== Attributes
</span><span class="inferred0"><a name="line959"></a> 959       #
</span><span class="inferred1"><a name="line960"></a> 960       # * +attr_name+ - The field name that should be serialized.
</span><span class="inferred0"><a name="line961"></a> 961       # * +class_name+ - Optional, class name that the object type should be equal to.
</span><span class="inferred1"><a name="line962"></a> 962       #
</span><span class="inferred0"><a name="line963"></a> 963       # ==== Example
</span><span class="inferred1"><a name="line964"></a> 964       #   # Serialize a preferences attribute
</span><span class="inferred0"><a name="line965"></a> 965       #   class User
</span><span class="inferred1"><a name="line966"></a> 966       #     serialize :preferences
</span><span class="inferred0"><a name="line967"></a> 967       #   end
</span><span class="marked1"><a name="line968"></a> 968       def serialize(attr_name, class_name = Object)
</span><span class="uncovered0"><a name="line969"></a> 969         serialized_attributes[attr_name.to_s] = class_name
</span><span class="uncovered1"><a name="line970"></a> 970       end
</span><span class="inferred0"><a name="line971"></a> 971 
</span><span class="inferred1"><a name="line972"></a> 972       # Returns a hash of all the attributes that have been specified for serialization as keys and their class restriction as values.
</span><span class="marked0"><a name="line973"></a> 973       def serialized_attributes
</span><span class="uncovered1"><a name="line974"></a> 974         read_inheritable_attribute(&quot;attr_serialized&quot;) or write_inheritable_attribute(&quot;attr_serialized&quot;, {})
</span><span class="uncovered0"><a name="line975"></a> 975       end
</span><span class="inferred1"><a name="line976"></a> 976 
</span><span class="inferred0"><a name="line977"></a> 977 
</span><span class="inferred1"><a name="line978"></a> 978       # Guesses the table name (in forced lower-case) based on the name of the class in the inheritance hierarchy descending
</span><span class="inferred0"><a name="line979"></a> 979       # directly from ActiveRecord::Base. So if the hierarchy looks like: Reply &lt; Message &lt; ActiveRecord::Base, then Message is used
</span><span class="inferred1"><a name="line980"></a> 980       # to guess the table name even when called on Reply. The rules used to do the guess are handled by the Inflector class
</span><span class="inferred0"><a name="line981"></a> 981       # in Active Support, which knows almost all common English inflections. You can add new inflections in config/initializers/inflections.rb.
</span><span class="inferred1"><a name="line982"></a> 982       #
</span><span class="inferred0"><a name="line983"></a> 983       # Nested classes are given table names prefixed by the singular form of
</span><span class="inferred1"><a name="line984"></a> 984       # the parent's table name. Enclosing modules are not considered.
</span><span class="inferred0"><a name="line985"></a> 985       #
</span><span class="inferred1"><a name="line986"></a> 986       # ==== Examples
</span><span class="inferred0"><a name="line987"></a> 987       #
</span><span class="inferred1"><a name="line988"></a> 988       #   class Invoice &lt; ActiveRecord::Base; end;
</span><span class="inferred0"><a name="line989"></a> 989       #   file                  class               table_name
</span><span class="inferred1"><a name="line990"></a> 990       #   invoice.rb            Invoice             invoices
</span><span class="inferred0"><a name="line991"></a> 991       #
</span><span class="inferred1"><a name="line992"></a> 992       #   class Invoice &lt; ActiveRecord::Base; class Lineitem &lt; ActiveRecord::Base; end; end;
</span><span class="inferred0"><a name="line993"></a> 993       #   file                  class               table_name
</span><span class="inferred1"><a name="line994"></a> 994       #   invoice.rb            Invoice::Lineitem   invoice_lineitems
</span><span class="inferred0"><a name="line995"></a> 995       #
</span><span class="inferred1"><a name="line996"></a> 996       #   module Invoice; class Lineitem &lt; ActiveRecord::Base; end; end;
</span><span class="inferred0"><a name="line997"></a> 997       #   file                  class               table_name
</span><span class="inferred1"><a name="line998"></a> 998       #   invoice/lineitem.rb   Invoice::Lineitem   lineitems
</span><span class="inferred0"><a name="line999"></a> 999       #
</span><span class="inferred1"><a name="line1000"></a>1000       # Additionally, the class-level +table_name_prefix+ is prepended and the
</span><span class="inferred0"><a name="line1001"></a>1001       # +table_name_suffix+ is appended.  So if you have &quot;myapp_&quot; as a prefix,
</span><span class="inferred1"><a name="line1002"></a>1002       # the table name guess for an Invoice class becomes &quot;myapp_invoices&quot;.
</span><span class="inferred0"><a name="line1003"></a>1003       # Invoice::Lineitem becomes &quot;myapp_invoice_lineitems&quot;.
</span><span class="inferred1"><a name="line1004"></a>1004       #
</span><span class="inferred0"><a name="line1005"></a>1005       # You can also overwrite this class method to allow for unguessable
</span><span class="inferred1"><a name="line1006"></a>1006       # links, such as a Mouse class with a link to a &quot;mice&quot; table. Example:
</span><span class="inferred0"><a name="line1007"></a>1007       #
</span><span class="inferred1"><a name="line1008"></a>1008       #   class Mouse &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line1009"></a>1009       #     set_table_name &quot;mice&quot;
</span><span class="inferred1"><a name="line1010"></a>1010       #   end
</span><span class="marked0"><a name="line1011"></a>1011       def table_name
</span><span class="marked1"><a name="line1012"></a>1012         reset_table_name
</span><span class="marked0"><a name="line1013"></a>1013       end
</span><span class="inferred1"><a name="line1014"></a>1014 
</span><span class="marked0"><a name="line1015"></a>1015       def reset_table_name #:nodoc:
</span><span class="marked1"><a name="line1016"></a>1016         base = base_class
</span><span class="inferred0"><a name="line1017"></a>1017 
</span><span class="marked1"><a name="line1018"></a>1018         name =
</span><span class="inferred0"><a name="line1019"></a>1019           # STI subclasses always use their superclass' table.
</span><span class="marked1"><a name="line1020"></a>1020           unless self == base
</span><span class="uncovered0"><a name="line1021"></a>1021             base.table_name
</span><span class="inferred1"><a name="line1022"></a>1022           else
</span><span class="inferred0"><a name="line1023"></a>1023             # Nested classes are prefixed with singular parent table name.
</span><span class="marked1"><a name="line1024"></a>1024             if parent &lt; ActiveRecord::Base &amp;&amp; !parent.abstract_class?
</span><span class="uncovered0"><a name="line1025"></a>1025               contained = parent.table_name
</span><span class="uncovered1"><a name="line1026"></a>1026               contained = contained.singularize if parent.pluralize_table_names
</span><span class="uncovered0"><a name="line1027"></a>1027               contained &lt;&lt; '_'
</span><span class="uncovered1"><a name="line1028"></a>1028             end
</span><span class="marked0"><a name="line1029"></a>1029             name = &quot;#{table_name_prefix}#{contained}#{undecorated_table_name(base.name)}#{table_name_suffix}&quot;
</span><span class="inferred1"><a name="line1030"></a>1030           end
</span><span class="inferred0"><a name="line1031"></a>1031 
</span><span class="marked1"><a name="line1032"></a>1032         set_table_name(name)
</span><span class="marked0"><a name="line1033"></a>1033         name
</span><span class="inferred1"><a name="line1034"></a>1034       end
</span><span class="inferred0"><a name="line1035"></a>1035 
</span><span class="inferred1"><a name="line1036"></a>1036       # Defines the primary key field -- can be overridden in subclasses. Overwriting will negate any effect of the
</span><span class="inferred0"><a name="line1037"></a>1037       # primary_key_prefix_type setting, though.
</span><span class="marked1"><a name="line1038"></a>1038       def primary_key
</span><span class="marked0"><a name="line1039"></a>1039         reset_primary_key
</span><span class="marked1"><a name="line1040"></a>1040       end
</span><span class="inferred0"><a name="line1041"></a>1041 
</span><span class="marked1"><a name="line1042"></a>1042       def reset_primary_key #:nodoc:
</span><span class="marked0"><a name="line1043"></a>1043         key = get_primary_key(base_class.name)
</span><span class="marked1"><a name="line1044"></a>1044         set_primary_key(key)
</span><span class="marked0"><a name="line1045"></a>1045         key
</span><span class="inferred1"><a name="line1046"></a>1046       end
</span><span class="inferred0"><a name="line1047"></a>1047 
</span><span class="marked1"><a name="line1048"></a>1048       def get_primary_key(base_name) #:nodoc:
</span><span class="marked0"><a name="line1049"></a>1049         key = 'id'
</span><span class="marked1"><a name="line1050"></a>1050         case primary_key_prefix_type
</span><span class="marked0"><a name="line1051"></a>1051           when :table_name
</span><span class="uncovered1"><a name="line1052"></a>1052             key = base_name.to_s.foreign_key(false)
</span><span class="marked0"><a name="line1053"></a>1053           when :table_name_with_underscore
</span><span class="uncovered1"><a name="line1054"></a>1054             key = base_name.to_s.foreign_key
</span><span class="uncovered0"><a name="line1055"></a>1055         end
</span><span class="marked1"><a name="line1056"></a>1056         key
</span><span class="inferred0"><a name="line1057"></a>1057       end
</span><span class="inferred1"><a name="line1058"></a>1058 
</span><span class="inferred0"><a name="line1059"></a>1059       # Defines the column name for use with single table inheritance
</span><span class="inferred1"><a name="line1060"></a>1060       # -- can be set in subclasses like so: self.inheritance_column = &quot;type_id&quot;
</span><span class="marked0"><a name="line1061"></a>1061       def inheritance_column
</span><span class="marked1"><a name="line1062"></a>1062         @inheritance_column ||= &quot;type&quot;.freeze
</span><span class="marked0"><a name="line1063"></a>1063       end
</span><span class="inferred1"><a name="line1064"></a>1064 
</span><span class="inferred0"><a name="line1065"></a>1065       # Lazy-set the sequence name to the connection's default.  This method
</span><span class="inferred1"><a name="line1066"></a>1066       # is only ever called once since set_sequence_name overrides it.
</span><span class="marked0"><a name="line1067"></a>1067       def sequence_name #:nodoc:
</span><span class="uncovered1"><a name="line1068"></a>1068         reset_sequence_name
</span><span class="uncovered0"><a name="line1069"></a>1069       end
</span><span class="inferred1"><a name="line1070"></a>1070 
</span><span class="marked0"><a name="line1071"></a>1071       def reset_sequence_name #:nodoc:
</span><span class="uncovered1"><a name="line1072"></a>1072         default = connection.default_sequence_name(table_name, primary_key)
</span><span class="uncovered0"><a name="line1073"></a>1073         set_sequence_name(default)
</span><span class="uncovered1"><a name="line1074"></a>1074         default
</span><span class="uncovered0"><a name="line1075"></a>1075       end
</span><span class="inferred1"><a name="line1076"></a>1076 
</span><span class="inferred0"><a name="line1077"></a>1077       # Sets the table name to use to the given value, or (if the value
</span><span class="inferred1"><a name="line1078"></a>1078       # is nil or false) to the value returned by the given block.
</span><span class="inferred0"><a name="line1079"></a>1079       #
</span><span class="inferred1"><a name="line1080"></a>1080       #   class Project &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line1081"></a>1081       #     set_table_name &quot;project&quot;
</span><span class="inferred1"><a name="line1082"></a>1082       #   end
</span><span class="marked0"><a name="line1083"></a>1083       def set_table_name(value = nil, &amp;block)
</span><span class="marked1"><a name="line1084"></a>1084         define_attr_method :table_name, value, &amp;block
</span><span class="inferred0"><a name="line1085"></a>1085       end
</span><span class="marked1"><a name="line1086"></a>1086       alias :table_name= :set_table_name
</span><span class="inferred0"><a name="line1087"></a>1087 
</span><span class="inferred1"><a name="line1088"></a>1088       # Sets the name of the primary key column to use to the given value,
</span><span class="inferred0"><a name="line1089"></a>1089       # or (if the value is nil or false) to the value returned by the given
</span><span class="inferred1"><a name="line1090"></a>1090       # block.
</span><span class="inferred0"><a name="line1091"></a>1091       #
</span><span class="inferred1"><a name="line1092"></a>1092       #   class Project &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line1093"></a>1093       #     set_primary_key &quot;sysid&quot;
</span><span class="inferred1"><a name="line1094"></a>1094       #   end
</span><span class="marked0"><a name="line1095"></a>1095       def set_primary_key(value = nil, &amp;block)
</span><span class="marked1"><a name="line1096"></a>1096         define_attr_method :primary_key, value, &amp;block
</span><span class="inferred0"><a name="line1097"></a>1097       end
</span><span class="marked1"><a name="line1098"></a>1098       alias :primary_key= :set_primary_key
</span><span class="inferred0"><a name="line1099"></a>1099 
</span><span class="inferred1"><a name="line1100"></a>1100       # Sets the name of the inheritance column to use to the given value,
</span><span class="inferred0"><a name="line1101"></a>1101       # or (if the value # is nil or false) to the value returned by the
</span><span class="inferred1"><a name="line1102"></a>1102       # given block.
</span><span class="inferred0"><a name="line1103"></a>1103       #
</span><span class="inferred1"><a name="line1104"></a>1104       #   class Project &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line1105"></a>1105       #     set_inheritance_column do
</span><span class="inferred1"><a name="line1106"></a>1106       #       original_inheritance_column + &quot;_id&quot;
</span><span class="inferred0"><a name="line1107"></a>1107       #     end
</span><span class="inferred1"><a name="line1108"></a>1108       #   end
</span><span class="marked0"><a name="line1109"></a>1109       def set_inheritance_column(value = nil, &amp;block)
</span><span class="uncovered1"><a name="line1110"></a>1110         define_attr_method :inheritance_column, value, &amp;block
</span><span class="uncovered0"><a name="line1111"></a>1111       end
</span><span class="marked1"><a name="line1112"></a>1112       alias :inheritance_column= :set_inheritance_column
</span><span class="inferred0"><a name="line1113"></a>1113 
</span><span class="inferred1"><a name="line1114"></a>1114       # Sets the name of the sequence to use when generating ids to the given
</span><span class="inferred0"><a name="line1115"></a>1115       # value, or (if the value is nil or false) to the value returned by the
</span><span class="inferred1"><a name="line1116"></a>1116       # given block. This is required for Oracle and is useful for any
</span><span class="inferred0"><a name="line1117"></a>1117       # database which relies on sequences for primary key generation.
</span><span class="inferred1"><a name="line1118"></a>1118       #
</span><span class="inferred0"><a name="line1119"></a>1119       # If a sequence name is not explicitly set when using Oracle or Firebird,
</span><span class="inferred1"><a name="line1120"></a>1120       # it will default to the commonly used pattern of: #{table_name}_seq
</span><span class="inferred0"><a name="line1121"></a>1121       #
</span><span class="inferred1"><a name="line1122"></a>1122       # If a sequence name is not explicitly set when using PostgreSQL, it
</span><span class="inferred0"><a name="line1123"></a>1123       # will discover the sequence corresponding to your primary key for you.
</span><span class="inferred1"><a name="line1124"></a>1124       #
</span><span class="inferred0"><a name="line1125"></a>1125       #   class Project &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line1126"></a>1126       #     set_sequence_name &quot;projectseq&quot;   # default would have been &quot;project_seq&quot;
</span><span class="inferred0"><a name="line1127"></a>1127       #   end
</span><span class="marked1"><a name="line1128"></a>1128       def set_sequence_name(value = nil, &amp;block)
</span><span class="uncovered0"><a name="line1129"></a>1129         define_attr_method :sequence_name, value, &amp;block
</span><span class="uncovered1"><a name="line1130"></a>1130       end
</span><span class="marked0"><a name="line1131"></a>1131       alias :sequence_name= :set_sequence_name
</span><span class="inferred1"><a name="line1132"></a>1132 
</span><span class="inferred0"><a name="line1133"></a>1133       # Turns the +table_name+ back into a class name following the reverse rules of +table_name+.
</span><span class="marked1"><a name="line1134"></a>1134       def class_name(table_name = table_name) # :nodoc:
</span><span class="uncovered0"><a name="line1135"></a>1135         # remove any prefix and/or suffix from the table name
</span><span class="uncovered1"><a name="line1136"></a>1136         class_name = table_name[table_name_prefix.length..-(table_name_suffix.length + 1)].camelize
</span><span class="uncovered0"><a name="line1137"></a>1137         class_name = class_name.singularize if pluralize_table_names
</span><span class="uncovered1"><a name="line1138"></a>1138         class_name
</span><span class="uncovered0"><a name="line1139"></a>1139       end
</span><span class="inferred1"><a name="line1140"></a>1140 
</span><span class="inferred0"><a name="line1141"></a>1141       # Indicates whether the table associated with this class exists
</span><span class="marked1"><a name="line1142"></a>1142       def table_exists?
</span><span class="uncovered0"><a name="line1143"></a>1143         connection.table_exists?(table_name)
</span><span class="uncovered1"><a name="line1144"></a>1144       end
</span><span class="inferred0"><a name="line1145"></a>1145 
</span><span class="inferred1"><a name="line1146"></a>1146       # Returns an array of column objects for the table associated with this class.
</span><span class="marked0"><a name="line1147"></a>1147       def columns
</span><span class="marked1"><a name="line1148"></a>1148         unless defined?(@columns) &amp;&amp; @columns
</span><span class="marked0"><a name="line1149"></a>1149           @columns = connection.columns(table_name, &quot;#{name} Columns&quot;)
</span><span class="marked1"><a name="line1150"></a>1150           @columns.each { |column| column.primary = column.name == primary_key }
</span><span class="inferred0"><a name="line1151"></a>1151         end
</span><span class="marked1"><a name="line1152"></a>1152         @columns
</span><span class="inferred0"><a name="line1153"></a>1153       end
</span><span class="inferred1"><a name="line1154"></a>1154 
</span><span class="inferred0"><a name="line1155"></a>1155       # Returns a hash of column objects for the table associated with this class.
</span><span class="marked1"><a name="line1156"></a>1156       def columns_hash
</span><span class="marked0"><a name="line1157"></a>1157         @columns_hash ||= columns.inject({}) { |hash, column| hash[column.name] = column; hash }
</span><span class="marked1"><a name="line1158"></a>1158       end
</span><span class="inferred0"><a name="line1159"></a>1159 
</span><span class="inferred1"><a name="line1160"></a>1160       # Returns an array of column names as strings.
</span><span class="marked0"><a name="line1161"></a>1161       def column_names
</span><span class="uncovered1"><a name="line1162"></a>1162         @column_names ||= columns.map { |column| column.name }
</span><span class="uncovered0"><a name="line1163"></a>1163       end
</span><span class="inferred1"><a name="line1164"></a>1164 
</span><span class="inferred0"><a name="line1165"></a>1165       # Returns an array of column objects where the primary id, all columns ending in &quot;_id&quot; or &quot;_count&quot;,
</span><span class="inferred1"><a name="line1166"></a>1166       # and columns used for single table inheritance have been removed.
</span><span class="marked0"><a name="line1167"></a>1167       def content_columns
</span><span class="uncovered1"><a name="line1168"></a>1168         @content_columns ||= columns.reject { |c| c.primary || c.name =~ /(_id|_count)$/ || c.name == inheritance_column }
</span><span class="uncovered0"><a name="line1169"></a>1169       end
</span><span class="inferred1"><a name="line1170"></a>1170 
</span><span class="inferred0"><a name="line1171"></a>1171       # Returns a hash of all the methods added to query each of the columns in the table with the name of the method as the key
</span><span class="inferred1"><a name="line1172"></a>1172       # and true as the value. This makes it possible to do O(1) lookups in respond_to? to check if a given method for attribute
</span><span class="inferred0"><a name="line1173"></a>1173       # is available.
</span><span class="marked1"><a name="line1174"></a>1174       def column_methods_hash #:nodoc:
</span><span class="uncovered0"><a name="line1175"></a>1175         @dynamic_methods_hash ||= column_names.inject(Hash.new(false)) do |methods, attr|
</span><span class="uncovered1"><a name="line1176"></a>1176           attr_name = attr.to_s
</span><span class="uncovered0"><a name="line1177"></a>1177           methods[attr.to_sym]       = attr_name
</span><span class="uncovered1"><a name="line1178"></a>1178           methods[&quot;#{attr}=&quot;.to_sym] = attr_name
</span><span class="uncovered0"><a name="line1179"></a>1179           methods[&quot;#{attr}?&quot;.to_sym] = attr_name
</span><span class="uncovered1"><a name="line1180"></a>1180           methods[&quot;#{attr}_before_type_cast&quot;.to_sym] = attr_name
</span><span class="uncovered0"><a name="line1181"></a>1181           methods
</span><span class="uncovered1"><a name="line1182"></a>1182         end
</span><span class="uncovered0"><a name="line1183"></a>1183       end
</span><span class="inferred1"><a name="line1184"></a>1184 
</span><span class="inferred0"><a name="line1185"></a>1185       # Resets all the cached information about columns, which will cause them to be reloaded on the next request.
</span><span class="marked1"><a name="line1186"></a>1186       def reset_column_information
</span><span class="uncovered0"><a name="line1187"></a>1187         generated_methods.each { |name| undef_method(name) }
</span><span class="uncovered1"><a name="line1188"></a>1188         @column_names = @columns = @columns_hash = @content_columns = @dynamic_methods_hash = @generated_methods = @inheritance_column = nil
</span><span class="uncovered0"><a name="line1189"></a>1189       end
</span><span class="inferred1"><a name="line1190"></a>1190 
</span><span class="marked0"><a name="line1191"></a>1191       def reset_column_information_and_inheritable_attributes_for_all_subclasses#:nodoc:
</span><span class="uncovered1"><a name="line1192"></a>1192         subclasses.each { |klass| klass.reset_inheritable_attributes; klass.reset_column_information }
</span><span class="uncovered0"><a name="line1193"></a>1193       end
</span><span class="inferred1"><a name="line1194"></a>1194 
</span><span class="inferred0"><a name="line1195"></a>1195       # Transforms attribute key names into a more humane format, such as &quot;First name&quot; instead of &quot;first_name&quot;. Example:
</span><span class="inferred1"><a name="line1196"></a>1196       #   Person.human_attribute_name(&quot;first_name&quot;) # =&gt; &quot;First name&quot;
</span><span class="inferred0"><a name="line1197"></a>1197       # Deprecated in favor of just calling &quot;first_name&quot;.humanize
</span><span class="marked1"><a name="line1198"></a>1198       def human_attribute_name(attribute_key_name) #:nodoc:
</span><span class="uncovered0"><a name="line1199"></a>1199         attribute_key_name.humanize
</span><span class="uncovered1"><a name="line1200"></a>1200       end
</span><span class="inferred0"><a name="line1201"></a>1201 
</span><span class="inferred1"><a name="line1202"></a>1202       # True if this isn't a concrete subclass needing a STI type condition.
</span><span class="marked0"><a name="line1203"></a>1203       def descends_from_active_record?
</span><span class="uncovered1"><a name="line1204"></a>1204         if superclass.abstract_class?
</span><span class="uncovered0"><a name="line1205"></a>1205           superclass.descends_from_active_record?
</span><span class="uncovered1"><a name="line1206"></a>1206         else
</span><span class="uncovered0"><a name="line1207"></a>1207           superclass == Base || !columns_hash.include?(inheritance_column)
</span><span class="uncovered1"><a name="line1208"></a>1208         end
</span><span class="uncovered0"><a name="line1209"></a>1209       end
</span><span class="inferred1"><a name="line1210"></a>1210 
</span><span class="marked0"><a name="line1211"></a>1211       def finder_needs_type_condition? #:nodoc:
</span><span class="uncovered1"><a name="line1212"></a>1212         # This is like this because benchmarking justifies the strange :false stuff
</span><span class="uncovered0"><a name="line1213"></a>1213         :true == (@finder_needs_type_condition ||= descends_from_active_record? ? :false : :true)
</span><span class="uncovered1"><a name="line1214"></a>1214       end
</span><span class="inferred0"><a name="line1215"></a>1215 
</span><span class="inferred1"><a name="line1216"></a>1216       # Returns a string like 'Post id:integer, title:string, body:text'
</span><span class="marked0"><a name="line1217"></a>1217       def inspect
</span><span class="uncovered1"><a name="line1218"></a>1218         if self == Base
</span><span class="uncovered0"><a name="line1219"></a>1219           super
</span><span class="uncovered1"><a name="line1220"></a>1220         elsif abstract_class?
</span><span class="uncovered0"><a name="line1221"></a>1221           &quot;#{super}(abstract)&quot;
</span><span class="uncovered1"><a name="line1222"></a>1222         elsif table_exists?
</span><span class="uncovered0"><a name="line1223"></a>1223           attr_list = columns.map { |c| &quot;#{c.name}: #{c.type}&quot; } * ', '
</span><span class="uncovered1"><a name="line1224"></a>1224           &quot;#{super}(#{attr_list})&quot;
</span><span class="uncovered0"><a name="line1225"></a>1225         else
</span><span class="uncovered1"><a name="line1226"></a>1226           &quot;#{super}(Table doesn't exist)&quot;
</span><span class="uncovered0"><a name="line1227"></a>1227         end
</span><span class="uncovered1"><a name="line1228"></a>1228       end
</span><span class="inferred0"><a name="line1229"></a>1229 
</span><span class="inferred1"><a name="line1230"></a>1230 
</span><span class="marked0"><a name="line1231"></a>1231       def quote_value(value, column = nil) #:nodoc:
</span><span class="uncovered1"><a name="line1232"></a>1232         connection.quote(value,column)
</span><span class="uncovered0"><a name="line1233"></a>1233       end
</span><span class="inferred1"><a name="line1234"></a>1234 
</span><span class="inferred0"><a name="line1235"></a>1235       # Used to sanitize objects before they're used in an SQL SELECT statement. Delegates to &lt;tt&gt;connection.quote&lt;/tt&gt;.
</span><span class="marked1"><a name="line1236"></a>1236       def sanitize(object) #:nodoc:
</span><span class="uncovered0"><a name="line1237"></a>1237         connection.quote(object)
</span><span class="uncovered1"><a name="line1238"></a>1238       end
</span><span class="inferred0"><a name="line1239"></a>1239 
</span><span class="inferred1"><a name="line1240"></a>1240       # Log and benchmark multiple statements in a single block. Example:
</span><span class="inferred0"><a name="line1241"></a>1241       #
</span><span class="inferred1"><a name="line1242"></a>1242       #   Project.benchmark(&quot;Creating project&quot;) do
</span><span class="inferred0"><a name="line1243"></a>1243       #     project = Project.create(&quot;name&quot; =&gt; &quot;stuff&quot;)
</span><span class="inferred1"><a name="line1244"></a>1244       #     project.create_manager(&quot;name&quot; =&gt; &quot;David&quot;)
</span><span class="inferred0"><a name="line1245"></a>1245       #     project.milestones &lt;&lt; Milestone.find(:all)
</span><span class="inferred1"><a name="line1246"></a>1246       #   end
</span><span class="inferred0"><a name="line1247"></a>1247       #
</span><span class="inferred1"><a name="line1248"></a>1248       # The benchmark is only recorded if the current level of the logger is less than or equal to the &lt;tt&gt;log_level&lt;/tt&gt;,
</span><span class="inferred0"><a name="line1249"></a>1249       # which makes it easy to include benchmarking statements in production software that will remain inexpensive because
</span><span class="inferred1"><a name="line1250"></a>1250       # the benchmark will only be conducted if the log level is low enough.
</span><span class="inferred0"><a name="line1251"></a>1251       #
</span><span class="inferred1"><a name="line1252"></a>1252       # The logging of the multiple statements is turned off unless &lt;tt&gt;use_silence&lt;/tt&gt; is set to false.
</span><span class="marked0"><a name="line1253"></a>1253       def benchmark(title, log_level = Logger::DEBUG, use_silence = true)
</span><span class="uncovered1"><a name="line1254"></a>1254         if logger &amp;&amp; logger.level &lt;= log_level
</span><span class="uncovered0"><a name="line1255"></a>1255           result = nil
</span><span class="uncovered1"><a name="line1256"></a>1256           seconds = Benchmark.realtime { result = use_silence ? silence { yield } : yield }
</span><span class="uncovered0"><a name="line1257"></a>1257           logger.add(log_level, &quot;#{title} (#{'%.5f' % seconds})&quot;)
</span><span class="uncovered1"><a name="line1258"></a>1258           result
</span><span class="uncovered0"><a name="line1259"></a>1259         else
</span><span class="uncovered1"><a name="line1260"></a>1260           yield
</span><span class="uncovered0"><a name="line1261"></a>1261         end
</span><span class="uncovered1"><a name="line1262"></a>1262       end
</span><span class="inferred0"><a name="line1263"></a>1263 
</span><span class="inferred1"><a name="line1264"></a>1264       # Silences the logger for the duration of the block.
</span><span class="marked0"><a name="line1265"></a>1265       def silence
</span><span class="marked1"><a name="line1266"></a>1266         old_logger_level, logger.level = logger.level, Logger::ERROR if logger
</span><span class="marked0"><a name="line1267"></a>1267         yield
</span><span class="inferred1"><a name="line1268"></a>1268       ensure
</span><span class="marked0"><a name="line1269"></a>1269         logger.level = old_logger_level if logger
</span><span class="marked1"><a name="line1270"></a>1270       end
</span><span class="inferred0"><a name="line1271"></a>1271 
</span><span class="inferred1"><a name="line1272"></a>1272       # Overwrite the default class equality method to provide support for association proxies.
</span><span class="marked0"><a name="line1273"></a>1273       def ===(object)
</span><span class="uncovered1"><a name="line1274"></a>1274         object.is_a?(self)
</span><span class="uncovered0"><a name="line1275"></a>1275       end
</span><span class="inferred1"><a name="line1276"></a>1276 
</span><span class="inferred0"><a name="line1277"></a>1277       # Returns the base AR subclass that this class descends from. If A
</span><span class="inferred1"><a name="line1278"></a>1278       # extends AR::Base, A.base_class will return A. If B descends from A
</span><span class="inferred0"><a name="line1279"></a>1279       # through some arbitrarily deep hierarchy, B.base_class will return A.
</span><span class="marked1"><a name="line1280"></a>1280       def base_class
</span><span class="marked0"><a name="line1281"></a>1281         class_of_active_record_descendant(self)
</span><span class="marked1"><a name="line1282"></a>1282       end
</span><span class="inferred0"><a name="line1283"></a>1283 
</span><span class="inferred1"><a name="line1284"></a>1284       # Set this to true if this is an abstract class (see &lt;tt&gt;abstract_class?&lt;/tt&gt;).
</span><span class="marked0"><a name="line1285"></a>1285       attr_accessor :abstract_class
</span><span class="inferred1"><a name="line1286"></a>1286 
</span><span class="inferred0"><a name="line1287"></a>1287       # Returns whether this class is a base AR class.  If A is a base class and
</span><span class="inferred1"><a name="line1288"></a>1288       # B descends from A, then B.base_class will return B.
</span><span class="marked0"><a name="line1289"></a>1289       def abstract_class?
</span><span class="uncovered1"><a name="line1290"></a>1290         defined?(@abstract_class) &amp;&amp; @abstract_class == true
</span><span class="uncovered0"><a name="line1291"></a>1291       end
</span><span class="inferred1"><a name="line1292"></a>1292 
</span><span class="marked0"><a name="line1293"></a>1293       def respond_to?(method_id, include_private = false)
</span><span class="marked1"><a name="line1294"></a>1294         if match = matches_dynamic_finder?(method_id) || matches_dynamic_finder_with_initialize_or_create?(method_id)
</span><span class="uncovered0"><a name="line1295"></a>1295           return true if all_attributes_exists?(extract_attribute_names_from_match(match))
</span><span class="uncovered1"><a name="line1296"></a>1296         end
</span><span class="marked0"><a name="line1297"></a>1297         super
</span><span class="inferred1"><a name="line1298"></a>1298       end
</span><span class="inferred0"><a name="line1299"></a>1299 
</span><span class="marked1"><a name="line1300"></a>1300       def sti_name
</span><span class="uncovered0"><a name="line1301"></a>1301         store_full_sti_class ? name : name.demodulize
</span><span class="uncovered1"><a name="line1302"></a>1302       end
</span><span class="inferred0"><a name="line1303"></a>1303 
</span><span class="marked1"><a name="line1304"></a>1304       private
</span><span class="marked0"><a name="line1305"></a>1305         def find_initial(options)
</span><span class="uncovered1"><a name="line1306"></a>1306           options.update(:limit =&gt; 1)
</span><span class="uncovered0"><a name="line1307"></a>1307           find_every(options).first
</span><span class="uncovered1"><a name="line1308"></a>1308         end
</span><span class="inferred0"><a name="line1309"></a>1309 
</span><span class="marked1"><a name="line1310"></a>1310         def find_last(options)
</span><span class="uncovered0"><a name="line1311"></a>1311           order = options[:order]
</span><span class="uncovered1"><a name="line1312"></a>1312 
</span><span class="uncovered0"><a name="line1313"></a>1313           if order
</span><span class="uncovered1"><a name="line1314"></a>1314             order = reverse_sql_order(order)
</span><span class="uncovered0"><a name="line1315"></a>1315           elsif !scoped?(:find, :order)
</span><span class="uncovered1"><a name="line1316"></a>1316             order = &quot;#{table_name}.#{primary_key} DESC&quot;
</span><span class="uncovered0"><a name="line1317"></a>1317           end
</span><span class="uncovered1"><a name="line1318"></a>1318 
</span><span class="uncovered0"><a name="line1319"></a>1319           if scoped?(:find, :order)
</span><span class="uncovered1"><a name="line1320"></a>1320             scoped_order = reverse_sql_order(scope(:find, :order))
</span><span class="uncovered0"><a name="line1321"></a>1321             scoped_methods.select { |s| s[:find].update(:order =&gt; scoped_order) }
</span><span class="uncovered1"><a name="line1322"></a>1322           end
</span><span class="uncovered0"><a name="line1323"></a>1323 
</span><span class="uncovered1"><a name="line1324"></a>1324           find_initial(options.merge({ :order =&gt; order }))
</span><span class="uncovered0"><a name="line1325"></a>1325         end
</span><span class="inferred1"><a name="line1326"></a>1326 
</span><span class="marked0"><a name="line1327"></a>1327         def reverse_sql_order(order_query)
</span><span class="uncovered1"><a name="line1328"></a>1328           reversed_query = order_query.split(/,/).each { |s|
</span><span class="uncovered0"><a name="line1329"></a>1329             if s.match(/\s(asc|ASC)$/)
</span><span class="uncovered1"><a name="line1330"></a>1330               s.gsub!(/\s(asc|ASC)$/, ' DESC')
</span><span class="uncovered0"><a name="line1331"></a>1331             elsif s.match(/\s(desc|DESC)$/)
</span><span class="uncovered1"><a name="line1332"></a>1332               s.gsub!(/\s(desc|DESC)$/, ' ASC')
</span><span class="uncovered0"><a name="line1333"></a>1333             elsif !s.match(/\s(asc|ASC|desc|DESC)$/)
</span><span class="uncovered1"><a name="line1334"></a>1334               s.concat(' DESC')
</span><span class="uncovered0"><a name="line1335"></a>1335             end
</span><span class="uncovered1"><a name="line1336"></a>1336           }.join(',')
</span><span class="uncovered0"><a name="line1337"></a>1337         end
</span><span class="inferred1"><a name="line1338"></a>1338 
</span><span class="marked0"><a name="line1339"></a>1339         def find_every(options)
</span><span class="uncovered1"><a name="line1340"></a>1340           include_associations = merge_includes(scope(:find, :include), options[:include])
</span><span class="uncovered0"><a name="line1341"></a>1341 
</span><span class="uncovered1"><a name="line1342"></a>1342           if include_associations.any? &amp;&amp; references_eager_loaded_tables?(options)
</span><span class="uncovered0"><a name="line1343"></a>1343             records = find_with_associations(options)
</span><span class="uncovered1"><a name="line1344"></a>1344           else
</span><span class="uncovered0"><a name="line1345"></a>1345             records = find_by_sql(construct_finder_sql(options))
</span><span class="uncovered1"><a name="line1346"></a>1346             if include_associations.any?
</span><span class="uncovered0"><a name="line1347"></a>1347               preload_associations(records, include_associations)
</span><span class="uncovered1"><a name="line1348"></a>1348             end
</span><span class="uncovered0"><a name="line1349"></a>1349           end
</span><span class="uncovered1"><a name="line1350"></a>1350 
</span><span class="uncovered0"><a name="line1351"></a>1351           records.each { |record| record.readonly! } if options[:readonly]
</span><span class="uncovered1"><a name="line1352"></a>1352 
</span><span class="uncovered0"><a name="line1353"></a>1353           records
</span><span class="uncovered1"><a name="line1354"></a>1354         end
</span><span class="inferred0"><a name="line1355"></a>1355 
</span><span class="marked1"><a name="line1356"></a>1356         def find_from_ids(ids, options)
</span><span class="uncovered0"><a name="line1357"></a>1357           expects_array = ids.first.kind_of?(Array)
</span><span class="uncovered1"><a name="line1358"></a>1358           return ids.first if expects_array &amp;&amp; ids.first.empty?
</span><span class="uncovered0"><a name="line1359"></a>1359 
</span><span class="uncovered1"><a name="line1360"></a>1360           ids = ids.flatten.compact.uniq
</span><span class="uncovered0"><a name="line1361"></a>1361 
</span><span class="uncovered1"><a name="line1362"></a>1362           case ids.size
</span><span class="uncovered0"><a name="line1363"></a>1363             when 0
</span><span class="uncovered1"><a name="line1364"></a>1364               raise RecordNotFound, &quot;Couldn't find #{name} without an ID&quot;
</span><span class="uncovered0"><a name="line1365"></a>1365             when 1
</span><span class="uncovered1"><a name="line1366"></a>1366               result = find_one(ids.first, options)
</span><span class="uncovered0"><a name="line1367"></a>1367               expects_array ? [ result ] : result
</span><span class="uncovered1"><a name="line1368"></a>1368             else
</span><span class="uncovered0"><a name="line1369"></a>1369               find_some(ids, options)
</span><span class="uncovered1"><a name="line1370"></a>1370           end
</span><span class="uncovered0"><a name="line1371"></a>1371         end
</span><span class="inferred1"><a name="line1372"></a>1372 
</span><span class="marked0"><a name="line1373"></a>1373         def find_one(id, options)
</span><span class="uncovered1"><a name="line1374"></a>1374           conditions = &quot; AND (#{sanitize_sql(options[:conditions])})&quot; if options[:conditions]
</span><span class="uncovered0"><a name="line1375"></a>1375           options.update :conditions =&gt; &quot;#{quoted_table_name}.#{connection.quote_column_name(primary_key)} = #{quote_value(id,columns_hash[primary_key])}#{conditions}&quot;
</span><span class="uncovered1"><a name="line1376"></a>1376 
</span><span class="uncovered0"><a name="line1377"></a>1377           # Use find_every(options).first since the primary key condition
</span><span class="uncovered1"><a name="line1378"></a>1378           # already ensures we have a single record. Using find_initial adds
</span><span class="uncovered0"><a name="line1379"></a>1379           # a superfluous :limit =&gt; 1.
</span><span class="uncovered1"><a name="line1380"></a>1380           if result = find_every(options).first
</span><span class="uncovered0"><a name="line1381"></a>1381             result
</span><span class="uncovered1"><a name="line1382"></a>1382           else
</span><span class="uncovered0"><a name="line1383"></a>1383             raise RecordNotFound, &quot;Couldn't find #{name} with ID=#{id}#{conditions}&quot;
</span><span class="uncovered1"><a name="line1384"></a>1384           end
</span><span class="uncovered0"><a name="line1385"></a>1385         end
</span><span class="inferred1"><a name="line1386"></a>1386 
</span><span class="marked0"><a name="line1387"></a>1387         def find_some(ids, options)
</span><span class="uncovered1"><a name="line1388"></a>1388           conditions = &quot; AND (#{sanitize_sql(options[:conditions])})&quot; if options[:conditions]
</span><span class="uncovered0"><a name="line1389"></a>1389           ids_list   = ids.map { |id| quote_value(id,columns_hash[primary_key]) }.join(',')
</span><span class="uncovered1"><a name="line1390"></a>1390           options.update :conditions =&gt; &quot;#{quoted_table_name}.#{connection.quote_column_name(primary_key)} IN (#{ids_list})#{conditions}&quot;
</span><span class="uncovered0"><a name="line1391"></a>1391 
</span><span class="uncovered1"><a name="line1392"></a>1392           result = find_every(options)
</span><span class="uncovered0"><a name="line1393"></a>1393 
</span><span class="uncovered1"><a name="line1394"></a>1394           # Determine expected size from limit and offset, not just ids.size.
</span><span class="uncovered0"><a name="line1395"></a>1395           expected_size =
</span><span class="uncovered1"><a name="line1396"></a>1396             if options[:limit] &amp;&amp; ids.size &gt; options[:limit]
</span><span class="uncovered0"><a name="line1397"></a>1397               options[:limit]
</span><span class="uncovered1"><a name="line1398"></a>1398             else
</span><span class="uncovered0"><a name="line1399"></a>1399               ids.size
</span><span class="uncovered1"><a name="line1400"></a>1400             end
</span><span class="uncovered0"><a name="line1401"></a>1401 
</span><span class="uncovered1"><a name="line1402"></a>1402           # 11 ids with limit 3, offset 9 should give 2 results.
</span><span class="uncovered0"><a name="line1403"></a>1403           if options[:offset] &amp;&amp; (ids.size - options[:offset] &lt; expected_size)
</span><span class="uncovered1"><a name="line1404"></a>1404             expected_size = ids.size - options[:offset]
</span><span class="uncovered0"><a name="line1405"></a>1405           end
</span><span class="uncovered1"><a name="line1406"></a>1406 
</span><span class="uncovered0"><a name="line1407"></a>1407           if result.size == expected_size
</span><span class="uncovered1"><a name="line1408"></a>1408             result
</span><span class="uncovered0"><a name="line1409"></a>1409           else
</span><span class="uncovered1"><a name="line1410"></a>1410             raise RecordNotFound, &quot;Couldn't find all #{name.pluralize} with IDs (#{ids_list})#{conditions} (found #{result.size} results, but was looking for #{expected_size})&quot;
</span><span class="uncovered0"><a name="line1411"></a>1411           end
</span><span class="uncovered1"><a name="line1412"></a>1412         end
</span><span class="inferred0"><a name="line1413"></a>1413 
</span><span class="inferred1"><a name="line1414"></a>1414         # Finder methods must instantiate through this method to work with the
</span><span class="inferred0"><a name="line1415"></a>1415         # single-table inheritance model that makes it possible to create
</span><span class="inferred1"><a name="line1416"></a>1416         # objects of different types from the same table.
</span><span class="marked0"><a name="line1417"></a>1417         def instantiate(record)
</span><span class="uncovered1"><a name="line1418"></a>1418           object =
</span><span class="uncovered0"><a name="line1419"></a>1419             if subclass_name = record[inheritance_column]
</span><span class="uncovered1"><a name="line1420"></a>1420               # No type given.
</span><span class="uncovered0"><a name="line1421"></a>1421               if subclass_name.empty?
</span><span class="uncovered1"><a name="line1422"></a>1422                 allocate
</span><span class="uncovered0"><a name="line1423"></a>1423 
</span><span class="uncovered1"><a name="line1424"></a>1424               else
</span><span class="uncovered0"><a name="line1425"></a>1425                 # Ignore type if no column is present since it was probably
</span><span class="uncovered1"><a name="line1426"></a>1426                 # pulled in from a sloppy join.
</span><span class="uncovered0"><a name="line1427"></a>1427                 unless columns_hash.include?(inheritance_column)
</span><span class="uncovered1"><a name="line1428"></a>1428                   allocate
</span><span class="uncovered0"><a name="line1429"></a>1429 
</span><span class="uncovered1"><a name="line1430"></a>1430                 else
</span><span class="uncovered0"><a name="line1431"></a>1431                   begin
</span><span class="uncovered1"><a name="line1432"></a>1432                     compute_type(subclass_name).allocate
</span><span class="uncovered0"><a name="line1433"></a>1433                   rescue NameError
</span><span class="uncovered1"><a name="line1434"></a>1434                     raise SubclassNotFound,
</span><span class="uncovered0"><a name="line1435"></a>1435                       &quot;The single-table inheritance mechanism failed to locate the subclass: '#{record[inheritance_column]}'. &quot; +
</span><span class="uncovered1"><a name="line1436"></a>1436                       &quot;This error is raised because the column '#{inheritance_column}' is reserved for storing the class in case of inheritance. &quot; +
</span><span class="uncovered0"><a name="line1437"></a>1437                       &quot;Please rename this column if you didn't intend it to be used for storing the inheritance class &quot; +
</span><span class="uncovered1"><a name="line1438"></a>1438                       &quot;or overwrite #{self.to_s}.inheritance_column to use another column for that information.&quot;
</span><span class="uncovered0"><a name="line1439"></a>1439                   end
</span><span class="uncovered1"><a name="line1440"></a>1440                 end
</span><span class="uncovered0"><a name="line1441"></a>1441               end
</span><span class="uncovered1"><a name="line1442"></a>1442             else
</span><span class="uncovered0"><a name="line1443"></a>1443               allocate
</span><span class="uncovered1"><a name="line1444"></a>1444             end
</span><span class="uncovered0"><a name="line1445"></a>1445 
</span><span class="uncovered1"><a name="line1446"></a>1446           object.instance_variable_set(&quot;@attributes&quot;, record)
</span><span class="uncovered0"><a name="line1447"></a>1447           object.instance_variable_set(&quot;@attributes_cache&quot;, Hash.new)
</span><span class="uncovered1"><a name="line1448"></a>1448 
</span><span class="uncovered0"><a name="line1449"></a>1449           if object.respond_to_without_attributes?(:after_find)
</span><span class="uncovered1"><a name="line1450"></a>1450             object.send(:callback, :after_find)
</span><span class="uncovered0"><a name="line1451"></a>1451           end
</span><span class="uncovered1"><a name="line1452"></a>1452 
</span><span class="uncovered0"><a name="line1453"></a>1453           if object.respond_to_without_attributes?(:after_initialize)
</span><span class="uncovered1"><a name="line1454"></a>1454             object.send(:callback, :after_initialize)
</span><span class="uncovered0"><a name="line1455"></a>1455           end
</span><span class="uncovered1"><a name="line1456"></a>1456 
</span><span class="uncovered0"><a name="line1457"></a>1457           object
</span><span class="uncovered1"><a name="line1458"></a>1458         end
</span><span class="inferred0"><a name="line1459"></a>1459 
</span><span class="inferred1"><a name="line1460"></a>1460         # Nest the type name in the same module as this class.
</span><span class="inferred0"><a name="line1461"></a>1461         # Bar is &quot;MyApp::Business::Bar&quot; relative to MyApp::Business::Foo
</span><span class="marked1"><a name="line1462"></a>1462         def type_name_with_module(type_name)
</span><span class="uncovered0"><a name="line1463"></a>1463           if store_full_sti_class
</span><span class="uncovered1"><a name="line1464"></a>1464             type_name
</span><span class="uncovered0"><a name="line1465"></a>1465           else
</span><span class="uncovered1"><a name="line1466"></a>1466             (/^::/ =~ type_name) ? type_name : &quot;#{parent.name}::#{type_name}&quot;
</span><span class="uncovered0"><a name="line1467"></a>1467           end
</span><span class="uncovered1"><a name="line1468"></a>1468         end
</span><span class="inferred0"><a name="line1469"></a>1469 
</span><span class="marked1"><a name="line1470"></a>1470         def construct_finder_sql(options)
</span><span class="uncovered0"><a name="line1471"></a>1471           scope = scope(:find)
</span><span class="uncovered1"><a name="line1472"></a>1472           sql  = &quot;SELECT #{options[:select] || (scope &amp;&amp; scope[:select]) || ((options[:joins] || (scope &amp;&amp; scope[:joins])) &amp;&amp; quoted_table_name + '.*') || '*'} &quot;
</span><span class="uncovered0"><a name="line1473"></a>1473           sql &lt;&lt; &quot;FROM #{(scope &amp;&amp; scope[:from]) || options[:from] || quoted_table_name} &quot;
</span><span class="uncovered1"><a name="line1474"></a>1474 
</span><span class="uncovered0"><a name="line1475"></a>1475           add_joins!(sql, options, scope)
</span><span class="uncovered1"><a name="line1476"></a>1476           add_conditions!(sql, options[:conditions], scope)
</span><span class="uncovered0"><a name="line1477"></a>1477 
</span><span class="uncovered1"><a name="line1478"></a>1478           add_group!(sql, options[:group], scope)
</span><span class="uncovered0"><a name="line1479"></a>1479           add_order!(sql, options[:order], scope)
</span><span class="uncovered1"><a name="line1480"></a>1480           add_limit!(sql, options, scope)
</span><span class="uncovered0"><a name="line1481"></a>1481           add_lock!(sql, options, scope)
</span><span class="uncovered1"><a name="line1482"></a>1482 
</span><span class="uncovered0"><a name="line1483"></a>1483           sql
</span><span class="uncovered1"><a name="line1484"></a>1484         end
</span><span class="inferred0"><a name="line1485"></a>1485 
</span><span class="inferred1"><a name="line1486"></a>1486         # Merges includes so that the result is a valid +include+
</span><span class="marked0"><a name="line1487"></a>1487         def merge_includes(first, second)
</span><span class="uncovered1"><a name="line1488"></a>1488          (safe_to_array(first) + safe_to_array(second)).uniq
</span><span class="uncovered0"><a name="line1489"></a>1489         end
</span><span class="inferred1"><a name="line1490"></a>1490 
</span><span class="inferred0"><a name="line1491"></a>1491         # Merges conditions so that the result is a valid +condition+
</span><span class="marked1"><a name="line1492"></a>1492         def merge_conditions(*conditions)
</span><span class="uncovered0"><a name="line1493"></a>1493           segments = []
</span><span class="uncovered1"><a name="line1494"></a>1494 
</span><span class="uncovered0"><a name="line1495"></a>1495           conditions.each do |condition|
</span><span class="uncovered1"><a name="line1496"></a>1496             unless condition.blank?
</span><span class="uncovered0"><a name="line1497"></a>1497               sql = sanitize_sql(condition)
</span><span class="uncovered1"><a name="line1498"></a>1498               segments &lt;&lt; sql unless sql.blank?
</span><span class="uncovered0"><a name="line1499"></a>1499             end
</span><span class="uncovered1"><a name="line1500"></a>1500           end
</span><span class="uncovered0"><a name="line1501"></a>1501 
</span><span class="uncovered1"><a name="line1502"></a>1502           &quot;(#{segments.join(') AND (')})&quot; unless segments.empty?
</span><span class="uncovered0"><a name="line1503"></a>1503         end
</span><span class="inferred1"><a name="line1504"></a>1504 
</span><span class="inferred0"><a name="line1505"></a>1505         # Object#to_a is deprecated, though it does have the desired behavior
</span><span class="marked1"><a name="line1506"></a>1506         def safe_to_array(o)
</span><span class="uncovered0"><a name="line1507"></a>1507           case o
</span><span class="uncovered1"><a name="line1508"></a>1508           when NilClass
</span><span class="uncovered0"><a name="line1509"></a>1509             []
</span><span class="uncovered1"><a name="line1510"></a>1510           when Array
</span><span class="uncovered0"><a name="line1511"></a>1511             o
</span><span class="uncovered1"><a name="line1512"></a>1512           else
</span><span class="uncovered0"><a name="line1513"></a>1513             [o]
</span><span class="uncovered1"><a name="line1514"></a>1514           end
</span><span class="uncovered0"><a name="line1515"></a>1515         end
</span><span class="inferred1"><a name="line1516"></a>1516 
</span><span class="marked0"><a name="line1517"></a>1517         def add_order!(sql, order, scope = :auto)
</span><span class="uncovered1"><a name="line1518"></a>1518           scope = scope(:find) if :auto == scope
</span><span class="uncovered0"><a name="line1519"></a>1519           scoped_order = scope[:order] if scope
</span><span class="uncovered1"><a name="line1520"></a>1520           if order
</span><span class="uncovered0"><a name="line1521"></a>1521             sql &lt;&lt; &quot; ORDER BY #{order}&quot;
</span><span class="uncovered1"><a name="line1522"></a>1522             sql &lt;&lt; &quot;, #{scoped_order}&quot; if scoped_order
</span><span class="uncovered0"><a name="line1523"></a>1523           else
</span><span class="uncovered1"><a name="line1524"></a>1524             sql &lt;&lt; &quot; ORDER BY #{scoped_order}&quot; if scoped_order
</span><span class="uncovered0"><a name="line1525"></a>1525           end
</span><span class="uncovered1"><a name="line1526"></a>1526         end
</span><span class="inferred0"><a name="line1527"></a>1527 
</span><span class="marked1"><a name="line1528"></a>1528         def add_group!(sql, group, scope = :auto)
</span><span class="uncovered0"><a name="line1529"></a>1529           if group
</span><span class="uncovered1"><a name="line1530"></a>1530             sql &lt;&lt; &quot; GROUP BY #{group}&quot;
</span><span class="uncovered0"><a name="line1531"></a>1531           else
</span><span class="uncovered1"><a name="line1532"></a>1532             scope = scope(:find) if :auto == scope
</span><span class="uncovered0"><a name="line1533"></a>1533             if scope &amp;&amp; (scoped_group = scope[:group])
</span><span class="uncovered1"><a name="line1534"></a>1534               sql &lt;&lt; &quot; GROUP BY #{scoped_group}&quot;
</span><span class="uncovered0"><a name="line1535"></a>1535             end
</span><span class="uncovered1"><a name="line1536"></a>1536           end
</span><span class="uncovered0"><a name="line1537"></a>1537         end
</span><span class="inferred1"><a name="line1538"></a>1538 
</span><span class="inferred0"><a name="line1539"></a>1539         # The optional scope argument is for the current &lt;tt&gt;:find&lt;/tt&gt; scope.
</span><span class="marked1"><a name="line1540"></a>1540         def add_limit!(sql, options, scope = :auto)
</span><span class="uncovered0"><a name="line1541"></a>1541           scope = scope(:find) if :auto == scope
</span><span class="uncovered1"><a name="line1542"></a>1542 
</span><span class="uncovered0"><a name="line1543"></a>1543           if scope
</span><span class="uncovered1"><a name="line1544"></a>1544             options[:limit] ||= scope[:limit]
</span><span class="uncovered0"><a name="line1545"></a>1545             options[:offset] ||= scope[:offset]
</span><span class="uncovered1"><a name="line1546"></a>1546           end
</span><span class="uncovered0"><a name="line1547"></a>1547 
</span><span class="uncovered1"><a name="line1548"></a>1548           connection.add_limit_offset!(sql, options)
</span><span class="uncovered0"><a name="line1549"></a>1549         end
</span><span class="inferred1"><a name="line1550"></a>1550 
</span><span class="inferred0"><a name="line1551"></a>1551         # The optional scope argument is for the current &lt;tt&gt;:find&lt;/tt&gt; scope.
</span><span class="inferred1"><a name="line1552"></a>1552         # The &lt;tt&gt;:lock&lt;/tt&gt; option has precedence over a scoped &lt;tt&gt;:lock&lt;/tt&gt;.
</span><span class="marked0"><a name="line1553"></a>1553         def add_lock!(sql, options, scope = :auto)
</span><span class="uncovered1"><a name="line1554"></a>1554           scope = scope(:find) if :auto == scope
</span><span class="uncovered0"><a name="line1555"></a>1555           options = options.reverse_merge(:lock =&gt; scope[:lock]) if scope
</span><span class="uncovered1"><a name="line1556"></a>1556           connection.add_lock!(sql, options)
</span><span class="uncovered0"><a name="line1557"></a>1557         end
</span><span class="inferred1"><a name="line1558"></a>1558 
</span><span class="inferred0"><a name="line1559"></a>1559         # The optional scope argument is for the current &lt;tt&gt;:find&lt;/tt&gt; scope.
</span><span class="marked1"><a name="line1560"></a>1560         def add_joins!(sql, options, scope = :auto)
</span><span class="uncovered0"><a name="line1561"></a>1561           scope = scope(:find) if :auto == scope
</span><span class="uncovered1"><a name="line1562"></a>1562           [(scope &amp;&amp; scope[:joins]), options[:joins]].each do |join|
</span><span class="uncovered0"><a name="line1563"></a>1563             case join
</span><span class="uncovered1"><a name="line1564"></a>1564             when Symbol, Hash, Array
</span><span class="uncovered0"><a name="line1565"></a>1565               join_dependency = ActiveRecord::Associations::ClassMethods::InnerJoinDependency.new(self, join, nil)
</span><span class="uncovered1"><a name="line1566"></a>1566               sql &lt;&lt; &quot; #{join_dependency.join_associations.collect { |assoc| assoc.association_join }.join} &quot;
</span><span class="uncovered0"><a name="line1567"></a>1567             else
</span><span class="uncovered1"><a name="line1568"></a>1568               sql &lt;&lt; &quot; #{join} &quot;
</span><span class="uncovered0"><a name="line1569"></a>1569             end
</span><span class="uncovered1"><a name="line1570"></a>1570           end
</span><span class="uncovered0"><a name="line1571"></a>1571         end
</span><span class="inferred1"><a name="line1572"></a>1572 
</span><span class="inferred0"><a name="line1573"></a>1573         # Adds a sanitized version of +conditions+ to the +sql+ string. Note that the passed-in +sql+ string is changed.
</span><span class="inferred1"><a name="line1574"></a>1574         # The optional scope argument is for the current &lt;tt&gt;:find&lt;/tt&gt; scope.
</span><span class="marked0"><a name="line1575"></a>1575         def add_conditions!(sql, conditions, scope = :auto)
</span><span class="uncovered1"><a name="line1576"></a>1576           scope = scope(:find) if :auto == scope
</span><span class="uncovered0"><a name="line1577"></a>1577           conditions = [conditions]
</span><span class="uncovered1"><a name="line1578"></a>1578           conditions &lt;&lt; scope[:conditions] if scope
</span><span class="uncovered0"><a name="line1579"></a>1579           conditions &lt;&lt; type_condition if finder_needs_type_condition?
</span><span class="uncovered1"><a name="line1580"></a>1580           merged_conditions = merge_conditions(*conditions)
</span><span class="uncovered0"><a name="line1581"></a>1581           sql &lt;&lt; &quot;WHERE #{merged_conditions} &quot; unless merged_conditions.blank?
</span><span class="uncovered1"><a name="line1582"></a>1582         end
</span><span class="inferred0"><a name="line1583"></a>1583 
</span><span class="marked1"><a name="line1584"></a>1584         def type_condition(table_alias=nil)
</span><span class="uncovered0"><a name="line1585"></a>1585           quoted_table_alias = self.connection.quote_table_name(table_alias || table_name)
</span><span class="uncovered1"><a name="line1586"></a>1586           quoted_inheritance_column = connection.quote_column_name(inheritance_column)
</span><span class="uncovered0"><a name="line1587"></a>1587           type_condition = subclasses.inject(&quot;#{quoted_table_alias}.#{quoted_inheritance_column} = '#{sti_name}' &quot;) do |condition, subclass|
</span><span class="uncovered1"><a name="line1588"></a>1588             condition &lt;&lt; &quot;OR #{quoted_table_alias}.#{quoted_inheritance_column} = '#{subclass.sti_name}' &quot;
</span><span class="uncovered0"><a name="line1589"></a>1589           end
</span><span class="uncovered1"><a name="line1590"></a>1590 
</span><span class="uncovered0"><a name="line1591"></a>1591           &quot; (#{type_condition}) &quot;
</span><span class="uncovered1"><a name="line1592"></a>1592         end
</span><span class="inferred0"><a name="line1593"></a>1593 
</span><span class="inferred1"><a name="line1594"></a>1594         # Guesses the table name, but does not decorate it with prefix and suffix information.
</span><span class="marked0"><a name="line1595"></a>1595         def undecorated_table_name(class_name = base_class.name)
</span><span class="marked1"><a name="line1596"></a>1596           table_name = class_name.to_s.demodulize.underscore
</span><span class="marked0"><a name="line1597"></a>1597           table_name = table_name.pluralize if pluralize_table_names
</span><span class="marked1"><a name="line1598"></a>1598           table_name
</span><span class="inferred0"><a name="line1599"></a>1599         end
</span><span class="inferred1"><a name="line1600"></a>1600 
</span><span class="inferred0"><a name="line1601"></a>1601         # Enables dynamic finders like find_by_user_name(user_name) and find_by_user_name_and_password(user_name, password) that are turned into
</span><span class="inferred1"><a name="line1602"></a>1602         # find(:first, :conditions =&gt; [&quot;user_name = ?&quot;, user_name]) and  find(:first, :conditions =&gt; [&quot;user_name = ? AND password = ?&quot;, user_name, password])
</span><span class="inferred0"><a name="line1603"></a>1603         # respectively. Also works for find(:all) by using find_all_by_amount(50) that is turned into find(:all, :conditions =&gt; [&quot;amount = ?&quot;, 50]).
</span><span class="inferred1"><a name="line1604"></a>1604         #
</span><span class="inferred0"><a name="line1605"></a>1605         # It's even possible to use all the additional parameters to find. For example, the full interface for find_all_by_amount
</span><span class="inferred1"><a name="line1606"></a>1606         # is actually find_all_by_amount(amount, options).
</span><span class="inferred0"><a name="line1607"></a>1607         #
</span><span class="inferred1"><a name="line1608"></a>1608         # This also enables you to initialize a record if it is not found, such as find_or_initialize_by_amount(amount)
</span><span class="inferred0"><a name="line1609"></a>1609         # or find_or_create_by_user_and_password(user, password).
</span><span class="inferred1"><a name="line1610"></a>1610         #
</span><span class="inferred0"><a name="line1611"></a>1611         # Each dynamic finder or initializer/creator is also defined in the class after it is first invoked, so that future
</span><span class="inferred1"><a name="line1612"></a>1612         # attempts to use it do not run through method_missing.
</span><span class="marked0"><a name="line1613"></a>1613         def method_missing(method_id, *arguments)
</span><span class="uncovered1"><a name="line1614"></a>1614           if match = matches_dynamic_finder?(method_id)
</span><span class="uncovered0"><a name="line1615"></a>1615             finder = determine_finder(match)
</span><span class="uncovered1"><a name="line1616"></a>1616 
</span><span class="uncovered0"><a name="line1617"></a>1617             attribute_names = extract_attribute_names_from_match(match)
</span><span class="uncovered1"><a name="line1618"></a>1618             super unless all_attributes_exists?(attribute_names)
</span><span class="uncovered0"><a name="line1619"></a>1619 
</span><span class="uncovered1"><a name="line1620"></a>1620             self.class_eval %{
</span><span class="uncovered0"><a name="line1621"></a>1621               def self.#{method_id}(*args)
</span><span class="uncovered1"><a name="line1622"></a>1622                 options = args.extract_options!
</span><span class="uncovered0"><a name="line1623"></a>1623                 attributes = construct_attributes_from_arguments([:#{attribute_names.join(',:')}], args)
</span><span class="uncovered1"><a name="line1624"></a>1624                 finder_options = { :conditions =&gt; attributes }
</span><span class="uncovered0"><a name="line1625"></a>1625                 validate_find_options(options)
</span><span class="uncovered1"><a name="line1626"></a>1626                 set_readonly_option!(options)
</span><span class="uncovered0"><a name="line1627"></a>1627 
</span><span class="uncovered1"><a name="line1628"></a>1628                 if options[:conditions]
</span><span class="uncovered0"><a name="line1629"></a>1629                   with_scope(:find =&gt; finder_options) do
</span><span class="uncovered1"><a name="line1630"></a>1630                     ActiveSupport::Deprecation.silence { send(:#{finder}, options) }
</span><span class="uncovered0"><a name="line1631"></a>1631                   end
</span><span class="uncovered1"><a name="line1632"></a>1632                 else
</span><span class="uncovered0"><a name="line1633"></a>1633                   ActiveSupport::Deprecation.silence { send(:#{finder}, options.merge(finder_options)) }
</span><span class="uncovered1"><a name="line1634"></a>1634                 end
</span><span class="uncovered0"><a name="line1635"></a>1635               end
</span><span class="uncovered1"><a name="line1636"></a>1636             }, __FILE__, __LINE__
</span><span class="uncovered0"><a name="line1637"></a>1637             send(method_id, *arguments)
</span><span class="uncovered1"><a name="line1638"></a>1638           elsif match = matches_dynamic_finder_with_initialize_or_create?(method_id)
</span><span class="uncovered0"><a name="line1639"></a>1639             instantiator = determine_instantiator(match)
</span><span class="uncovered1"><a name="line1640"></a>1640             attribute_names = extract_attribute_names_from_match(match)
</span><span class="uncovered0"><a name="line1641"></a>1641             super unless all_attributes_exists?(attribute_names)
</span><span class="uncovered1"><a name="line1642"></a>1642 
</span><span class="uncovered0"><a name="line1643"></a>1643             self.class_eval %{
</span><span class="uncovered1"><a name="line1644"></a>1644               def self.#{method_id}(*args)
</span><span class="uncovered0"><a name="line1645"></a>1645                 guard_protected_attributes = false
</span><span class="uncovered1"><a name="line1646"></a>1646 
</span><span class="uncovered0"><a name="line1647"></a>1647                 if args[0].is_a?(Hash)
</span><span class="uncovered1"><a name="line1648"></a>1648                   guard_protected_attributes = true
</span><span class="uncovered0"><a name="line1649"></a>1649                   attributes = args[0].with_indifferent_access
</span><span class="uncovered1"><a name="line1650"></a>1650                   find_attributes = attributes.slice(*[:#{attribute_names.join(',:')}])
</span><span class="uncovered0"><a name="line1651"></a>1651                 else
</span><span class="uncovered1"><a name="line1652"></a>1652                   find_attributes = attributes = construct_attributes_from_arguments([:#{attribute_names.join(',:')}], args)
</span><span class="uncovered0"><a name="line1653"></a>1653                 end
</span><span class="uncovered1"><a name="line1654"></a>1654 
</span><span class="uncovered0"><a name="line1655"></a>1655                 options = { :conditions =&gt; find_attributes }
</span><span class="uncovered1"><a name="line1656"></a>1656                 set_readonly_option!(options)
</span><span class="uncovered0"><a name="line1657"></a>1657 
</span><span class="uncovered1"><a name="line1658"></a>1658                 record = find_initial(options)
</span><span class="uncovered0"><a name="line1659"></a>1659 
</span><span class="uncovered1"><a name="line1660"></a>1660                  if record.nil?
</span><span class="uncovered0"><a name="line1661"></a>1661                   record = self.new { |r| r.send(:attributes=, attributes, guard_protected_attributes) }
</span><span class="uncovered1"><a name="line1662"></a>1662                   #{'yield(record) if block_given?'}
</span><span class="uncovered0"><a name="line1663"></a>1663                   #{'record.save' if instantiator == :create}
</span><span class="uncovered1"><a name="line1664"></a>1664                   record
</span><span class="uncovered0"><a name="line1665"></a>1665                 else
</span><span class="uncovered1"><a name="line1666"></a>1666                   record
</span><span class="uncovered0"><a name="line1667"></a>1667                 end
</span><span class="uncovered1"><a name="line1668"></a>1668               end
</span><span class="uncovered0"><a name="line1669"></a>1669             }, __FILE__, __LINE__
</span><span class="uncovered1"><a name="line1670"></a>1670             send(method_id, *arguments)
</span><span class="uncovered0"><a name="line1671"></a>1671           else
</span><span class="uncovered1"><a name="line1672"></a>1672             super
</span><span class="uncovered0"><a name="line1673"></a>1673           end
</span><span class="uncovered1"><a name="line1674"></a>1674         end
</span><span class="inferred0"><a name="line1675"></a>1675 
</span><span class="marked1"><a name="line1676"></a>1676         def matches_dynamic_finder?(method_id)
</span><span class="marked0"><a name="line1677"></a>1677           /^find_(all_by|by)_([_a-zA-Z]\w*)$/.match(method_id.to_s)
</span><span class="marked1"><a name="line1678"></a>1678         end
</span><span class="inferred0"><a name="line1679"></a>1679 
</span><span class="marked1"><a name="line1680"></a>1680         def matches_dynamic_finder_with_initialize_or_create?(method_id)
</span><span class="marked0"><a name="line1681"></a>1681           /^find_or_(initialize|create)_by_([_a-zA-Z]\w*)$/.match(method_id.to_s)
</span><span class="marked1"><a name="line1682"></a>1682         end
</span><span class="inferred0"><a name="line1683"></a>1683 
</span><span class="marked1"><a name="line1684"></a>1684         def determine_finder(match)
</span><span class="uncovered0"><a name="line1685"></a>1685           match.captures.first == 'all_by' ? :find_every : :find_initial
</span><span class="uncovered1"><a name="line1686"></a>1686         end
</span><span class="inferred0"><a name="line1687"></a>1687 
</span><span class="marked1"><a name="line1688"></a>1688         def determine_instantiator(match)
</span><span class="uncovered0"><a name="line1689"></a>1689           match.captures.first == 'initialize' ? :new : :create
</span><span class="uncovered1"><a name="line1690"></a>1690         end
</span><span class="inferred0"><a name="line1691"></a>1691 
</span><span class="marked1"><a name="line1692"></a>1692         def extract_attribute_names_from_match(match)
</span><span class="uncovered0"><a name="line1693"></a>1693           match.captures.last.split('_and_')
</span><span class="uncovered1"><a name="line1694"></a>1694         end
</span><span class="inferred0"><a name="line1695"></a>1695 
</span><span class="marked1"><a name="line1696"></a>1696         def construct_attributes_from_arguments(attribute_names, arguments)
</span><span class="uncovered0"><a name="line1697"></a>1697           attributes = {}
</span><span class="uncovered1"><a name="line1698"></a>1698           attribute_names.each_with_index { |name, idx| attributes[name] = arguments[idx] }
</span><span class="uncovered0"><a name="line1699"></a>1699           attributes
</span><span class="uncovered1"><a name="line1700"></a>1700         end
</span><span class="inferred0"><a name="line1701"></a>1701 
</span><span class="inferred1"><a name="line1702"></a>1702         # Similar in purpose to +expand_hash_conditions_for_aggregates+.
</span><span class="marked0"><a name="line1703"></a>1703         def expand_attribute_names_for_aggregates(attribute_names)
</span><span class="uncovered1"><a name="line1704"></a>1704           expanded_attribute_names = []
</span><span class="uncovered0"><a name="line1705"></a>1705           attribute_names.each do |attribute_name|
</span><span class="uncovered1"><a name="line1706"></a>1706             unless (aggregation = reflect_on_aggregation(attribute_name.to_sym)).nil?
</span><span class="uncovered0"><a name="line1707"></a>1707               aggregate_mapping(aggregation).each do |field_attr, aggregate_attr|
</span><span class="uncovered1"><a name="line1708"></a>1708                 expanded_attribute_names &lt;&lt; field_attr
</span><span class="uncovered0"><a name="line1709"></a>1709               end
</span><span class="uncovered1"><a name="line1710"></a>1710             else
</span><span class="uncovered0"><a name="line1711"></a>1711               expanded_attribute_names &lt;&lt; attribute_name
</span><span class="uncovered1"><a name="line1712"></a>1712             end
</span><span class="uncovered0"><a name="line1713"></a>1713           end
</span><span class="uncovered1"><a name="line1714"></a>1714           expanded_attribute_names
</span><span class="uncovered0"><a name="line1715"></a>1715         end
</span><span class="inferred1"><a name="line1716"></a>1716 
</span><span class="marked0"><a name="line1717"></a>1717         def all_attributes_exists?(attribute_names)
</span><span class="uncovered1"><a name="line1718"></a>1718           attribute_names = expand_attribute_names_for_aggregates(attribute_names)
</span><span class="uncovered0"><a name="line1719"></a>1719           attribute_names.all? { |name| column_methods_hash.include?(name.to_sym) }
</span><span class="uncovered1"><a name="line1720"></a>1720         end
</span><span class="inferred0"><a name="line1721"></a>1721 
</span><span class="marked1"><a name="line1722"></a>1722         def attribute_condition(argument)
</span><span class="uncovered0"><a name="line1723"></a>1723           case argument
</span><span class="uncovered1"><a name="line1724"></a>1724             when nil   then &quot;IS ?&quot;
</span><span class="uncovered0"><a name="line1725"></a>1725             when Array, ActiveRecord::Associations::AssociationCollection, ActiveRecord::NamedScope::Scope then &quot;IN (?)&quot;
</span><span class="uncovered1"><a name="line1726"></a>1726             when Range then &quot;BETWEEN ? AND ?&quot;
</span><span class="uncovered0"><a name="line1727"></a>1727             else            &quot;= ?&quot;
</span><span class="uncovered1"><a name="line1728"></a>1728           end
</span><span class="uncovered0"><a name="line1729"></a>1729         end
</span><span class="inferred1"><a name="line1730"></a>1730 
</span><span class="inferred0"><a name="line1731"></a>1731         # Interpret Array and Hash as conditions and anything else as an id.
</span><span class="marked1"><a name="line1732"></a>1732         def expand_id_conditions(id_or_conditions)
</span><span class="uncovered0"><a name="line1733"></a>1733           case id_or_conditions
</span><span class="uncovered1"><a name="line1734"></a>1734             when Array, Hash then id_or_conditions
</span><span class="uncovered0"><a name="line1735"></a>1735             else sanitize_sql(primary_key =&gt; id_or_conditions)
</span><span class="uncovered1"><a name="line1736"></a>1736           end
</span><span class="uncovered0"><a name="line1737"></a>1737         end
</span><span class="inferred1"><a name="line1738"></a>1738 
</span><span class="inferred0"><a name="line1739"></a>1739 
</span><span class="inferred1"><a name="line1740"></a>1740         # Defines an &quot;attribute&quot; method (like +inheritance_column+ or
</span><span class="inferred0"><a name="line1741"></a>1741         # +table_name+). A new (class) method will be created with the
</span><span class="inferred1"><a name="line1742"></a>1742         # given name. If a value is specified, the new method will
</span><span class="inferred0"><a name="line1743"></a>1743         # return that value (as a string). Otherwise, the given block
</span><span class="inferred1"><a name="line1744"></a>1744         # will be used to compute the value of the method.
</span><span class="inferred0"><a name="line1745"></a>1745         #
</span><span class="inferred1"><a name="line1746"></a>1746         # The original method will be aliased, with the new name being
</span><span class="inferred0"><a name="line1747"></a>1747         # prefixed with &quot;original_&quot;. This allows the new method to
</span><span class="inferred1"><a name="line1748"></a>1748         # access the original value.
</span><span class="inferred0"><a name="line1749"></a>1749         #
</span><span class="inferred1"><a name="line1750"></a>1750         # Example:
</span><span class="inferred0"><a name="line1751"></a>1751         #
</span><span class="inferred1"><a name="line1752"></a>1752         #   class A &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line1753"></a>1753         #     define_attr_method :primary_key, &quot;sysid&quot;
</span><span class="inferred1"><a name="line1754"></a>1754         #     define_attr_method( :inheritance_column ) do
</span><span class="inferred0"><a name="line1755"></a>1755         #       original_inheritance_column + &quot;_id&quot;
</span><span class="inferred1"><a name="line1756"></a>1756         #     end
</span><span class="inferred0"><a name="line1757"></a>1757         #   end
</span><span class="marked1"><a name="line1758"></a>1758         def define_attr_method(name, value=nil, &amp;block)
</span><span class="marked0"><a name="line1759"></a>1759           sing = class &lt;&lt; self; self; end
</span><span class="marked1"><a name="line1760"></a>1760           sing.send :alias_method, &quot;original_#{name}&quot;, name
</span><span class="marked0"><a name="line1761"></a>1761           if block_given?
</span><span class="uncovered1"><a name="line1762"></a>1762             sing.send :define_method, name, &amp;block
</span><span class="inferred0"><a name="line1763"></a>1763           else
</span><span class="inferred1"><a name="line1764"></a>1764             # use eval instead of a block to work around a memory leak in dev
</span><span class="inferred0"><a name="line1765"></a>1765             # mode in fcgi
</span><span class="marked1"><a name="line1766"></a>1766             sing.class_eval &quot;def #{name}; #{value.to_s.inspect}; end&quot;
</span><span class="inferred0"><a name="line1767"></a>1767           end
</span><span class="inferred1"><a name="line1768"></a>1768         end
</span><span class="inferred0"><a name="line1769"></a>1769 
</span><span class="marked1"><a name="line1770"></a>1770       protected
</span><span class="inferred0"><a name="line1771"></a>1771         # Scope parameters to method calls within the block.  Takes a hash of method_name =&gt; parameters hash.
</span><span class="inferred1"><a name="line1772"></a>1772         # method_name may be &lt;tt&gt;:find&lt;/tt&gt; or &lt;tt&gt;:create&lt;/tt&gt;. &lt;tt&gt;:find&lt;/tt&gt; parameters may include the &lt;tt&gt;:conditions&lt;/tt&gt;, &lt;tt&gt;:joins&lt;/tt&gt;,
</span><span class="inferred0"><a name="line1773"></a>1773         # &lt;tt&gt;:include&lt;/tt&gt;, &lt;tt&gt;:offset&lt;/tt&gt;, &lt;tt&gt;:limit&lt;/tt&gt;, and &lt;tt&gt;:readonly&lt;/tt&gt; options. &lt;tt&gt;:create&lt;/tt&gt; parameters are an attributes hash.
</span><span class="inferred1"><a name="line1774"></a>1774         #
</span><span class="inferred0"><a name="line1775"></a>1775         #   class Article &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line1776"></a>1776         #     def self.create_with_scope
</span><span class="inferred0"><a name="line1777"></a>1777         #       with_scope(:find =&gt; { :conditions =&gt; &quot;blog_id = 1&quot; }, :create =&gt; { :blog_id =&gt; 1 }) do
</span><span class="inferred1"><a name="line1778"></a>1778         #         find(1) # =&gt; SELECT * from articles WHERE blog_id = 1 AND id = 1
</span><span class="inferred0"><a name="line1779"></a>1779         #         a = create(1)
</span><span class="inferred1"><a name="line1780"></a>1780         #         a.blog_id # =&gt; 1
</span><span class="inferred0"><a name="line1781"></a>1781         #       end
</span><span class="inferred1"><a name="line1782"></a>1782         #     end
</span><span class="inferred0"><a name="line1783"></a>1783         #   end
</span><span class="inferred1"><a name="line1784"></a>1784         #
</span><span class="inferred0"><a name="line1785"></a>1785         # In nested scopings, all previous parameters are overwritten by the innermost rule, with the exception of
</span><span class="inferred1"><a name="line1786"></a>1786         # &lt;tt&gt;:conditions&lt;/tt&gt; and &lt;tt&gt;:include&lt;/tt&gt; options in &lt;tt&gt;:find&lt;/tt&gt;, which are merged.
</span><span class="inferred0"><a name="line1787"></a>1787         #
</span><span class="inferred1"><a name="line1788"></a>1788         #   class Article &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line1789"></a>1789         #     def self.find_with_scope
</span><span class="inferred1"><a name="line1790"></a>1790         #       with_scope(:find =&gt; { :conditions =&gt; &quot;blog_id = 1&quot;, :limit =&gt; 1 }, :create =&gt; { :blog_id =&gt; 1 }) do
</span><span class="inferred0"><a name="line1791"></a>1791         #         with_scope(:find =&gt; { :limit =&gt; 10 })
</span><span class="inferred1"><a name="line1792"></a>1792         #           find(:all) # =&gt; SELECT * from articles WHERE blog_id = 1 LIMIT 10
</span><span class="inferred0"><a name="line1793"></a>1793         #         end
</span><span class="inferred1"><a name="line1794"></a>1794         #         with_scope(:find =&gt; { :conditions =&gt; &quot;author_id = 3&quot; })
</span><span class="inferred0"><a name="line1795"></a>1795         #           find(:all) # =&gt; SELECT * from articles WHERE blog_id = 1 AND author_id = 3 LIMIT 1
</span><span class="inferred1"><a name="line1796"></a>1796         #         end
</span><span class="inferred0"><a name="line1797"></a>1797         #       end
</span><span class="inferred1"><a name="line1798"></a>1798         #     end
</span><span class="inferred0"><a name="line1799"></a>1799         #   end
</span><span class="inferred1"><a name="line1800"></a>1800         #
</span><span class="inferred0"><a name="line1801"></a>1801         # You can ignore any previous scopings by using the &lt;tt&gt;with_exclusive_scope&lt;/tt&gt; method.
</span><span class="inferred1"><a name="line1802"></a>1802         #
</span><span class="inferred0"><a name="line1803"></a>1803         #   class Article &lt; ActiveRecord::Base
</span><span class="inferred1"><a name="line1804"></a>1804         #     def self.find_with_exclusive_scope
</span><span class="inferred0"><a name="line1805"></a>1805         #       with_scope(:find =&gt; { :conditions =&gt; &quot;blog_id = 1&quot;, :limit =&gt; 1 }) do
</span><span class="inferred1"><a name="line1806"></a>1806         #         with_exclusive_scope(:find =&gt; { :limit =&gt; 10 })
</span><span class="inferred0"><a name="line1807"></a>1807         #           find(:all) # =&gt; SELECT * from articles LIMIT 10
</span><span class="inferred1"><a name="line1808"></a>1808         #         end
</span><span class="inferred0"><a name="line1809"></a>1809         #       end
</span><span class="inferred1"><a name="line1810"></a>1810         #     end
</span><span class="inferred0"><a name="line1811"></a>1811         #   end
</span><span class="marked1"><a name="line1812"></a>1812         def with_scope(method_scoping = {}, action = :merge, &amp;block)
</span><span class="uncovered0"><a name="line1813"></a>1813           method_scoping = method_scoping.method_scoping if method_scoping.respond_to?(:method_scoping)
</span><span class="uncovered1"><a name="line1814"></a>1814 
</span><span class="uncovered0"><a name="line1815"></a>1815           # Dup first and second level of hash (method and params).
</span><span class="uncovered1"><a name="line1816"></a>1816           method_scoping = method_scoping.inject({}) do |hash, (method, params)|
</span><span class="uncovered0"><a name="line1817"></a>1817             hash[method] = (params == true) ? params : params.dup
</span><span class="uncovered1"><a name="line1818"></a>1818             hash
</span><span class="uncovered0"><a name="line1819"></a>1819           end
</span><span class="uncovered1"><a name="line1820"></a>1820 
</span><span class="uncovered0"><a name="line1821"></a>1821           method_scoping.assert_valid_keys([ :find, :create ])
</span><span class="uncovered1"><a name="line1822"></a>1822 
</span><span class="uncovered0"><a name="line1823"></a>1823           if f = method_scoping[:find]
</span><span class="uncovered1"><a name="line1824"></a>1824             f.assert_valid_keys(VALID_FIND_OPTIONS)
</span><span class="uncovered0"><a name="line1825"></a>1825             set_readonly_option! f
</span><span class="uncovered1"><a name="line1826"></a>1826           end
</span><span class="uncovered0"><a name="line1827"></a>1827 
</span><span class="uncovered1"><a name="line1828"></a>1828           # Merge scopings
</span><span class="uncovered0"><a name="line1829"></a>1829           if action == :merge &amp;&amp; current_scoped_methods
</span><span class="uncovered1"><a name="line1830"></a>1830             method_scoping = current_scoped_methods.inject(method_scoping) do |hash, (method, params)|
</span><span class="uncovered0"><a name="line1831"></a>1831               case hash[method]
</span><span class="uncovered1"><a name="line1832"></a>1832                 when Hash
</span><span class="uncovered0"><a name="line1833"></a>1833                   if method == :find
</span><span class="uncovered1"><a name="line1834"></a>1834                     (hash[method].keys + params.keys).uniq.each do |key|
</span><span class="uncovered0"><a name="line1835"></a>1835                       merge = hash[method][key] &amp;&amp; params[key] # merge if both scopes have the same key
</span><span class="uncovered1"><a name="line1836"></a>1836                       if key == :conditions &amp;&amp; merge
</span><span class="uncovered0"><a name="line1837"></a>1837                         hash[method][key] = merge_conditions(params[key], hash[method][key])
</span><span class="uncovered1"><a name="line1838"></a>1838                       elsif key == :include &amp;&amp; merge
</span><span class="uncovered0"><a name="line1839"></a>1839                         hash[method][key] = merge_includes(hash[method][key], params[key]).uniq
</span><span class="uncovered1"><a name="line1840"></a>1840                       else
</span><span class="uncovered0"><a name="line1841"></a>1841                         hash[method][key] = hash[method][key] || params[key]
</span><span class="uncovered1"><a name="line1842"></a>1842                       end
</span><span class="uncovered0"><a name="line1843"></a>1843                     end
</span><span class="uncovered1"><a name="line1844"></a>1844                   else
</span><span class="uncovered0"><a name="line1845"></a>1845                     hash[method] = params.merge(hash[method])
</span><span class="uncovered1"><a name="line1846"></a>1846                   end
</span><span class="uncovered0"><a name="line1847"></a>1847                 else
</span><span class="uncovered1"><a name="line1848"></a>1848                   hash[method] = params
</span><span class="uncovered0"><a name="line1849"></a>1849               end
</span><span class="uncovered1"><a name="line1850"></a>1850               hash
</span><span class="uncovered0"><a name="line1851"></a>1851             end
</span><span class="uncovered1"><a name="line1852"></a>1852           end
</span><span class="uncovered0"><a name="line1853"></a>1853 
</span><span class="uncovered1"><a name="line1854"></a>1854           self.scoped_methods &lt;&lt; method_scoping
</span><span class="uncovered0"><a name="line1855"></a>1855 
</span><span class="uncovered1"><a name="line1856"></a>1856           begin
</span><span class="uncovered0"><a name="line1857"></a>1857             yield
</span><span class="uncovered1"><a name="line1858"></a>1858           ensure
</span><span class="uncovered0"><a name="line1859"></a>1859             self.scoped_methods.pop
</span><span class="uncovered1"><a name="line1860"></a>1860           end
</span><span class="uncovered0"><a name="line1861"></a>1861         end
</span><span class="inferred1"><a name="line1862"></a>1862 
</span><span class="inferred0"><a name="line1863"></a>1863         # Works like with_scope, but discards any nested properties.
</span><span class="marked1"><a name="line1864"></a>1864         def with_exclusive_scope(method_scoping = {}, &amp;block)
</span><span class="uncovered0"><a name="line1865"></a>1865           with_scope(method_scoping, :overwrite, &amp;block)
</span><span class="uncovered1"><a name="line1866"></a>1866         end
</span><span class="inferred0"><a name="line1867"></a>1867 
</span><span class="marked1"><a name="line1868"></a>1868         def subclasses #:nodoc:
</span><span class="marked0"><a name="line1869"></a>1869           @@subclasses[self] ||= []
</span><span class="marked1"><a name="line1870"></a>1870           @@subclasses[self] + extra = @@subclasses[self].inject([]) {|list, subclass| list + subclass.subclasses }
</span><span class="inferred0"><a name="line1871"></a>1871         end
</span><span class="inferred1"><a name="line1872"></a>1872 
</span><span class="inferred0"><a name="line1873"></a>1873         # Test whether the given method and optional key are scoped.
</span><span class="marked1"><a name="line1874"></a>1874         def scoped?(method, key = nil) #:nodoc:
</span><span class="uncovered0"><a name="line1875"></a>1875           if current_scoped_methods &amp;&amp; (scope = current_scoped_methods[method])
</span><span class="uncovered1"><a name="line1876"></a>1876             !key || scope.has_key?(key)
</span><span class="uncovered0"><a name="line1877"></a>1877           end
</span><span class="uncovered1"><a name="line1878"></a>1878         end
</span><span class="inferred0"><a name="line1879"></a>1879 
</span><span class="inferred1"><a name="line1880"></a>1880         # Retrieve the scope for the given method and optional key.
</span><span class="marked0"><a name="line1881"></a>1881         def scope(method, key = nil) #:nodoc:
</span><span class="uncovered1"><a name="line1882"></a>1882           if current_scoped_methods &amp;&amp; (scope = current_scoped_methods[method])
</span><span class="uncovered0"><a name="line1883"></a>1883             key ? scope[key] : scope
</span><span class="uncovered1"><a name="line1884"></a>1884           end
</span><span class="uncovered0"><a name="line1885"></a>1885         end
</span><span class="inferred1"><a name="line1886"></a>1886 
</span><span class="marked0"><a name="line1887"></a>1887         def thread_safe_scoped_methods #:nodoc:
</span><span class="uncovered1"><a name="line1888"></a>1888           scoped_methods = (Thread.current[:scoped_methods] ||= {})
</span><span class="uncovered0"><a name="line1889"></a>1889           scoped_methods[self] ||= []
</span><span class="uncovered1"><a name="line1890"></a>1890         end
</span><span class="inferred0"><a name="line1891"></a>1891 
</span><span class="marked1"><a name="line1892"></a>1892         def single_threaded_scoped_methods #:nodoc:
</span><span class="uncovered0"><a name="line1893"></a>1893           @scoped_methods ||= []
</span><span class="uncovered1"><a name="line1894"></a>1894         end
</span><span class="inferred0"><a name="line1895"></a>1895 
</span><span class="inferred1"><a name="line1896"></a>1896         # pick up the correct scoped_methods version from @@allow_concurrency
</span><span class="marked0"><a name="line1897"></a>1897         if @@allow_concurrency
</span><span class="uncovered1"><a name="line1898"></a>1898           alias_method :scoped_methods, :thread_safe_scoped_methods
</span><span class="inferred0"><a name="line1899"></a>1899         else
</span><span class="marked1"><a name="line1900"></a>1900           alias_method :scoped_methods, :single_threaded_scoped_methods
</span><span class="inferred0"><a name="line1901"></a>1901         end
</span><span class="inferred1"><a name="line1902"></a>1902 
</span><span class="marked0"><a name="line1903"></a>1903         def current_scoped_methods #:nodoc:
</span><span class="uncovered1"><a name="line1904"></a>1904           scoped_methods.last
</span><span class="uncovered0"><a name="line1905"></a>1905         end
</span><span class="inferred1"><a name="line1906"></a>1906 
</span><span class="inferred0"><a name="line1907"></a>1907         # Returns the class type of the record using the current module as a prefix. So descendents of
</span><span class="inferred1"><a name="line1908"></a>1908         # MyApp::Business::Account would appear as MyApp::Business::AccountSubclass.
</span><span class="marked0"><a name="line1909"></a>1909         def compute_type(type_name)
</span><span class="uncovered1"><a name="line1910"></a>1910           modularized_name = type_name_with_module(type_name)
</span><span class="uncovered0"><a name="line1911"></a>1911           begin
</span><span class="uncovered1"><a name="line1912"></a>1912             class_eval(modularized_name, __FILE__, __LINE__)
</span><span class="uncovered0"><a name="line1913"></a>1913           rescue NameError
</span><span class="uncovered1"><a name="line1914"></a>1914             class_eval(type_name, __FILE__, __LINE__)
</span><span class="uncovered0"><a name="line1915"></a>1915           end
</span><span class="uncovered1"><a name="line1916"></a>1916         end
</span><span class="inferred0"><a name="line1917"></a>1917 
</span><span class="inferred1"><a name="line1918"></a>1918         # Returns the class descending directly from Active Record in the inheritance hierarchy.
</span><span class="marked0"><a name="line1919"></a>1919         def class_of_active_record_descendant(klass)
</span><span class="marked1"><a name="line1920"></a>1920           if klass.superclass == Base || klass.superclass.abstract_class?
</span><span class="marked0"><a name="line1921"></a>1921             klass
</span><span class="uncovered1"><a name="line1922"></a>1922           elsif klass.superclass.nil?
</span><span class="uncovered0"><a name="line1923"></a>1923             raise ActiveRecordError, &quot;#{name} doesn't belong in a hierarchy descending from ActiveRecord&quot;
</span><span class="uncovered1"><a name="line1924"></a>1924           else
</span><span class="uncovered0"><a name="line1925"></a>1925             class_of_active_record_descendant(klass.superclass)
</span><span class="uncovered1"><a name="line1926"></a>1926           end
</span><span class="marked0"><a name="line1927"></a>1927         end
</span><span class="inferred1"><a name="line1928"></a>1928 
</span><span class="inferred0"><a name="line1929"></a>1929         # Returns the name of the class descending directly from Active Record in the inheritance hierarchy.
</span><span class="marked1"><a name="line1930"></a>1930         def class_name_of_active_record_descendant(klass) #:nodoc:
</span><span class="uncovered0"><a name="line1931"></a>1931           klass.base_class.name
</span><span class="uncovered1"><a name="line1932"></a>1932         end
</span><span class="inferred0"><a name="line1933"></a>1933 
</span><span class="inferred1"><a name="line1934"></a>1934         # Accepts an array, hash, or string of SQL conditions and sanitizes
</span><span class="inferred0"><a name="line1935"></a>1935         # them into a valid SQL fragment for a WHERE clause.
</span><span class="inferred1"><a name="line1936"></a>1936         #   [&quot;name='%s' and group_id='%s'&quot;, &quot;foo'bar&quot;, 4]  returns  &quot;name='foo''bar' and group_id='4'&quot;
</span><span class="inferred0"><a name="line1937"></a>1937         #   { :name =&gt; &quot;foo'bar&quot;, :group_id =&gt; 4 }  returns &quot;name='foo''bar' and group_id='4'&quot;
</span><span class="inferred1"><a name="line1938"></a>1938         #   &quot;name='foo''bar' and group_id='4'&quot; returns &quot;name='foo''bar' and group_id='4'&quot;
</span><span class="marked0"><a name="line1939"></a>1939         def sanitize_sql_for_conditions(condition)
</span><span class="uncovered1"><a name="line1940"></a>1940           return nil if condition.blank?
</span><span class="uncovered0"><a name="line1941"></a>1941 
</span><span class="uncovered1"><a name="line1942"></a>1942           case condition
</span><span class="uncovered0"><a name="line1943"></a>1943             when Array; sanitize_sql_array(condition)
</span><span class="uncovered1"><a name="line1944"></a>1944             when Hash;  sanitize_sql_hash_for_conditions(condition)
</span><span class="uncovered0"><a name="line1945"></a>1945             else        condition
</span><span class="uncovered1"><a name="line1946"></a>1946           end
</span><span class="uncovered0"><a name="line1947"></a>1947         end
</span><span class="marked1"><a name="line1948"></a>1948         alias_method :sanitize_sql, :sanitize_sql_for_conditions
</span><span class="inferred0"><a name="line1949"></a>1949 
</span><span class="inferred1"><a name="line1950"></a>1950         # Accepts an array, hash, or string of SQL conditions and sanitizes
</span><span class="inferred0"><a name="line1951"></a>1951         # them into a valid SQL fragment for a SET clause.
</span><span class="inferred1"><a name="line1952"></a>1952         #   { :name =&gt; nil, :group_id =&gt; 4 }  returns &quot;name = NULL , group_id='4'&quot;
</span><span class="marked0"><a name="line1953"></a>1953         def sanitize_sql_for_assignment(assignments)
</span><span class="uncovered1"><a name="line1954"></a>1954           case assignments
</span><span class="uncovered0"><a name="line1955"></a>1955             when Array; sanitize_sql_array(assignments)
</span><span class="uncovered1"><a name="line1956"></a>1956             when Hash;  sanitize_sql_hash_for_assignment(assignments)
</span><span class="uncovered0"><a name="line1957"></a>1957             else        assignments
</span><span class="uncovered1"><a name="line1958"></a>1958           end
</span><span class="uncovered0"><a name="line1959"></a>1959         end
</span><span class="inferred1"><a name="line1960"></a>1960 
</span><span class="marked0"><a name="line1961"></a>1961         def aggregate_mapping(reflection)
</span><span class="uncovered1"><a name="line1962"></a>1962           mapping = reflection.options[:mapping] || [reflection.name, reflection.name]
</span><span class="uncovered0"><a name="line1963"></a>1963           mapping.first.is_a?(Array) ? mapping : [mapping]
</span><span class="uncovered1"><a name="line1964"></a>1964         end
</span><span class="inferred0"><a name="line1965"></a>1965 
</span><span class="inferred1"><a name="line1966"></a>1966         # Accepts a hash of SQL conditions and replaces those attributes
</span><span class="inferred0"><a name="line1967"></a>1967         # that correspond to a +composed_of+ relationship with their expanded
</span><span class="inferred1"><a name="line1968"></a>1968         # aggregate attribute values.
</span><span class="inferred0"><a name="line1969"></a>1969         # Given:
</span><span class="inferred1"><a name="line1970"></a>1970         #     class Person &lt; ActiveRecord::Base
</span><span class="inferred0"><a name="line1971"></a>1971         #       composed_of :address, :class_name =&gt; &quot;Address&quot;,
</span><span class="inferred1"><a name="line1972"></a>1972         #         :mapping =&gt; [%w(address_street street), %w(address_city city)]
</span><span class="inferred0"><a name="line1973"></a>1973         #     end
</span><span class="inferred1"><a name="line1974"></a>1974         # Then:
</span><span class="inferred0"><a name="line1975"></a>1975         #     { :address =&gt; Address.new(&quot;813 abc st.&quot;, &quot;chicago&quot;) }
</span><span class="inferred1"><a name="line1976"></a>1976         #       # =&gt; { :address_street =&gt; &quot;813 abc st.&quot;, :address_city =&gt; &quot;chicago&quot; }
</span><span class="marked0"><a name="line1977"></a>1977         def expand_hash_conditions_for_aggregates(attrs)
</span><span class="uncovered1"><a name="line1978"></a>1978           expanded_attrs = {}
</span><span class="uncovered0"><a name="line1979"></a>1979           attrs.each do |attr, value|
</span><span class="uncovered1"><a name="line1980"></a>1980             unless (aggregation = reflect_on_aggregation(attr.to_sym)).nil?
</span><span class="uncovered0"><a name="line1981"></a>1981               mapping = aggregate_mapping(aggregation)
</span><span class="uncovered1"><a name="line1982"></a>1982               mapping.each do |field_attr, aggregate_attr|
</span><span class="uncovered0"><a name="line1983"></a>1983                 if mapping.size == 1 &amp;&amp; !value.respond_to?(aggregate_attr)
</span><span class="uncovered1"><a name="line1984"></a>1984                   expanded_attrs[field_attr] = value
</span><span class="uncovered0"><a name="line1985"></a>1985                 else
</span><span class="uncovered1"><a name="line1986"></a>1986                   expanded_attrs[field_attr] = value.send(aggregate_attr)
</span><span class="uncovered0"><a name="line1987"></a>1987                 end
</span><span class="uncovered1"><a name="line1988"></a>1988               end
</span><span class="uncovered0"><a name="line1989"></a>1989             else
</span><span class="uncovered1"><a name="line1990"></a>1990               expanded_attrs[attr] = value
</span><span class="uncovered0"><a name="line1991"></a>1991             end
</span><span class="uncovered1"><a name="line1992"></a>1992           end
</span><span class="uncovered0"><a name="line1993"></a>1993           expanded_attrs
</span><span class="uncovered1"><a name="line1994"></a>1994         end
</span><span class="inferred0"><a name="line1995"></a>1995 
</span><span class="inferred1"><a name="line1996"></a>1996         # Sanitizes a hash of attribute/value pairs into SQL conditions for a WHERE clause.
</span><span class="inferred0"><a name="line1997"></a>1997         #   { :name =&gt; &quot;foo'bar&quot;, :group_id =&gt; 4 }
</span><span class="inferred1"><a name="line1998"></a>1998         #     # =&gt; &quot;name='foo''bar' and group_id= 4&quot;
</span><span class="inferred0"><a name="line1999"></a>1999         #   { :status =&gt; nil, :group_id =&gt; [1,2,3] }
</span><span class="inferred1"><a name="line2000"></a>2000         #     # =&gt; &quot;status IS NULL and group_id IN (1,2,3)&quot;
</span><span class="inferred0"><a name="line2001"></a>2001         #   { :age =&gt; 13..18 }
</span><span class="inferred1"><a name="line2002"></a>2002         #     # =&gt; &quot;age BETWEEN 13 AND 18&quot;
</span><span class="inferred0"><a name="line2003"></a>2003         #   { 'other_records.id' =&gt; 7 }
</span><span class="inferred1"><a name="line2004"></a>2004         #     # =&gt; &quot;`other_records`.`id` = 7&quot;
</span><span class="inferred0"><a name="line2005"></a>2005         # And for value objects on a composed_of relationship:
</span><span class="inferred1"><a name="line2006"></a>2006         #   { :address =&gt; Address.new(&quot;123 abc st.&quot;, &quot;chicago&quot;) }
</span><span class="inferred0"><a name="line2007"></a>2007         #     # =&gt; &quot;address_street='123 abc st.' and address_city='chicago'&quot;
</span><span class="marked1"><a name="line2008"></a>2008         def sanitize_sql_hash_for_conditions(attrs)
</span><span class="uncovered0"><a name="line2009"></a>2009           attrs = expand_hash_conditions_for_aggregates(attrs)
</span><span class="uncovered1"><a name="line2010"></a>2010 
</span><span class="uncovered0"><a name="line2011"></a>2011           conditions = attrs.map do |attr, value|
</span><span class="uncovered1"><a name="line2012"></a>2012             attr = attr.to_s
</span><span class="uncovered0"><a name="line2013"></a>2013 
</span><span class="uncovered1"><a name="line2014"></a>2014             # Extract table name from qualified attribute names.
</span><span class="uncovered0"><a name="line2015"></a>2015             if attr.include?('.')
</span><span class="uncovered1"><a name="line2016"></a>2016               table_name, attr = attr.split('.', 2)
</span><span class="uncovered0"><a name="line2017"></a>2017               table_name = connection.quote_table_name(table_name)
</span><span class="uncovered1"><a name="line2018"></a>2018             else
</span><span class="uncovered0"><a name="line2019"></a>2019               table_name = quoted_table_name
</span><span class="uncovered1"><a name="line2020"></a>2020             end
</span><span class="uncovered0"><a name="line2021"></a>2021 
</span><span class="uncovered1"><a name="line2022"></a>2022             &quot;#{table_name}.#{connection.quote_column_name(attr)} #{attribute_condition(value)}&quot;
</span><span class="uncovered0"><a name="line2023"></a>2023           end.join(' AND ')
</span><span class="uncovered1"><a name="line2024"></a>2024 
</span><span class="uncovered0"><a name="line2025"></a>2025           replace_bind_variables(conditions, expand_range_bind_variables(attrs.values))
</span><span class="uncovered1"><a name="line2026"></a>2026         end
</span><span class="marked0"><a name="line2027"></a>2027         alias_method :sanitize_sql_hash, :sanitize_sql_hash_for_conditions
</span><span class="inferred1"><a name="line2028"></a>2028 
</span><span class="inferred0"><a name="line2029"></a>2029         # Sanitizes a hash of attribute/value pairs into SQL conditions for a SET clause.
</span><span class="inferred1"><a name="line2030"></a>2030         #   { :status =&gt; nil, :group_id =&gt; 1 }
</span><span class="inferred0"><a name="line2031"></a>2031         #     # =&gt; &quot;status = NULL , group_id = 1&quot;
</span><span class="marked1"><a name="line2032"></a>2032         def sanitize_sql_hash_for_assignment(attrs)
</span><span class="uncovered0"><a name="line2033"></a>2033           attrs.map do |attr, value|
</span><span class="uncovered1"><a name="line2034"></a>2034             &quot;#{connection.quote_column_name(attr)} = #{quote_bound_value(value)}&quot;
</span><span class="uncovered0"><a name="line2035"></a>2035           end.join(', ')
</span><span class="uncovered1"><a name="line2036"></a>2036         end
</span><span class="inferred0"><a name="line2037"></a>2037 
</span><span class="inferred1"><a name="line2038"></a>2038         # Accepts an array of conditions.  The array has each value
</span><span class="inferred0"><a name="line2039"></a>2039         # sanitized and interpolated into the SQL statement.
</span><span class="inferred1"><a name="line2040"></a>2040         #   [&quot;name='%s' and group_id='%s'&quot;, &quot;foo'bar&quot;, 4]  returns  &quot;name='foo''bar' and group_id='4'&quot;
</span><span class="marked0"><a name="line2041"></a>2041         def sanitize_sql_array(ary)
</span><span class="uncovered1"><a name="line2042"></a>2042           statement, *values = ary
</span><span class="uncovered0"><a name="line2043"></a>2043           if values.first.is_a?(Hash) and statement =~ /:\w+/
</span><span class="uncovered1"><a name="line2044"></a>2044             replace_named_bind_variables(statement, values.first)
</span><span class="uncovered0"><a name="line2045"></a>2045           elsif statement.include?('?')
</span><span class="uncovered1"><a name="line2046"></a>2046             replace_bind_variables(statement, values)
</span><span class="uncovered0"><a name="line2047"></a>2047           else
</span><span class="uncovered1"><a name="line2048"></a>2048             statement % values.collect { |value| connection.quote_string(value.to_s) }
</span><span class="uncovered0"><a name="line2049"></a>2049           end
</span><span class="uncovered1"><a name="line2050"></a>2050         end
</span><span class="inferred0"><a name="line2051"></a>2051 
</span><span class="marked1"><a name="line2052"></a>2052         alias_method :sanitize_conditions, :sanitize_sql
</span><span class="inferred0"><a name="line2053"></a>2053 
</span><span class="marked1"><a name="line2054"></a>2054         def replace_bind_variables(statement, values) #:nodoc:
</span><span class="uncovered0"><a name="line2055"></a>2055           raise_if_bind_arity_mismatch(statement, statement.count('?'), values.size)
</span><span class="uncovered1"><a name="line2056"></a>2056           bound = values.dup
</span><span class="uncovered0"><a name="line2057"></a>2057           statement.gsub('?') { quote_bound_value(bound.shift) }
</span><span class="uncovered1"><a name="line2058"></a>2058         end
</span><span class="inferred0"><a name="line2059"></a>2059 
</span><span class="marked1"><a name="line2060"></a>2060         def replace_named_bind_variables(statement, bind_vars) #:nodoc:
</span><span class="uncovered0"><a name="line2061"></a>2061           statement.gsub(/(:?):([a-zA-Z]\w*)/) do
</span><span class="uncovered1"><a name="line2062"></a>2062             if $1 == ':' # skip postgresql casts
</span><span class="uncovered0"><a name="line2063"></a>2063               $&amp; # return the whole match
</span><span class="uncovered1"><a name="line2064"></a>2064             elsif bind_vars.include?(match = $2.to_sym)
</span><span class="uncovered0"><a name="line2065"></a>2065               quote_bound_value(bind_vars[match])
</span><span class="uncovered1"><a name="line2066"></a>2066             else
</span><span class="uncovered0"><a name="line2067"></a>2067               raise PreparedStatementInvalid, &quot;missing value for :#{match} in #{statement}&quot;
</span><span class="uncovered1"><a name="line2068"></a>2068             end
</span><span class="uncovered0"><a name="line2069"></a>2069           end
</span><span class="uncovered1"><a name="line2070"></a>2070         end
</span><span class="inferred0"><a name="line2071"></a>2071 
</span><span class="marked1"><a name="line2072"></a>2072         def expand_range_bind_variables(bind_vars) #:nodoc:
</span><span class="uncovered0"><a name="line2073"></a>2073           expanded = []
</span><span class="uncovered1"><a name="line2074"></a>2074 
</span><span class="uncovered0"><a name="line2075"></a>2075           bind_vars.each do |var|
</span><span class="uncovered1"><a name="line2076"></a>2076             if var.is_a?(Range)
</span><span class="uncovered0"><a name="line2077"></a>2077               expanded &lt;&lt; var.first
</span><span class="uncovered1"><a name="line2078"></a>2078               expanded &lt;&lt; var.last
</span><span class="uncovered0"><a name="line2079"></a>2079             else
</span><span class="uncovered1"><a name="line2080"></a>2080               expanded &lt;&lt; var
</span><span class="uncovered0"><a name="line2081"></a>2081             end
</span><span class="uncovered1"><a name="line2082"></a>2082           end
</span><span class="uncovered0"><a name="line2083"></a>2083 
</span><span class="uncovered1"><a name="line2084"></a>2084           expanded
</span><span class="uncovered0"><a name="line2085"></a>2085         end
</span><span class="inferred1"><a name="line2086"></a>2086 
</span><span class="marked0"><a name="line2087"></a>2087         def quote_bound_value(value) #:nodoc:
</span><span class="uncovered1"><a name="line2088"></a>2088           if value.respond_to?(:map) &amp;&amp; !value.is_a?(String)
</span><span class="uncovered0"><a name="line2089"></a>2089             if value.respond_to?(:empty?) &amp;&amp; value.empty?
</span><span class="uncovered1"><a name="line2090"></a>2090               connection.quote(nil)
</span><span class="uncovered0"><a name="line2091"></a>2091             else
</span><span class="uncovered1"><a name="line2092"></a>2092               value.map { |v| connection.quote(v) }.join(',')
</span><span class="uncovered0"><a name="line2093"></a>2093             end
</span><span class="uncovered1"><a name="line2094"></a>2094           else
</span><span class="uncovered0"><a name="line2095"></a>2095             connection.quote(value)
</span><span class="uncovered1"><a name="line2096"></a>2096           end
</span><span class="uncovered0"><a name="line2097"></a>2097         end
</span><span class="inferred1"><a name="line2098"></a>2098 
</span><span class="marked0"><a name="line2099"></a>2099         def raise_if_bind_arity_mismatch(statement, expected, provided) #:nodoc:
</span><span class="uncovered1"><a name="line2100"></a>2100           unless expected == provided
</span><span class="uncovered0"><a name="line2101"></a>2101             raise PreparedStatementInvalid, &quot;wrong number of bind variables (#{provided} for #{expected}) in: #{statement}&quot;
</span><span class="uncovered1"><a name="line2102"></a>2102           end
</span><span class="uncovered0"><a name="line2103"></a>2103         end
</span><span class="inferred1"><a name="line2104"></a>2104 
</span><span class="marked0"><a name="line2105"></a>2105         VALID_FIND_OPTIONS = [ :conditions, :include, :joins, :limit, :offset,
</span><span class="inferred1"><a name="line2106"></a>2106                                :order, :select, :readonly, :group, :from, :lock ]
</span><span class="inferred0"><a name="line2107"></a>2107 
</span><span class="marked1"><a name="line2108"></a>2108         def validate_find_options(options) #:nodoc:
</span><span class="uncovered0"><a name="line2109"></a>2109           options.assert_valid_keys(VALID_FIND_OPTIONS)
</span><span class="uncovered1"><a name="line2110"></a>2110         end
</span><span class="inferred0"><a name="line2111"></a>2111 
</span><span class="marked1"><a name="line2112"></a>2112         def set_readonly_option!(options) #:nodoc:
</span><span class="uncovered0"><a name="line2113"></a>2113           # Inherit :readonly from finder scope if set.  Otherwise,
</span><span class="uncovered1"><a name="line2114"></a>2114           # if :joins is not blank then :readonly defaults to true.
</span><span class="uncovered0"><a name="line2115"></a>2115           unless options.has_key?(:readonly)
</span><span class="uncovered1"><a name="line2116"></a>2116             if scoped_readonly = scope(:find, :readonly)
</span><span class="uncovered0"><a name="line2117"></a>2117               options[:readonly] = scoped_readonly
</span><span class="uncovered1"><a name="line2118"></a>2118             elsif !options[:joins].blank? &amp;&amp; !options[:select]
</span><span class="uncovered0"><a name="line2119"></a>2119               options[:readonly] = true
</span><span class="uncovered1"><a name="line2120"></a>2120             end
</span><span class="uncovered0"><a name="line2121"></a>2121           end
</span><span class="uncovered1"><a name="line2122"></a>2122         end
</span><span class="inferred0"><a name="line2123"></a>2123 
</span><span class="marked1"><a name="line2124"></a>2124         def encode_quoted_value(value) #:nodoc:
</span><span class="uncovered0"><a name="line2125"></a>2125           quoted_value = connection.quote(value)
</span><span class="uncovered1"><a name="line2126"></a>2126           quoted_value = &quot;'#{quoted_value[1..-2].gsub(/\'/, &quot;\\\\'&quot;)}'&quot; if quoted_value.include?(&quot;\\\'&quot;) # (for ruby mode) &quot;
</span><span class="uncovered0"><a name="line2127"></a>2127           quoted_value
</span><span class="uncovered1"><a name="line2128"></a>2128         end
</span><span class="uncovered0"><a name="line2129"></a>2129     end
</span><span class="inferred1"><a name="line2130"></a>2130 
</span><span class="marked0"><a name="line2131"></a>2131     public
</span><span class="inferred1"><a name="line2132"></a>2132       # New objects can be instantiated as either empty (pass no construction parameter) or pre-set with
</span><span class="inferred0"><a name="line2133"></a>2133       # attributes but not yet saved (pass a hash with key names matching the associated table column names).
</span><span class="inferred1"><a name="line2134"></a>2134       # In both instances, valid attribute keys are determined by the column names of the associated table --
</span><span class="inferred0"><a name="line2135"></a>2135       # hence you can't have attributes that aren't part of the table columns.
</span><span class="marked1"><a name="line2136"></a>2136       def initialize(attributes = nil)
</span><span class="uncovered0"><a name="line2137"></a>2137         @attributes = attributes_from_column_definition
</span><span class="uncovered1"><a name="line2138"></a>2138         @attributes_cache = {}
</span><span class="uncovered0"><a name="line2139"></a>2139         @new_record = true
</span><span class="uncovered1"><a name="line2140"></a>2140         ensure_proper_type
</span><span class="uncovered0"><a name="line2141"></a>2141         self.attributes = attributes unless attributes.nil?
</span><span class="uncovered1"><a name="line2142"></a>2142         self.class.send(:scope, :create).each { |att,value| self.send(&quot;#{att}=&quot;, value) } if self.class.send(:scoped?, :create)
</span><span class="uncovered0"><a name="line2143"></a>2143         result = yield self if block_given?
</span><span class="uncovered1"><a name="line2144"></a>2144         callback(:after_initialize) if respond_to_without_attributes?(:after_initialize)
</span><span class="uncovered0"><a name="line2145"></a>2145         result
</span><span class="uncovered1"><a name="line2146"></a>2146       end
</span><span class="inferred0"><a name="line2147"></a>2147 
</span><span class="inferred1"><a name="line2148"></a>2148       # A model instance's primary key is always available as model.id
</span><span class="inferred0"><a name="line2149"></a>2149       # whether you name it the default 'id' or set it to something else.
</span><span class="marked1"><a name="line2150"></a>2150       def id
</span><span class="uncovered0"><a name="line2151"></a>2151         attr_name = self.class.primary_key
</span><span class="uncovered1"><a name="line2152"></a>2152         column = column_for_attribute(attr_name)
</span><span class="uncovered0"><a name="line2153"></a>2153 
</span><span class="uncovered1"><a name="line2154"></a>2154         self.class.send(:define_read_method, :id, attr_name, column)
</span><span class="uncovered0"><a name="line2155"></a>2155         # now that the method exists, call it
</span><span class="uncovered1"><a name="line2156"></a>2156         self.send attr_name.to_sym
</span><span class="uncovered0"><a name="line2157"></a>2157 
</span><span class="uncovered1"><a name="line2158"></a>2158       end
</span><span class="inferred0"><a name="line2159"></a>2159 
</span><span class="inferred1"><a name="line2160"></a>2160       # Enables Active Record objects to be used as URL parameters in Action Pack automatically.
</span><span class="marked0"><a name="line2161"></a>2161       def to_param
</span><span class="uncovered1"><a name="line2162"></a>2162         # We can't use alias_method here, because method 'id' optimizes itself on the fly.
</span><span class="uncovered0"><a name="line2163"></a>2163         (id = self.id) ? id.to_s : nil # Be sure to stringify the id for routes
</span><span class="uncovered1"><a name="line2164"></a>2164       end
</span><span class="inferred0"><a name="line2165"></a>2165 
</span><span class="inferred1"><a name="line2166"></a>2166       # Returns a cache key that can be used to identify this record.
</span><span class="inferred0"><a name="line2167"></a>2167       #
</span><span class="inferred1"><a name="line2168"></a>2168       # ==== Examples
</span><span class="inferred0"><a name="line2169"></a>2169       #
</span><span class="inferred1"><a name="line2170"></a>2170       #   Product.new.cache_key     # =&gt; &quot;products/new&quot;
</span><span class="inferred0"><a name="line2171"></a>2171       #   Product.find(5).cache_key # =&gt; &quot;products/5&quot; (updated_at not available)
</span><span class="inferred1"><a name="line2172"></a>2172       #   Person.find(5).cache_key  # =&gt; &quot;people/5-20071224150000&quot; (updated_at available)
</span><span class="marked0"><a name="line2173"></a>2173       def cache_key
</span><span class="uncovered1"><a name="line2174"></a>2174         case
</span><span class="uncovered0"><a name="line2175"></a>2175         when new_record?
</span><span class="uncovered1"><a name="line2176"></a>2176           &quot;#{self.class.name.tableize}/new&quot;
</span><span class="uncovered0"><a name="line2177"></a>2177         when self[:updated_at]
</span><span class="uncovered1"><a name="line2178"></a>2178           &quot;#{self.class.name.tableize}/#{id}-#{updated_at.to_s(:number)}&quot;
</span><span class="uncovered0"><a name="line2179"></a>2179         else
</span><span class="uncovered1"><a name="line2180"></a>2180           &quot;#{self.class.name.tableize}/#{id}&quot;
</span><span class="uncovered0"><a name="line2181"></a>2181         end
</span><span class="uncovered1"><a name="line2182"></a>2182       end
</span><span class="inferred0"><a name="line2183"></a>2183 
</span><span class="marked1"><a name="line2184"></a>2184       def id_before_type_cast #:nodoc:
</span><span class="uncovered0"><a name="line2185"></a>2185         read_attribute_before_type_cast(self.class.primary_key)
</span><span class="uncovered1"><a name="line2186"></a>2186       end
</span><span class="inferred0"><a name="line2187"></a>2187 
</span><span class="marked1"><a name="line2188"></a>2188       def quoted_id #:nodoc:
</span><span class="uncovered0"><a name="line2189"></a>2189         quote_value(id, column_for_attribute(self.class.primary_key))
</span><span class="uncovered1"><a name="line2190"></a>2190       end
</span><span class="inferred0"><a name="line2191"></a>2191 
</span><span class="inferred1"><a name="line2192"></a>2192       # Sets the primary ID.
</span><span class="marked0"><a name="line2193"></a>2193       def id=(value)
</span><span class="uncovered1"><a name="line2194"></a>2194         write_attribute(self.class.primary_key, value)
</span><span class="uncovered0"><a name="line2195"></a>2195       end
</span><span class="inferred1"><a name="line2196"></a>2196 
</span><span class="inferred0"><a name="line2197"></a>2197       # Returns true if this object hasn't been saved yet -- that is, a record for the object doesn't exist yet.
</span><span class="marked1"><a name="line2198"></a>2198       def new_record?
</span><span class="uncovered0"><a name="line2199"></a>2199         defined?(@new_record) &amp;&amp; @new_record
</span><span class="uncovered1"><a name="line2200"></a>2200       end
</span><span class="inferred0"><a name="line2201"></a>2201 
</span><span class="inferred1"><a name="line2202"></a>2202       # * No record exists: Creates a new record with values matching those of the object attributes.
</span><span class="inferred0"><a name="line2203"></a>2203       # * A record does exist: Updates the record with values matching those of the object attributes.
</span><span class="inferred1"><a name="line2204"></a>2204       #
</span><span class="inferred0"><a name="line2205"></a>2205       # Note: If your model specifies any validations then the method declaration dynamically
</span><span class="inferred1"><a name="line2206"></a>2206       # changes to:
</span><span class="inferred0"><a name="line2207"></a>2207       #   save(perform_validation=true)
</span><span class="inferred1"><a name="line2208"></a>2208       # Calling save(false) saves the model without running validations.
</span><span class="inferred0"><a name="line2209"></a>2209       # See ActiveRecord::Validations for more information.
</span><span class="marked1"><a name="line2210"></a>2210       def save
</span><span class="uncovered0"><a name="line2211"></a>2211         create_or_update
</span><span class="uncovered1"><a name="line2212"></a>2212       end
</span><span class="inferred0"><a name="line2213"></a>2213 
</span><span class="inferred1"><a name="line2214"></a>2214       # Attempts to save the record, but instead of just returning false if it couldn't happen, it raises a
</span><span class="inferred0"><a name="line2215"></a>2215       # RecordNotSaved exception
</span><span class="marked1"><a name="line2216"></a>2216       def save!
</span><span class="uncovered0"><a name="line2217"></a>2217         create_or_update || raise(RecordNotSaved)
</span><span class="uncovered1"><a name="line2218"></a>2218       end
</span><span class="inferred0"><a name="line2219"></a>2219 
</span><span class="inferred1"><a name="line2220"></a>2220       # Deletes the record in the database and freezes this instance to reflect that no changes should
</span><span class="inferred0"><a name="line2221"></a>2221       # be made (since they can't be persisted).
</span><span class="marked1"><a name="line2222"></a>2222       def destroy
</span><span class="uncovered0"><a name="line2223"></a>2223         unless new_record?
</span><span class="uncovered1"><a name="line2224"></a>2224           connection.delete &lt;&lt;-end_sql, &quot;#{self.class.name} Destroy&quot;
</span><span class="uncovered0"><a name="line2225"></a>2225             DELETE FROM #{self.class.quoted_table_name}
</span><span class="uncovered1"><a name="line2226"></a>2226             WHERE #{connection.quote_column_name(self.class.primary_key)} = #{quoted_id}
</span><span class="uncovered0"><a name="line2227"></a>2227           end_sql
</span><span class="uncovered1"><a name="line2228"></a>2228         end
</span><span class="uncovered0"><a name="line2229"></a>2229 
</span><span class="uncovered1"><a name="line2230"></a>2230         freeze
</span><span class="uncovered0"><a name="line2231"></a>2231       end
</span><span class="inferred1"><a name="line2232"></a>2232 
</span><span class="inferred0"><a name="line2233"></a>2233       # Returns a clone of the record that hasn't been assigned an id yet and
</span><span class="inferred1"><a name="line2234"></a>2234       # is treated as a new record.  Note that this is a &quot;shallow&quot; clone:
</span><span class="inferred0"><a name="line2235"></a>2235       # it copies the object's attributes only, not its associations.
</span><span class="inferred1"><a name="line2236"></a>2236       # The extent of a &quot;deep&quot; clone is application-specific and is therefore
</span><span class="inferred0"><a name="line2237"></a>2237       # left to the application to implement according to its need.
</span><span class="marked1"><a name="line2238"></a>2238       def clone
</span><span class="uncovered0"><a name="line2239"></a>2239         attrs = clone_attributes(:read_attribute_before_type_cast)
</span><span class="uncovered1"><a name="line2240"></a>2240         attrs.delete(self.class.primary_key)
</span><span class="uncovered0"><a name="line2241"></a>2241         record = self.class.new
</span><span class="uncovered1"><a name="line2242"></a>2242         record.send :instance_variable_set, '@attributes', attrs
</span><span class="uncovered0"><a name="line2243"></a>2243         record
</span><span class="uncovered1"><a name="line2244"></a>2244       end
</span><span class="inferred0"><a name="line2245"></a>2245 
</span><span class="inferred1"><a name="line2246"></a>2246       # Returns an instance of the specified +klass+ with the attributes of the current record. This is mostly useful in relation to
</span><span class="inferred0"><a name="line2247"></a>2247       # single-table inheritance structures where you want a subclass to appear as the superclass. This can be used along with record
</span><span class="inferred1"><a name="line2248"></a>2248       # identification in Action Pack to allow, say, &lt;tt&gt;Client &lt; Company&lt;/tt&gt; to do something like render &lt;tt&gt;:partial =&gt; @client.becomes(Company)&lt;/tt&gt;
</span><span class="inferred0"><a name="line2249"></a>2249       # to render that instance using the companies/company partial instead of clients/client.
</span><span class="inferred1"><a name="line2250"></a>2250       #
</span><span class="inferred0"><a name="line2251"></a>2251       # Note: The new instance will share a link to the same attributes as the original class. So any change to the attributes in either
</span><span class="inferred1"><a name="line2252"></a>2252       # instance will affect the other.
</span><span class="marked0"><a name="line2253"></a>2253       def becomes(klass)
</span><span class="uncovered1"><a name="line2254"></a>2254         returning klass.new do |became|
</span><span class="uncovered0"><a name="line2255"></a>2255           became.instance_variable_set(&quot;@attributes&quot;, @attributes)
</span><span class="uncovered1"><a name="line2256"></a>2256           became.instance_variable_set(&quot;@attributes_cache&quot;, @attributes_cache)
</span><span class="uncovered0"><a name="line2257"></a>2257           became.instance_variable_set(&quot;@new_record&quot;, new_record?)
</span><span class="uncovered1"><a name="line2258"></a>2258         end
</span><span class="uncovered0"><a name="line2259"></a>2259       end
</span><span class="inferred1"><a name="line2260"></a>2260 
</span><span class="inferred0"><a name="line2261"></a>2261       # Updates a single attribute and saves the record. This is especially useful for boolean flags on existing records.
</span><span class="inferred1"><a name="line2262"></a>2262       # Note: This method is overwritten by the Validation module that'll make sure that updates made with this method
</span><span class="inferred0"><a name="line2263"></a>2263       # aren't subjected to validation checks. Hence, attributes can be updated even if the full object isn't valid.
</span><span class="marked1"><a name="line2264"></a>2264       def update_attribute(name, value)
</span><span class="uncovered0"><a name="line2265"></a>2265         send(name.to_s + '=', value)
</span><span class="uncovered1"><a name="line2266"></a>2266         save
</span><span class="uncovered0"><a name="line2267"></a>2267       end
</span><span class="inferred1"><a name="line2268"></a>2268 
</span><span class="inferred0"><a name="line2269"></a>2269       # Updates all the attributes from the passed-in Hash and saves the record. If the object is invalid, the saving will
</span><span class="inferred1"><a name="line2270"></a>2270       # fail and false will be returned.
</span><span class="marked0"><a name="line2271"></a>2271       def update_attributes(attributes)
</span><span class="uncovered1"><a name="line2272"></a>2272         self.attributes = attributes
</span><span class="uncovered0"><a name="line2273"></a>2273         save
</span><span class="uncovered1"><a name="line2274"></a>2274       end
</span><span class="inferred0"><a name="line2275"></a>2275 
</span><span class="inferred1"><a name="line2276"></a>2276       # Updates an object just like Base.update_attributes but calls save! instead of save so an exception is raised if the record is invalid.
</span><span class="marked0"><a name="line2277"></a>2277       def update_attributes!(attributes)
</span><span class="uncovered1"><a name="line2278"></a>2278         self.attributes = attributes
</span><span class="uncovered0"><a name="line2279"></a>2279         save!
</span><span class="uncovered1"><a name="line2280"></a>2280       end
</span><span class="inferred0"><a name="line2281"></a>2281 
</span><span class="inferred1"><a name="line2282"></a>2282       # Initializes +attribute+ to zero if +nil+ and adds the value passed as +by+ (default is 1).
</span><span class="inferred0"><a name="line2283"></a>2283       # The increment is performed directly on the underlying attribute, no setter is invoked.
</span><span class="inferred1"><a name="line2284"></a>2284       # Only makes sense for number-based attributes. Returns +self+.
</span><span class="marked0"><a name="line2285"></a>2285       def increment(attribute, by = 1)
</span><span class="uncovered1"><a name="line2286"></a>2286         self[attribute] ||= 0
</span><span class="uncovered0"><a name="line2287"></a>2287         self[attribute] += by
</span><span class="uncovered1"><a name="line2288"></a>2288         self
</span><span class="uncovered0"><a name="line2289"></a>2289       end
</span><span class="inferred1"><a name="line2290"></a>2290 
</span><span class="inferred0"><a name="line2291"></a>2291       # Wrapper around +increment+ that saves the record. This method differs from
</span><span class="inferred1"><a name="line2292"></a>2292       # its non-bang version in that it passes through the attribute setter.
</span><span class="inferred0"><a name="line2293"></a>2293       # Saving is not subjected to validation checks. Returns +true+ if the
</span><span class="inferred1"><a name="line2294"></a>2294       # record could be saved.
</span><span class="marked0"><a name="line2295"></a>2295       def increment!(attribute, by = 1)
</span><span class="uncovered1"><a name="line2296"></a>2296         increment(attribute, by).update_attribute(attribute, self[attribute])
</span><span class="uncovered0"><a name="line2297"></a>2297       end
</span><span class="inferred1"><a name="line2298"></a>2298 
</span><span class="inferred0"><a name="line2299"></a>2299       # Initializes +attribute+ to zero if +nil+ and subtracts the value passed as +by+ (default is 1).
</span><span class="inferred1"><a name="line2300"></a>2300       # The decrement is performed directly on the underlying attribute, no setter is invoked.
</span><span class="inferred0"><a name="line2301"></a>2301       # Only makes sense for number-based attributes. Returns +self+.
</span><span class="marked1"><a name="line2302"></a>2302       def decrement(attribute, by = 1)
</span><span class="uncovered0"><a name="line2303"></a>2303         self[attribute] ||= 0
</span><span class="uncovered1"><a name="line2304"></a>2304         self[attribute] -= by
</span><span class="uncovered0"><a name="line2305"></a>2305         self
</span><span class="uncovered1"><a name="line2306"></a>2306       end
</span><span class="inferred0"><a name="line2307"></a>2307 
</span><span class="inferred1"><a name="line2308"></a>2308       # Wrapper around +decrement+ that saves the record. This method differs from
</span><span class="inferred0"><a name="line2309"></a>2309       # its non-bang version in that it passes through the attribute setter.
</span><span class="inferred1"><a name="line2310"></a>2310       # Saving is not subjected to validation checks. Returns +true+ if the
</span><span class="inferred0"><a name="line2311"></a>2311       # record could be saved.
</span><span class="marked1"><a name="line2312"></a>2312       def decrement!(attribute, by = 1)
</span><span class="uncovered0"><a name="line2313"></a>2313         decrement(attribute, by).update_attribute(attribute, self[attribute])
</span><span class="uncovered1"><a name="line2314"></a>2314       end
</span><span class="inferred0"><a name="line2315"></a>2315 
</span><span class="inferred1"><a name="line2316"></a>2316       # Assigns to +attribute+ the boolean opposite of &lt;tt&gt;attribute?&lt;/tt&gt;. So
</span><span class="inferred0"><a name="line2317"></a>2317       # if the predicate returns +true+ the attribute will become +false+. This
</span><span class="inferred1"><a name="line2318"></a>2318       # method toggles directly the underlying value without calling any setter.
</span><span class="inferred0"><a name="line2319"></a>2319       # Returns +self+.
</span><span class="marked1"><a name="line2320"></a>2320       def toggle(attribute)
</span><span class="uncovered0"><a name="line2321"></a>2321         self[attribute] = !send(&quot;#{attribute}?&quot;)
</span><span class="uncovered1"><a name="line2322"></a>2322         self
</span><span class="uncovered0"><a name="line2323"></a>2323       end
</span><span class="inferred1"><a name="line2324"></a>2324 
</span><span class="inferred0"><a name="line2325"></a>2325       # Wrapper around +toggle+ that saves the record. This method differs from
</span><span class="inferred1"><a name="line2326"></a>2326       # its non-bang version in that it passes through the attribute setter.
</span><span class="inferred0"><a name="line2327"></a>2327       # Saving is not subjected to validation checks. Returns +true+ if the
</span><span class="inferred1"><a name="line2328"></a>2328       # record could be saved.
</span><span class="marked0"><a name="line2329"></a>2329       def toggle!(attribute)
</span><span class="uncovered1"><a name="line2330"></a>2330         toggle(attribute).update_attribute(attribute, self[attribute])
</span><span class="uncovered0"><a name="line2331"></a>2331       end
</span><span class="inferred1"><a name="line2332"></a>2332 
</span><span class="inferred0"><a name="line2333"></a>2333       # Reloads the attributes of this object from the database.
</span><span class="inferred1"><a name="line2334"></a>2334       # The optional options argument is passed to find when reloading so you
</span><span class="inferred0"><a name="line2335"></a>2335       # may do e.g. record.reload(:lock =&gt; true) to reload the same record with
</span><span class="inferred1"><a name="line2336"></a>2336       # an exclusive row lock.
</span><span class="marked0"><a name="line2337"></a>2337       def reload(options = nil)
</span><span class="uncovered1"><a name="line2338"></a>2338         clear_aggregation_cache
</span><span class="uncovered0"><a name="line2339"></a>2339         clear_association_cache
</span><span class="uncovered1"><a name="line2340"></a>2340         @attributes.update(self.class.find(self.id, options).instance_variable_get('@attributes'))
</span><span class="uncovered0"><a name="line2341"></a>2341         @attributes_cache = {}
</span><span class="uncovered1"><a name="line2342"></a>2342         self
</span><span class="uncovered0"><a name="line2343"></a>2343       end
</span><span class="inferred1"><a name="line2344"></a>2344 
</span><span class="inferred0"><a name="line2345"></a>2345       # Returns the value of the attribute identified by &lt;tt&gt;attr_name&lt;/tt&gt; after it has been typecast (for example,
</span><span class="inferred1"><a name="line2346"></a>2346       # &quot;2004-12-12&quot; in a data column is cast to a date object, like Date.new(2004, 12, 12)).
</span><span class="inferred0"><a name="line2347"></a>2347       # (Alias for the protected read_attribute method).
</span><span class="marked1"><a name="line2348"></a>2348       def [](attr_name)
</span><span class="uncovered0"><a name="line2349"></a>2349         read_attribute(attr_name)
</span><span class="uncovered1"><a name="line2350"></a>2350       end
</span><span class="inferred0"><a name="line2351"></a>2351 
</span><span class="inferred1"><a name="line2352"></a>2352       # Updates the attribute identified by &lt;tt&gt;attr_name&lt;/tt&gt; with the specified +value+.
</span><span class="inferred0"><a name="line2353"></a>2353       # (Alias for the protected write_attribute method).
</span><span class="marked1"><a name="line2354"></a>2354       def []=(attr_name, value)
</span><span class="uncovered0"><a name="line2355"></a>2355         write_attribute(attr_name, value)
</span><span class="uncovered1"><a name="line2356"></a>2356       end
</span><span class="inferred0"><a name="line2357"></a>2357 
</span><span class="inferred1"><a name="line2358"></a>2358       # Allows you to set all the attributes at once by passing in a hash with keys
</span><span class="inferred0"><a name="line2359"></a>2359       # matching the attribute names (which again matches the column names). Sensitive attributes can be protected
</span><span class="inferred1"><a name="line2360"></a>2360       # from this form of mass-assignment by using the +attr_protected+ macro. Or you can alternatively
</span><span class="inferred0"><a name="line2361"></a>2361       # specify which attributes *can* be accessed with the +attr_accessible+ macro. Then all the
</span><span class="inferred1"><a name="line2362"></a>2362       # attributes not included in that won't be allowed to be mass-assigned.
</span><span class="marked0"><a name="line2363"></a>2363       def attributes=(new_attributes, guard_protected_attributes = true)
</span><span class="uncovered1"><a name="line2364"></a>2364         return if new_attributes.nil?
</span><span class="uncovered0"><a name="line2365"></a>2365         attributes = new_attributes.dup
</span><span class="uncovered1"><a name="line2366"></a>2366         attributes.stringify_keys!
</span><span class="uncovered0"><a name="line2367"></a>2367 
</span><span class="uncovered1"><a name="line2368"></a>2368         multi_parameter_attributes = []
</span><span class="uncovered0"><a name="line2369"></a>2369         attributes = remove_attributes_protected_from_mass_assignment(attributes) if guard_protected_attributes
</span><span class="uncovered1"><a name="line2370"></a>2370 
</span><span class="uncovered0"><a name="line2371"></a>2371         attributes.each do |k, v|
</span><span class="uncovered1"><a name="line2372"></a>2372           k.include?(&quot;(&quot;) ? multi_parameter_attributes &lt;&lt; [ k, v ] : send(k + &quot;=&quot;, v)
</span><span class="uncovered0"><a name="line2373"></a>2373         end
</span><span class="uncovered1"><a name="line2374"></a>2374 
</span><span class="uncovered0"><a name="line2375"></a>2375         assign_multiparameter_attributes(multi_parameter_attributes)
</span><span class="uncovered1"><a name="line2376"></a>2376       end
</span><span class="inferred0"><a name="line2377"></a>2377 
</span><span class="inferred1"><a name="line2378"></a>2378 
</span><span class="inferred0"><a name="line2379"></a>2379       # Returns a hash of all the attributes with their names as keys and the values of the attributes as values.
</span><span class="marked1"><a name="line2380"></a>2380       def attributes
</span><span class="uncovered0"><a name="line2381"></a>2381         self.attribute_names.inject({}) do |attrs, name|
</span><span class="uncovered1"><a name="line2382"></a>2382           attrs[name] = read_attribute(name)
</span><span class="uncovered0"><a name="line2383"></a>2383           attrs
</span><span class="uncovered1"><a name="line2384"></a>2384         end
</span><span class="uncovered0"><a name="line2385"></a>2385       end
</span><span class="inferred1"><a name="line2386"></a>2386 
</span><span class="inferred0"><a name="line2387"></a>2387       # Returns a hash of attributes before typecasting and deserialization.
</span><span class="marked1"><a name="line2388"></a>2388       def attributes_before_type_cast
</span><span class="uncovered0"><a name="line2389"></a>2389         self.attribute_names.inject({}) do |attrs, name|
</span><span class="uncovered1"><a name="line2390"></a>2390           attrs[name] = read_attribute_before_type_cast(name)
</span><span class="uncovered0"><a name="line2391"></a>2391           attrs
</span><span class="uncovered1"><a name="line2392"></a>2392         end
</span><span class="uncovered0"><a name="line2393"></a>2393       end
</span><span class="inferred1"><a name="line2394"></a>2394 
</span><span class="inferred0"><a name="line2395"></a>2395       # Format attributes nicely for inspect.
</span><span class="marked1"><a name="line2396"></a>2396       def attribute_for_inspect(attr_name)
</span><span class="uncovered0"><a name="line2397"></a>2397         value = read_attribute(attr_name)
</span><span class="uncovered1"><a name="line2398"></a>2398 
</span><span class="uncovered0"><a name="line2399"></a>2399         if value.is_a?(String) &amp;&amp; value.length &gt; 50
</span><span class="uncovered1"><a name="line2400"></a>2400           &quot;#{value[0..50]}...&quot;.inspect
</span><span class="uncovered0"><a name="line2401"></a>2401         elsif value.is_a?(Date) || value.is_a?(Time)
</span><span class="uncovered1"><a name="line2402"></a>2402           %(&quot;#{value.to_s(:db)}&quot;)
</span><span class="uncovered0"><a name="line2403"></a>2403         else
</span><span class="uncovered1"><a name="line2404"></a>2404           value.inspect
</span><span class="uncovered0"><a name="line2405"></a>2405         end
</span><span class="uncovered1"><a name="line2406"></a>2406       end
</span><span class="inferred0"><a name="line2407"></a>2407 
</span><span class="inferred1"><a name="line2408"></a>2408       # Returns true if the specified +attribute+ has been set by the user or by a database load and is neither
</span><span class="inferred0"><a name="line2409"></a>2409       # nil nor empty? (the latter only applies to objects that respond to empty?, most notably Strings).
</span><span class="marked1"><a name="line2410"></a>2410       def attribute_present?(attribute)
</span><span class="uncovered0"><a name="line2411"></a>2411         value = read_attribute(attribute)
</span><span class="uncovered1"><a name="line2412"></a>2412         !value.blank?
</span><span class="uncovered0"><a name="line2413"></a>2413       end
</span><span class="inferred1"><a name="line2414"></a>2414 
</span><span class="inferred0"><a name="line2415"></a>2415       # Returns true if the given attribute is in the attributes hash
</span><span class="marked1"><a name="line2416"></a>2416       def has_attribute?(attr_name)
</span><span class="uncovered0"><a name="line2417"></a>2417         @attributes.has_key?(attr_name.to_s)
</span><span class="uncovered1"><a name="line2418"></a>2418       end
</span><span class="inferred0"><a name="line2419"></a>2419 
</span><span class="inferred1"><a name="line2420"></a>2420       # Returns an array of names for the attributes available on this object sorted alphabetically.
</span><span class="marked0"><a name="line2421"></a>2421       def attribute_names
</span><span class="uncovered1"><a name="line2422"></a>2422         @attributes.keys.sort
</span><span class="uncovered0"><a name="line2423"></a>2423       end
</span><span class="inferred1"><a name="line2424"></a>2424 
</span><span class="inferred0"><a name="line2425"></a>2425       # Returns the column object for the named attribute.
</span><span class="marked1"><a name="line2426"></a>2426       def column_for_attribute(name)
</span><span class="uncovered0"><a name="line2427"></a>2427         self.class.columns_hash[name.to_s]
</span><span class="uncovered1"><a name="line2428"></a>2428       end
</span><span class="inferred0"><a name="line2429"></a>2429 
</span><span class="inferred1"><a name="line2430"></a>2430       # Returns true if the +comparison_object+ is the same object, or is of the same type and has the same id.
</span><span class="marked0"><a name="line2431"></a>2431       def ==(comparison_object)
</span><span class="uncovered1"><a name="line2432"></a>2432         comparison_object.equal?(self) ||
</span><span class="uncovered0"><a name="line2433"></a>2433           (comparison_object.instance_of?(self.class) &amp;&amp;
</span><span class="uncovered1"><a name="line2434"></a>2434             comparison_object.id == id &amp;&amp;
</span><span class="uncovered0"><a name="line2435"></a>2435             !comparison_object.new_record?)
</span><span class="uncovered1"><a name="line2436"></a>2436       end
</span><span class="inferred0"><a name="line2437"></a>2437 
</span><span class="inferred1"><a name="line2438"></a>2438       # Delegates to ==
</span><span class="marked0"><a name="line2439"></a>2439       def eql?(comparison_object)
</span><span class="uncovered1"><a name="line2440"></a>2440         self == (comparison_object)
</span><span class="uncovered0"><a name="line2441"></a>2441       end
</span><span class="inferred1"><a name="line2442"></a>2442 
</span><span class="inferred0"><a name="line2443"></a>2443       # Delegates to id in order to allow two records of the same type and id to work with something like:
</span><span class="inferred1"><a name="line2444"></a>2444       #   [ Person.find(1), Person.find(2), Person.find(3) ] &amp; [ Person.find(1), Person.find(4) ] # =&gt; [ Person.find(1) ]
</span><span class="marked0"><a name="line2445"></a>2445       def hash
</span><span class="uncovered1"><a name="line2446"></a>2446         id.hash
</span><span class="uncovered0"><a name="line2447"></a>2447       end
</span><span class="inferred1"><a name="line2448"></a>2448 
</span><span class="inferred0"><a name="line2449"></a>2449       # Freeze the attributes hash such that associations are still accessible, even on destroyed records.
</span><span class="marked1"><a name="line2450"></a>2450       def freeze
</span><span class="uncovered0"><a name="line2451"></a>2451         @attributes.freeze; self
</span><span class="uncovered1"><a name="line2452"></a>2452       end
</span><span class="inferred0"><a name="line2453"></a>2453 
</span><span class="inferred1"><a name="line2454"></a>2454       # Returns +true+ if the attributes hash has been frozen.
</span><span class="marked0"><a name="line2455"></a>2455       def frozen?
</span><span class="uncovered1"><a name="line2456"></a>2456         @attributes.frozen?
</span><span class="uncovered0"><a name="line2457"></a>2457       end
</span><span class="inferred1"><a name="line2458"></a>2458 
</span><span class="inferred0"><a name="line2459"></a>2459       # Returns +true+ if the record is read only. Records loaded through joins with piggy-back
</span><span class="inferred1"><a name="line2460"></a>2460       # attributes will be marked as read only since they cannot be saved.
</span><span class="marked0"><a name="line2461"></a>2461       def readonly?
</span><span class="uncovered1"><a name="line2462"></a>2462         defined?(@readonly) &amp;&amp; @readonly == true
</span><span class="uncovered0"><a name="line2463"></a>2463       end
</span><span class="inferred1"><a name="line2464"></a>2464 
</span><span class="inferred0"><a name="line2465"></a>2465       # Marks this record as read only.
</span><span class="marked1"><a name="line2466"></a>2466       def readonly!
</span><span class="uncovered0"><a name="line2467"></a>2467         @readonly = true
</span><span class="uncovered1"><a name="line2468"></a>2468       end
</span><span class="inferred0"><a name="line2469"></a>2469 
</span><span class="inferred1"><a name="line2470"></a>2470       # Returns the contents of the record as a nicely formatted string.
</span><span class="marked0"><a name="line2471"></a>2471       def inspect
</span><span class="uncovered1"><a name="line2472"></a>2472         attributes_as_nice_string = self.class.column_names.collect { |name|
</span><span class="uncovered0"><a name="line2473"></a>2473           if has_attribute?(name) || new_record?
</span><span class="uncovered1"><a name="line2474"></a>2474             &quot;#{name}: #{attribute_for_inspect(name)}&quot;
</span><span class="uncovered0"><a name="line2475"></a>2475           end
</span><span class="uncovered1"><a name="line2476"></a>2476         }.compact.join(&quot;, &quot;)
</span><span class="uncovered0"><a name="line2477"></a>2477         &quot;#&lt;#{self.class} #{attributes_as_nice_string}&gt;&quot;
</span><span class="uncovered1"><a name="line2478"></a>2478       end
</span><span class="inferred0"><a name="line2479"></a>2479 
</span><span class="marked1"><a name="line2480"></a>2480     private
</span><span class="marked0"><a name="line2481"></a>2481       def create_or_update
</span><span class="uncovered1"><a name="line2482"></a>2482         raise ReadOnlyRecord if readonly?
</span><span class="uncovered0"><a name="line2483"></a>2483         result = new_record? ? create : update
</span><span class="uncovered1"><a name="line2484"></a>2484         result != false
</span><span class="uncovered0"><a name="line2485"></a>2485       end
</span><span class="inferred1"><a name="line2486"></a>2486 
</span><span class="inferred0"><a name="line2487"></a>2487       # Updates the associated record with values matching those of the instance attributes.
</span><span class="inferred1"><a name="line2488"></a>2488       # Returns the number of affected rows.
</span><span class="marked0"><a name="line2489"></a>2489       def update(attribute_names = @attributes.keys)
</span><span class="uncovered1"><a name="line2490"></a>2490         quoted_attributes = attributes_with_quotes(false, false, attribute_names)
</span><span class="uncovered0"><a name="line2491"></a>2491         return 0 if quoted_attributes.empty?
</span><span class="uncovered1"><a name="line2492"></a>2492         connection.update(
</span><span class="uncovered0"><a name="line2493"></a>2493           &quot;UPDATE #{self.class.quoted_table_name} &quot; +
</span><span class="uncovered1"><a name="line2494"></a>2494           &quot;SET #{quoted_comma_pair_list(connection, quoted_attributes)} &quot; +
</span><span class="uncovered0"><a name="line2495"></a>2495           &quot;WHERE #{connection.quote_column_name(self.class.primary_key)} = #{quote_value(id)}&quot;,
</span><span class="uncovered1"><a name="line2496"></a>2496           &quot;#{self.class.name} Update&quot;
</span><span class="uncovered0"><a name="line2497"></a>2497         )
</span><span class="uncovered1"><a name="line2498"></a>2498       end
</span><span class="inferred0"><a name="line2499"></a>2499 
</span><span class="inferred1"><a name="line2500"></a>2500       # Creates a record with values matching those of the instance attributes
</span><span class="inferred0"><a name="line2501"></a>2501       # and returns its id.
</span><span class="marked1"><a name="line2502"></a>2502       def create
</span><span class="uncovered0"><a name="line2503"></a>2503         if self.id.nil? &amp;&amp; connection.prefetch_primary_key?(self.class.table_name)
</span><span class="uncovered1"><a name="line2504"></a>2504           self.id = connection.next_sequence_value(self.class.sequence_name)
</span><span class="uncovered0"><a name="line2505"></a>2505         end
</span><span class="uncovered1"><a name="line2506"></a>2506 
</span><span class="uncovered0"><a name="line2507"></a>2507         quoted_attributes = attributes_with_quotes
</span><span class="uncovered1"><a name="line2508"></a>2508 
</span><span class="uncovered0"><a name="line2509"></a>2509         statement = if quoted_attributes.empty?
</span><span class="uncovered1"><a name="line2510"></a>2510           connection.empty_insert_statement(self.class.table_name)
</span><span class="uncovered0"><a name="line2511"></a>2511         else
</span><span class="uncovered1"><a name="line2512"></a>2512           &quot;INSERT INTO #{self.class.quoted_table_name} &quot; +
</span><span class="uncovered0"><a name="line2513"></a>2513           &quot;(#{quoted_column_names.join(', ')}) &quot; +
</span><span class="uncovered1"><a name="line2514"></a>2514           &quot;VALUES(#{quoted_attributes.values.join(', ')})&quot;
</span><span class="uncovered0"><a name="line2515"></a>2515         end
</span><span class="uncovered1"><a name="line2516"></a>2516 
</span><span class="uncovered0"><a name="line2517"></a>2517         self.id = connection.insert(statement, &quot;#{self.class.name} Create&quot;,
</span><span class="uncovered1"><a name="line2518"></a>2518           self.class.primary_key, self.id, self.class.sequence_name)
</span><span class="uncovered0"><a name="line2519"></a>2519 
</span><span class="uncovered1"><a name="line2520"></a>2520         @new_record = false
</span><span class="uncovered0"><a name="line2521"></a>2521         id
</span><span class="uncovered1"><a name="line2522"></a>2522       end
</span><span class="inferred0"><a name="line2523"></a>2523 
</span><span class="inferred1"><a name="line2524"></a>2524       # Sets the attribute used for single table inheritance to this class name if this is not the ActiveRecord::Base descendent.
</span><span class="inferred0"><a name="line2525"></a>2525       # Considering the hierarchy Reply &lt; Message &lt; ActiveRecord::Base, this makes it possible to do Reply.new without having to
</span><span class="inferred1"><a name="line2526"></a>2526       # set &lt;tt&gt;Reply[Reply.inheritance_column] = &quot;Reply&quot;&lt;/tt&gt; yourself. No such attribute would be set for objects of the
</span><span class="inferred0"><a name="line2527"></a>2527       # Message class in that example.
</span><span class="marked1"><a name="line2528"></a>2528       def ensure_proper_type
</span><span class="uncovered0"><a name="line2529"></a>2529         unless self.class.descends_from_active_record?
</span><span class="uncovered1"><a name="line2530"></a>2530           write_attribute(self.class.inheritance_column, self.class.sti_name)
</span><span class="uncovered0"><a name="line2531"></a>2531         end
</span><span class="uncovered1"><a name="line2532"></a>2532       end
</span><span class="inferred0"><a name="line2533"></a>2533 
</span><span class="marked1"><a name="line2534"></a>2534       def convert_number_column_value(value)
</span><span class="uncovered0"><a name="line2535"></a>2535         case value
</span><span class="uncovered1"><a name="line2536"></a>2536           when FalseClass; 0
</span><span class="uncovered0"><a name="line2537"></a>2537           when TrueClass;  1
</span><span class="uncovered1"><a name="line2538"></a>2538           when '';         nil
</span><span class="uncovered0"><a name="line2539"></a>2539           else value
</span><span class="uncovered1"><a name="line2540"></a>2540         end
</span><span class="uncovered0"><a name="line2541"></a>2541       end
</span><span class="inferred1"><a name="line2542"></a>2542 
</span><span class="marked0"><a name="line2543"></a>2543       def remove_attributes_protected_from_mass_assignment(attributes)
</span><span class="uncovered1"><a name="line2544"></a>2544         safe_attributes =
</span><span class="uncovered0"><a name="line2545"></a>2545           if self.class.accessible_attributes.nil? &amp;&amp; self.class.protected_attributes.nil?
</span><span class="uncovered1"><a name="line2546"></a>2546             attributes.reject { |key, value| attributes_protected_by_default.include?(key.gsub(/\(.+/, &quot;&quot;)) }
</span><span class="uncovered0"><a name="line2547"></a>2547           elsif self.class.protected_attributes.nil?
</span><span class="uncovered1"><a name="line2548"></a>2548             attributes.reject { |key, value| !self.class.accessible_attributes.include?(key.gsub(/\(.+/, &quot;&quot;)) || attributes_protected_by_default.include?(key.gsub(/\(.+/, &quot;&quot;)) }
</span><span class="uncovered0"><a name="line2549"></a>2549           elsif self.class.accessible_attributes.nil?
</span><span class="uncovered1"><a name="line2550"></a>2550             attributes.reject { |key, value| self.class.protected_attributes.include?(key.gsub(/\(.+/,&quot;&quot;)) || attributes_protected_by_default.include?(key.gsub(/\(.+/, &quot;&quot;)) }
</span><span class="uncovered0"><a name="line2551"></a>2551           else
</span><span class="uncovered1"><a name="line2552"></a>2552             raise &quot;Declare either attr_protected or attr_accessible for #{self.class}, but not both.&quot;
</span><span class="uncovered0"><a name="line2553"></a>2553           end
</span><span class="uncovered1"><a name="line2554"></a>2554 
</span><span class="uncovered0"><a name="line2555"></a>2555         removed_attributes = attributes.keys - safe_attributes.keys
</span><span class="uncovered1"><a name="line2556"></a>2556 
</span><span class="uncovered0"><a name="line2557"></a>2557         if removed_attributes.any?
</span><span class="uncovered1"><a name="line2558"></a>2558           logger.debug &quot;WARNING: Can't mass-assign these protected attributes: #{removed_attributes.join(', ')}&quot;
</span><span class="uncovered0"><a name="line2559"></a>2559         end
</span><span class="uncovered1"><a name="line2560"></a>2560 
</span><span class="uncovered0"><a name="line2561"></a>2561         safe_attributes
</span><span class="uncovered1"><a name="line2562"></a>2562       end
</span><span class="inferred0"><a name="line2563"></a>2563 
</span><span class="inferred1"><a name="line2564"></a>2564       # Removes attributes which have been marked as readonly.
</span><span class="marked0"><a name="line2565"></a>2565       def remove_readonly_attributes(attributes)
</span><span class="uncovered1"><a name="line2566"></a>2566         unless self.class.readonly_attributes.nil?
</span><span class="uncovered0"><a name="line2567"></a>2567           attributes.delete_if { |key, value| self.class.readonly_attributes.include?(key.gsub(/\(.+/,&quot;&quot;)) }
</span><span class="uncovered1"><a name="line2568"></a>2568         else
</span><span class="uncovered0"><a name="line2569"></a>2569           attributes
</span><span class="uncovered1"><a name="line2570"></a>2570         end
</span><span class="uncovered0"><a name="line2571"></a>2571       end
</span><span class="inferred1"><a name="line2572"></a>2572 
</span><span class="inferred0"><a name="line2573"></a>2573       # The primary key and inheritance column can never be set by mass-assignment for security reasons.
</span><span class="marked1"><a name="line2574"></a>2574       def attributes_protected_by_default
</span><span class="uncovered0"><a name="line2575"></a>2575         default = [ self.class.primary_key, self.class.inheritance_column ]
</span><span class="uncovered1"><a name="line2576"></a>2576         default &lt;&lt; 'id' unless self.class.primary_key.eql? 'id'
</span><span class="uncovered0"><a name="line2577"></a>2577         default
</span><span class="uncovered1"><a name="line2578"></a>2578       end
</span><span class="inferred0"><a name="line2579"></a>2579 
</span><span class="inferred1"><a name="line2580"></a>2580       # Returns a copy of the attributes hash where all the values have been safely quoted for use in
</span><span class="inferred0"><a name="line2581"></a>2581       # an SQL statement.
</span><span class="marked1"><a name="line2582"></a>2582       def attributes_with_quotes(include_primary_key = true, include_readonly_attributes = true, attribute_names = @attributes.keys)
</span><span class="uncovered0"><a name="line2583"></a>2583         quoted = {}
</span><span class="uncovered1"><a name="line2584"></a>2584         connection = self.class.connection
</span><span class="uncovered0"><a name="line2585"></a>2585         attribute_names.each do |name|
</span><span class="uncovered1"><a name="line2586"></a>2586           if (column = column_for_attribute(name)) &amp;&amp; (include_primary_key || !column.primary)
</span><span class="uncovered0"><a name="line2587"></a>2587             value = read_attribute(name)
</span><span class="uncovered1"><a name="line2588"></a>2588 
</span><span class="uncovered0"><a name="line2589"></a>2589             # We need explicit to_yaml because quote() does not properly convert Time/Date fields to YAML.
</span><span class="uncovered1"><a name="line2590"></a>2590             if value &amp;&amp; self.class.serialized_attributes.has_key?(name) &amp;&amp; (value.acts_like?(:date) || value.acts_like?(:time))
</span><span class="uncovered0"><a name="line2591"></a>2591               value = value.to_yaml
</span><span class="uncovered1"><a name="line2592"></a>2592             end
</span><span class="uncovered0"><a name="line2593"></a>2593 
</span><span class="uncovered1"><a name="line2594"></a>2594             quoted[name] = connection.quote(value, column)
</span><span class="uncovered0"><a name="line2595"></a>2595           end
</span><span class="uncovered1"><a name="line2596"></a>2596         end
</span><span class="uncovered0"><a name="line2597"></a>2597         include_readonly_attributes ? quoted : remove_readonly_attributes(quoted)
</span><span class="uncovered1"><a name="line2598"></a>2598       end
</span><span class="inferred0"><a name="line2599"></a>2599 
</span><span class="inferred1"><a name="line2600"></a>2600       # Quote strings appropriately for SQL statements.
</span><span class="marked0"><a name="line2601"></a>2601       def quote_value(value, column = nil)
</span><span class="uncovered1"><a name="line2602"></a>2602         self.class.connection.quote(value, column)
</span><span class="uncovered0"><a name="line2603"></a>2603       end
</span><span class="inferred1"><a name="line2604"></a>2604 
</span><span class="inferred0"><a name="line2605"></a>2605       # Interpolate custom SQL string in instance context.
</span><span class="inferred1"><a name="line2606"></a>2606       # Optional record argument is meant for custom insert_sql.
</span><span class="marked0"><a name="line2607"></a>2607       def interpolate_sql(sql, record = nil)
</span><span class="uncovered1"><a name="line2608"></a>2608         instance_eval(&quot;%@#{sql.gsub('@', '\@')}@&quot;)
</span><span class="uncovered0"><a name="line2609"></a>2609       end
</span><span class="inferred1"><a name="line2610"></a>2610 
</span><span class="inferred0"><a name="line2611"></a>2611       # Initializes the attributes array with keys matching the columns from the linked table and
</span><span class="inferred1"><a name="line2612"></a>2612       # the values matching the corresponding default value of that column, so
</span><span class="inferred0"><a name="line2613"></a>2613       # that a new instance, or one populated from a passed-in Hash, still has all the attributes
</span><span class="inferred1"><a name="line2614"></a>2614       # that instances loaded from the database would.
</span><span class="marked0"><a name="line2615"></a>2615       def attributes_from_column_definition
</span><span class="uncovered1"><a name="line2616"></a>2616         self.class.columns.inject({}) do |attributes, column|
</span><span class="uncovered0"><a name="line2617"></a>2617           attributes[column.name] = column.default unless column.name == self.class.primary_key
</span><span class="uncovered1"><a name="line2618"></a>2618           attributes
</span><span class="uncovered0"><a name="line2619"></a>2619         end
</span><span class="uncovered1"><a name="line2620"></a>2620       end
</span><span class="inferred0"><a name="line2621"></a>2621 
</span><span class="inferred1"><a name="line2622"></a>2622       # Instantiates objects for all attribute classes that needs more than one constructor parameter. This is done
</span><span class="inferred0"><a name="line2623"></a>2623       # by calling new on the column type or aggregation type (through composed_of) object with these parameters.
</span><span class="inferred1"><a name="line2624"></a>2624       # So having the pairs written_on(1) = &quot;2004&quot;, written_on(2) = &quot;6&quot;, written_on(3) = &quot;24&quot;, will instantiate
</span><span class="inferred0"><a name="line2625"></a>2625       # written_on (a date type) with Date.new(&quot;2004&quot;, &quot;6&quot;, &quot;24&quot;). You can also specify a typecast character in the
</span><span class="inferred1"><a name="line2626"></a>2626       # parentheses to have the parameters typecasted before they're used in the constructor. Use i for Fixnum, f for Float,
</span><span class="inferred0"><a name="line2627"></a>2627       # s for String, and a for Array. If all the values for a given attribute are empty, the attribute will be set to nil.
</span><span class="marked1"><a name="line2628"></a>2628       def assign_multiparameter_attributes(pairs)
</span><span class="uncovered0"><a name="line2629"></a>2629         execute_callstack_for_multiparameter_attributes(
</span><span class="uncovered1"><a name="line2630"></a>2630           extract_callstack_for_multiparameter_attributes(pairs)
</span><span class="uncovered0"><a name="line2631"></a>2631         )
</span><span class="uncovered1"><a name="line2632"></a>2632       end
</span><span class="inferred0"><a name="line2633"></a>2633 
</span><span class="marked1"><a name="line2634"></a>2634       def instantiate_time_object(name, values)
</span><span class="uncovered0"><a name="line2635"></a>2635         if self.class.time_zone_aware_attributes &amp;&amp; !self.class.skip_time_zone_conversion_for_attributes.include?(name.to_sym)
</span><span class="uncovered1"><a name="line2636"></a>2636           Time.zone.local(*values)
</span><span class="uncovered0"><a name="line2637"></a>2637         else
</span><span class="uncovered1"><a name="line2638"></a>2638           Time.time_with_datetime_fallback(@@default_timezone, *values)
</span><span class="uncovered0"><a name="line2639"></a>2639         end
</span><span class="uncovered1"><a name="line2640"></a>2640       end
</span><span class="inferred0"><a name="line2641"></a>2641 
</span><span class="marked1"><a name="line2642"></a>2642       def execute_callstack_for_multiparameter_attributes(callstack)
</span><span class="uncovered0"><a name="line2643"></a>2643         errors = []
</span><span class="uncovered1"><a name="line2644"></a>2644         callstack.each do |name, values|
</span><span class="uncovered0"><a name="line2645"></a>2645           klass = (self.class.reflect_on_aggregation(name.to_sym) || column_for_attribute(name)).klass
</span><span class="uncovered1"><a name="line2646"></a>2646           if values.empty?
</span><span class="uncovered0"><a name="line2647"></a>2647             send(name + &quot;=&quot;, nil)
</span><span class="uncovered1"><a name="line2648"></a>2648           else
</span><span class="uncovered0"><a name="line2649"></a>2649             begin
</span><span class="uncovered1"><a name="line2650"></a>2650               value = if Time == klass
</span><span class="uncovered0"><a name="line2651"></a>2651                 instantiate_time_object(name, values)
</span><span class="uncovered1"><a name="line2652"></a>2652               elsif Date == klass
</span><span class="uncovered0"><a name="line2653"></a>2653                 begin
</span><span class="uncovered1"><a name="line2654"></a>2654                   Date.new(*values)
</span><span class="uncovered0"><a name="line2655"></a>2655                 rescue ArgumentError =&gt; ex # if Date.new raises an exception on an invalid date
</span><span class="uncovered1"><a name="line2656"></a>2656                   instantiate_time_object(name, values).to_date # we instantiate Time object and convert it back to a date thus using Time's logic in handling invalid dates
</span><span class="uncovered0"><a name="line2657"></a>2657                 end
</span><span class="uncovered1"><a name="line2658"></a>2658               else
</span><span class="uncovered0"><a name="line2659"></a>2659                 klass.new(*values)
</span><span class="uncovered1"><a name="line2660"></a>2660               end
</span><span class="uncovered0"><a name="line2661"></a>2661 
</span><span class="uncovered1"><a name="line2662"></a>2662               send(name + &quot;=&quot;, value)
</span><span class="uncovered0"><a name="line2663"></a>2663             rescue =&gt; ex
</span><span class="uncovered1"><a name="line2664"></a>2664               errors &lt;&lt; AttributeAssignmentError.new(&quot;error on assignment #{values.inspect} to #{name}&quot;, ex, name)
</span><span class="uncovered0"><a name="line2665"></a>2665             end
</span><span class="uncovered1"><a name="line2666"></a>2666           end
</span><span class="uncovered0"><a name="line2667"></a>2667         end
</span><span class="uncovered1"><a name="line2668"></a>2668         unless errors.empty?
</span><span class="uncovered0"><a name="line2669"></a>2669           raise MultiparameterAssignmentErrors.new(errors), &quot;#{errors.size} error(s) on assignment of multiparameter attributes&quot;
</span><span class="uncovered1"><a name="line2670"></a>2670         end
</span><span class="uncovered0"><a name="line2671"></a>2671       end
</span><span class="inferred1"><a name="line2672"></a>2672 
</span><span class="marked0"><a name="line2673"></a>2673       def extract_callstack_for_multiparameter_attributes(pairs)
</span><span class="uncovered1"><a name="line2674"></a>2674         attributes = { }
</span><span class="uncovered0"><a name="line2675"></a>2675 
</span><span class="uncovered1"><a name="line2676"></a>2676         for pair in pairs
</span><span class="uncovered0"><a name="line2677"></a>2677           multiparameter_name, value = pair
</span><span class="uncovered1"><a name="line2678"></a>2678           attribute_name = multiparameter_name.split(&quot;(&quot;).first
</span><span class="uncovered0"><a name="line2679"></a>2679           attributes[attribute_name] = [] unless attributes.include?(attribute_name)
</span><span class="uncovered1"><a name="line2680"></a>2680 
</span><span class="uncovered0"><a name="line2681"></a>2681           unless value.empty?
</span><span class="uncovered1"><a name="line2682"></a>2682             attributes[attribute_name] &lt;&lt;
</span><span class="uncovered0"><a name="line2683"></a>2683               [ find_parameter_position(multiparameter_name), type_cast_attribute_value(multiparameter_name, value) ]
</span><span class="uncovered1"><a name="line2684"></a>2684           end
</span><span class="uncovered0"><a name="line2685"></a>2685         end
</span><span class="uncovered1"><a name="line2686"></a>2686 
</span><span class="uncovered0"><a name="line2687"></a>2687         attributes.each { |name, values| attributes[name] = values.sort_by{ |v| v.first }.collect { |v| v.last } }
</span><span class="uncovered1"><a name="line2688"></a>2688       end
</span><span class="inferred0"><a name="line2689"></a>2689 
</span><span class="marked1"><a name="line2690"></a>2690       def type_cast_attribute_value(multiparameter_name, value)
</span><span class="uncovered0"><a name="line2691"></a>2691         multiparameter_name =~ /\([0-9]*([a-z])\)/ ? value.send(&quot;to_&quot; + $1) : value
</span><span class="uncovered1"><a name="line2692"></a>2692       end
</span><span class="inferred0"><a name="line2693"></a>2693 
</span><span class="marked1"><a name="line2694"></a>2694       def find_parameter_position(multiparameter_name)
</span><span class="uncovered0"><a name="line2695"></a>2695         multiparameter_name.scan(/\(([0-9]*).*\)/).first.first
</span><span class="uncovered1"><a name="line2696"></a>2696       end
</span><span class="inferred0"><a name="line2697"></a>2697 
</span><span class="inferred1"><a name="line2698"></a>2698       # Returns a comma-separated pair list, like &quot;key1 = val1, key2 = val2&quot;.
</span><span class="marked0"><a name="line2699"></a>2699       def comma_pair_list(hash)
</span><span class="uncovered1"><a name="line2700"></a>2700         hash.inject([]) { |list, pair| list &lt;&lt; &quot;#{pair.first} = #{pair.last}&quot; }.join(&quot;, &quot;)
</span><span class="uncovered0"><a name="line2701"></a>2701       end
</span><span class="inferred1"><a name="line2702"></a>2702 
</span><span class="marked0"><a name="line2703"></a>2703       def quoted_column_names(attributes = attributes_with_quotes)
</span><span class="uncovered1"><a name="line2704"></a>2704         connection = self.class.connection
</span><span class="uncovered0"><a name="line2705"></a>2705         attributes.keys.collect do |column_name|
</span><span class="uncovered1"><a name="line2706"></a>2706           connection.quote_column_name(column_name)
</span><span class="uncovered0"><a name="line2707"></a>2707         end
</span><span class="uncovered1"><a name="line2708"></a>2708       end
</span><span class="inferred0"><a name="line2709"></a>2709 
</span><span class="marked1"><a name="line2710"></a>2710       def self.quoted_table_name
</span><span class="uncovered0"><a name="line2711"></a>2711         self.connection.quote_table_name(self.table_name)
</span><span class="uncovered1"><a name="line2712"></a>2712       end
</span><span class="inferred0"><a name="line2713"></a>2713 
</span><span class="marked1"><a name="line2714"></a>2714       def quote_columns(quoter, hash)
</span><span class="uncovered0"><a name="line2715"></a>2715         hash.inject({}) do |quoted, (name, value)|
</span><span class="uncovered1"><a name="line2716"></a>2716           quoted[quoter.quote_column_name(name)] = value
</span><span class="uncovered0"><a name="line2717"></a>2717           quoted
</span><span class="uncovered1"><a name="line2718"></a>2718         end
</span><span class="uncovered0"><a name="line2719"></a>2719       end
</span><span class="inferred1"><a name="line2720"></a>2720 
</span><span class="marked0"><a name="line2721"></a>2721       def quoted_comma_pair_list(quoter, hash)
</span><span class="uncovered1"><a name="line2722"></a>2722         comma_pair_list(quote_columns(quoter, hash))
</span><span class="uncovered0"><a name="line2723"></a>2723       end
</span><span class="inferred1"><a name="line2724"></a>2724 
</span><span class="marked0"><a name="line2725"></a>2725       def object_from_yaml(string)
</span><span class="uncovered1"><a name="line2726"></a>2726         return string unless string.is_a?(String)
</span><span class="uncovered0"><a name="line2727"></a>2727         YAML::load(string) rescue string
</span><span class="uncovered1"><a name="line2728"></a>2728       end
</span><span class="inferred0"><a name="line2729"></a>2729 
</span><span class="marked1"><a name="line2730"></a>2730       def clone_attributes(reader_method = :read_attribute, attributes = {})
</span><span class="uncovered0"><a name="line2731"></a>2731         self.attribute_names.inject(attributes) do |attrs, name|
</span><span class="uncovered1"><a name="line2732"></a>2732           attrs[name] = clone_attribute_value(reader_method, name)
</span><span class="uncovered0"><a name="line2733"></a>2733           attrs
</span><span class="uncovered1"><a name="line2734"></a>2734         end
</span><span class="uncovered0"><a name="line2735"></a>2735       end
</span><span class="inferred1"><a name="line2736"></a>2736 
</span><span class="marked0"><a name="line2737"></a>2737       def clone_attribute_value(reader_method, attribute_name)
</span><span class="uncovered1"><a name="line2738"></a>2738         value = send(reader_method, attribute_name)
</span><span class="uncovered0"><a name="line2739"></a>2739         value.duplicable? ? value.clone : value
</span><span class="uncovered1"><a name="line2740"></a>2740       rescue TypeError, NoMethodError
</span><span class="uncovered0"><a name="line2741"></a>2741         value
</span><span class="uncovered1"><a name="line2742"></a>2742       end
</span><span class="uncovered0"><a name="line2743"></a>2743   end
</span><span class="uncovered1"><a name="line2744"></a>2744 end
</span></pre><hr/>
    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a>
   version 0.8.1.2.</p>
<p><a href='http://validator.w3.org/check/referer'><img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88'/>
        </a>
      <a href='http://jigsaw.w3.org/css-validator/check/referer'><img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px'/>
        </a>
      </p>
    </body>
  </html>
